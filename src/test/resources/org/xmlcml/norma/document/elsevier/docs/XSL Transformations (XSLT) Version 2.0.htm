<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html lang="EN" xmlns="http://www.w3.org/1999/xhtml" xml:lang="EN">
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 1st December 2004), see www.w3.org" />

  <title>XSL Transformations (XSLT) Version 2.0</title>
<style type="text/css">
/*<![CDATA[*/
code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

div.issue
p.title        { margin-left: -2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }

li p           { margin-top: 0.3em;
                 margin-bottom: 0.3em; }

sup small      { font-style: italic;
                 color: #8F8F8F;
               }
    
div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

div.issue { border-bottom-color: black;
            border-bottom-style: solid;
            border-bottom-width: 1pt;
            margin-bottom: 20pt;
}

th.issue-toc-head { border-bottom-color: black;
                    border-bottom-style: solid;
                    border-bottom-width: 1pt;
}

      
dd.indent { margin-left: 2em; }
p.element-syntax { border: solid thin; background-color: #ffccff }
div.proto { border: solid thin; background-color: #ffccff }
div.example { border: solid thin; background-color: #40e0d0; padding: 1em }
span.verb { font: small-caps 100% sans-serif } 
span.error { font-size: small } 
span.definition { font: small-caps 100% sans-serif } 
span.grayed { color: gray }
/*]]>*/
</style>
  <link rel="stylesheet" type="text/css" href=
  "http://www.w3.org/StyleSheets/TR/W3C-REC.css" />
</head>

<body>
  <div class="head">
    <p><a href="http://www.w3.org/"><img src=
    "http://www.w3.org/Icons/w3c_home" alt="W3C" height="48" width=
    "72" /></a></p>

    <h1><a name="title" id="title"></a>XSL Transformations (XSLT)
    Version 2.0</h1>

    <h2><a name="w3c-doctype" id="w3c-doctype"></a>W3C
    Recommendation 23 January 2007</h2>

    <dl>
      <dt>This version:</dt>

      <dd><a href=
      "http://www.w3.org/TR/2007/REC-xslt20-20070123/">http://www.w3.org/TR/2007/REC-xslt20-20070123/</a></dd>

      <dt>Latest version:</dt>

      <dd><a href=
      "http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a><br />
      </dd>

      <dt>Previous version:</dt>

      <dd><a href=
      "http://www.w3.org/TR/2006/PR-xslt20-20061121/">http://www.w3.org/TR/2006/PR-xslt20-20061121/</a><br />
      </dd>

      <dt>Editor:</dt>

      <dd>Michael Kay, Saxonica <a href=
      "http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd>
    </dl>

    <p>Please refer to the <a href=
    "http://www.w3.org/XML/2007/qt-errata/xslt-errata.html"><strong>
    errata</strong></a> for this document, which may include some
    normative corrections.</p>

    <p>See also <a href=
    "http://www.w3.org/2003/03/Translations/byTechnology?technology=xslt20">
    <strong>translations</strong></a>.</p>

    <p class="copyright"><a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&#160;©&#160;2007&#160;<a href="http://www.w3.org/">
    <acronym title=
    "World Wide Web Consortium">W3C</acronym></a><sup>®</sup>
    (<a href="http://www.csail.mit.edu/"><acronym title=
    "Massachusetts Institute of Technology">MIT</acronym></a>,
    <a href="http://www.ercim.org/"><acronym title=
    "European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>,
    <a href="http://www.keio.ac.jp/">Keio</a>), All Rights
    Reserved. W3C <a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">
    liability</a>, <a href=
    "http://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a>
    and <a href=
    "http://www.w3.org/Consortium/Legal/copyright-documents">document
    use</a> rules apply.</p>
  </div>
  <hr />

  <div>
    <h2><a name="abstract" id="abstract"></a>Abstract</h2>

    <p>This specification defines the syntax and semantics of XSLT
    2.0, a language for transforming XML documents into other XML
    documents.</p>

    <p>XSLT 2.0 is a revised version of the XSLT 1.0 Recommendation
    <a href="#xslt">[XSLT 1.0]</a> published on 16 November
    1999.</p>

    <p>XSLT 2.0 is designed to be used in conjunction with XPath
    2.0, which is defined in <a href="#xpath20">[XPath 2.0]</a>.
    XSLT shares the same data model as XPath 2.0, which is defined
    in <a href="#xpath-datamodel">[Data Model]</a>, and it uses the
    library of functions and operators defined in <a href=
    "#xpath-functions">[Functions and Operators]</a>.</p>

    <p>XSLT 2.0 also includes optional facilities to serialize the
    results of a transformation, by means of an interface to the
    serialization component described in <a href=
    "#xslt-xquery-serialization">[XSLT and XQuery
    Serialization]</a>.</p>

    <p><em>This document contains hyperlinks to specific sections
    or definitions within other documents in this family of
    specifications. These links are indicated visually by a
    superscript identifying the target specification: for example
    XP for XPath, DM for the XDM data model, FO for Functions and
    Operators.</em></p>
  </div>

  <div>
    <h2><a name="status" id="status"></a>Status of this
    Document</h2>

    <p><em>This section describes the status of this document at
    the time of its publication. Other documents may supersede this
    document. A list of current W3C publications and the latest
    revision of this technical report can be found in the <a href=
    "http://www.w3.org/TR/">W3C technical reports index</a> at
    http://www.w3.org/TR/.</em></p>

    <p>This <a href=
    "http://www.w3.org/2004/02/Process-20040205/tr.html#RecsW3C">Recommendation</a>
    builds on the success of <a href="#xslt">[XSLT 1.0]</a>, which
    was published on 16 November 1999. Many new features have been
    added to the language (see <a href="#changes-since-1.0"><i>J.2
    New Functionality</i></a>) while retaining a high level of
    backwards compatibility (see <a href=
    "#incompatibilities"><i>J.1 Incompatible Changes</i></a>). The
    changes have been designed to meet the requirements for XSLT
    2.0 described in <a href="#xslt20req">[XSLT 2.0
    Requirements]</a>. The way in which each requirement has been
    addressed is outlined in <a href="#requirements-checklist"><i>I
    Checklist of Requirements</i></a>.</p>

    <p>XSLT 2.0 depends on a number of other specifications that
    have progressed to Recommendation status at the same time: see
    <a href="#xpath20">[XPath 2.0]</a>, <a href=
    "#xpath-datamodel">[Data Model]</a>, <a href=
    "#xpath-functions">[Functions and Operators]</a>, and <a href=
    "#xslt-xquery-serialization">[XSLT and XQuery
    Serialization]</a>. These subsidiary documents are also
    referenced in the specification of XQuery 1.0.</p>

    <p>This document has been produced by the <a href=
    "http://www.w3.org/Style/XSL/">XSL Working Group</a>, which is
    part of the <a href="http://www.w3.org/XML/Activity">XML
    Activity</a>. The document has been reviewed by W3C Members and
    other interested parties, and is endorsed by the Director. It
    is a stable document and may be used as reference material or
    cited as a normative reference from another document. W3C's
    role in making the Recommendation is to draw attention to the
    specification and to promote its widespread deployment. This
    enhances the functionality and interoperability of the Web.</p>

    <p>A small number of editorial corrections and clarifications
    have been made to the document since it <a href=
    "http://www.w3.org/TR/2006/PR-xslt20-20061121/">was
    published</a> as a <a href=
    "http://www.w3.org/2004/02/Process-20040205/tr.html#RecsPR">Proposed
    Recommendation</a> on 21 November 2006. These changes are
    listed at <a href="#changes-2007-01"><i>J.2.4 Changes since
    Proposed Recommendation</i></a>.</p>

    <p>Please record any comments about this document in W3C's
    <a href="http://www.w3.org/Bugs/Public/">public Bugzilla
    system</a> (instructions can be found at <a href=
    "http://www.w3.org/XML/2005/04/qt-bugzilla">http://www.w3.org/XML/2005/04/qt-bugzilla</a>).
    If access to that system is not feasible, you may send your
    comments to the W3C XSLT/XPath/XQuery public comments mailing
    list, <a href=
    "mailto:public-qt-comments@w3.org">public-qt-comments@w3.org</a>.
    It is helpful to include the string [XSLT] in the subject line
    of your comment, whether made in Bugzilla or in email. Each
    Bugzilla entry and email message should contain only one
    comment. Archives of the comments and responses are available
    at <a href=
    "http://lists.w3.org/Archives/Public/public-qt-comments/">http://lists.w3.org/Archives/Public/public-qt-comments/</a>.</p>

    <p>General public discussion of XSLT takes place on the
    <a href="http://www.mulberrytech.com/xsl/xsl-list/index.html">XSL-List</a>
    forum.</p>

    <p>This document was produced by a group operating under the
    <a href=
    "http://www.w3.org/Consortium/Patent-Policy-20040205/">5
    February 2004 W3C Patent Policy</a>. W3C maintains a <a href=
    "http://www.w3.org/2004/01/pp-impl/19552/status#disclosures">public
    list of any patent disclosures</a> made in connection with the
    deliverables of the group; that page also includes instructions
    for disclosing a patent. An individual who has actual knowledge
    of a patent which the individual believes contains <a href=
    "http://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">
    Essential Claim(s)</a> must disclose the information in
    accordance with <a href=
    "http://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">
    section 6 of the W3C Patent Policy</a>.</p>
  </div>

  <div class="toc">
    <h2><a name="contents" id="contents"></a>Table of Contents</h2>

    <p class="toc">1 <a href="#introduction">Introduction</a><br />
    &#160;&#160;&#160;&#160;1.1 <a href="#what-is-xslt">What is
    XSLT?</a><br />
    &#160;&#160;&#160;&#160;1.2 <a href=
    "#whats-new-in-xslt2">What's New in XSLT 2.0?</a><br />
    2 <a href="#concepts">Concepts</a><br />
    &#160;&#160;&#160;&#160;2.1 <a href=
    "#terminology">Terminology</a><br />
    &#160;&#160;&#160;&#160;2.2 <a href=
    "#notation">Notation</a><br />
    &#160;&#160;&#160;&#160;2.3 <a href="#initiating">Initiating a
    Transformation</a><br />
    &#160;&#160;&#160;&#160;2.4 <a href=
    "#executing-a-transformation">Executing a
    Transformation</a><br />
    &#160;&#160;&#160;&#160;2.5 <a href="#context">The Evaluation
    Context</a><br />
    &#160;&#160;&#160;&#160;2.6 <a href=
    "#parsing-and-serialization">Parsing and
    Serialization</a><br />
    &#160;&#160;&#160;&#160;2.7 <a href=
    "#extensibility">Extensibility</a><br />
    &#160;&#160;&#160;&#160;2.8 <a href=
    "#stylesheets-and-schemas">Stylesheets and XML
    Schemas</a><br />
    &#160;&#160;&#160;&#160;2.9 <a href="#errors">Error
    Handling</a><br />
    3 <a href="#stylesheet-structure">Stylesheet
    Structure</a><br />
    &#160;&#160;&#160;&#160;3.1 <a href="#xslt-namespace">XSLT
    Namespace</a><br />
    &#160;&#160;&#160;&#160;3.2 <a href=
    "#reserved-namespaces">Reserved Namespaces</a><br />
    &#160;&#160;&#160;&#160;3.3 <a href=
    "#extension-attributes">Extension Attributes</a><br />
    &#160;&#160;&#160;&#160;3.4 <a href="#xslt-media-type">XSLT
    Media Type</a><br />
    &#160;&#160;&#160;&#160;3.5 <a href=
    "#standard-attributes">Standard Attributes</a><br />
    &#160;&#160;&#160;&#160;3.6 <a href=
    "#stylesheet-element">Stylesheet Element</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.1 <a href=
    "#default-collation-attribute">The default-collation
    attribute</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.6.2 <a href=
    "#user-defined-top-level">User-defined Data Elements</a><br />
    &#160;&#160;&#160;&#160;3.7 <a href=
    "#simplified-stylesheet">Simplified Stylesheet
    Modules</a><br />
    &#160;&#160;&#160;&#160;3.8 <a href=
    "#backwards">Backwards-Compatible Processing</a><br />
    &#160;&#160;&#160;&#160;3.9 <a href=
    "#forwards">Forwards-Compatible Processing</a><br />
    &#160;&#160;&#160;&#160;3.10 <a href=
    "#combining-modules">Combining Stylesheet Modules</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.1 <a href=
    "#locating-modules">Locating Stylesheet Modules</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.2 <a href=
    "#include">Stylesheet Inclusion</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;3.10.3 <a href=
    "#import">Stylesheet Import</a><br />
    &#160;&#160;&#160;&#160;3.11 <a href="#embedded">Embedded
    Stylesheet Modules</a><br />
    &#160;&#160;&#160;&#160;3.12 <a href=
    "#conditional-inclusion">Conditional Element
    Inclusion</a><br />
    &#160;&#160;&#160;&#160;3.13 <a href="#built-in-types">Built-in
    Types</a><br />
    &#160;&#160;&#160;&#160;3.14 <a href="#import-schema">Importing
    Schema Components</a><br />
    4 <a href="#data-model">Data Model</a><br />
    &#160;&#160;&#160;&#160;4.1 <a href="#xml-versions">XML
    Versions</a><br />
    &#160;&#160;&#160;&#160;4.2 <a href=
    "#stylesheet-stripping">Stripping Whitespace from the
    Stylesheet</a><br />
    &#160;&#160;&#160;&#160;4.3 <a href=
    "#stripping-annotations">Stripping Type Annotations from a
    Source Tree</a><br />
    &#160;&#160;&#160;&#160;4.4 <a href="#strip">Stripping
    Whitespace from a Source Tree</a><br />
    &#160;&#160;&#160;&#160;4.5 <a href=
    "#id-in-data-model">Attribute Types and DTD
    Validation</a><br />
    &#160;&#160;&#160;&#160;4.6 <a href="#limits">Limits</a><br />
    &#160;&#160;&#160;&#160;4.7 <a href=
    "#d-o-e-in-data-model">Disable Output Escaping</a><br />
    5 <a href="#constructs">Features of the XSLT Language</a><br />
    &#160;&#160;&#160;&#160;5.1 <a href="#qname">Qualified
    Names</a><br />
    &#160;&#160;&#160;&#160;5.2 <a href=
    "#unprefixed-qnames">Unprefixed QNames in Expressions and
    Patterns</a><br />
    &#160;&#160;&#160;&#160;5.3 <a href=
    "#expressions">Expressions</a><br />
    &#160;&#160;&#160;&#160;5.4 <a href=
    "#static-and-dynamic-context">The Static and Dynamic
    Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.1 <a href=
    "#static-context">Initializing the Static Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.2 <a href=
    "#additional-static-context">Additional Static Context
    Components used by XSLT</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3 <a href=
    "#xpath-dynamic-context">Initializing the Dynamic
    Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.1
    <a href="#focus">Maintaining Position: the Focus</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.3.2
    <a href="#evaluation-context">Other components of the XPath
    Dynamic Context</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.4.4 <a href=
    "#additional-dynamic-context">Additional Dynamic Context
    Components used by XSLT</a><br />
    &#160;&#160;&#160;&#160;5.5 <a href=
    "#patterns">Patterns</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.5.1 <a href=
    "#pattern-examples">Examples of Patterns</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.5.2 <a href=
    "#pattern-syntax">Syntax of Patterns</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.5.3 <a href=
    "#pattern-semantics">The Meaning of a Pattern</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.5.4 <a href=
    "#pattern-errors">Errors in Patterns</a><br />
    &#160;&#160;&#160;&#160;5.6 <a href=
    "#attribute-value-templates">Attribute Value
    Templates</a><br />
    &#160;&#160;&#160;&#160;5.7 <a href=
    "#sequence-constructors">Sequence Constructors</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.1 <a href=
    "#constructing-complex-content">Constructing Complex
    Content</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.2 <a href=
    "#constructing-simple-content">Constructing Simple
    Content</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;5.7.3 <a href=
    "#namespace-fixup">Namespace Fixup</a><br />
    &#160;&#160;&#160;&#160;5.8 <a href="#uri-references">URI
    References</a><br />
    6 <a href="#rules">Template Rules</a><br />
    &#160;&#160;&#160;&#160;6.1 <a href=
    "#defining-templates">Defining Templates</a><br />
    &#160;&#160;&#160;&#160;6.2 <a href=
    "#defining-template-rules">Defining Template Rules</a><br />
    &#160;&#160;&#160;&#160;6.3 <a href=
    "#applying-templates">Applying Template Rules</a><br />
    &#160;&#160;&#160;&#160;6.4 <a href="#conflict">Conflict
    Resolution for Template Rules</a><br />
    &#160;&#160;&#160;&#160;6.5 <a href="#modes">Modes</a><br />
    &#160;&#160;&#160;&#160;6.6 <a href="#built-in-rule">Built-in
    Template Rules</a><br />
    &#160;&#160;&#160;&#160;6.7 <a href="#apply-imports">Overriding
    Template Rules</a><br />
    7 <a href="#for-each">Repetition</a><br />
    8 <a href="#conditionals">Conditional Processing</a><br />
    &#160;&#160;&#160;&#160;8.1 <a href="#xsl-if">Conditional
    Processing with xsl:if</a><br />
    &#160;&#160;&#160;&#160;8.2 <a href="#xsl-choose">Conditional
    Processing with xsl:choose</a><br />
    9 <a href="#variables-and-parameters">Variables and
    Parameters</a><br />
    &#160;&#160;&#160;&#160;9.1 <a href=
    "#variables">Variables</a><br />
    &#160;&#160;&#160;&#160;9.2 <a href=
    "#parameters">Parameters</a><br />
    &#160;&#160;&#160;&#160;9.3 <a href="#variable-values">Values
    of Variables and Parameters</a><br />
    &#160;&#160;&#160;&#160;9.4 <a href="#temporary-trees">Creating
    implicit document nodes</a><br />
    &#160;&#160;&#160;&#160;9.5 <a href="#global-variables">Global
    Variables and Parameters</a><br />
    &#160;&#160;&#160;&#160;9.6 <a href="#local-variables">Local
    Variables and Parameters</a><br />
    &#160;&#160;&#160;&#160;9.7 <a href="#scope-of-variables">Scope
    of Variables</a><br />
    &#160;&#160;&#160;&#160;9.8 <a href="#circularity">Circular
    Definitions</a><br />
    10 <a href="#callable-components">Callable Components</a><br />
    &#160;&#160;&#160;&#160;10.1 <a href="#named-templates">Named
    Templates</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.1 <a href=
    "#with-param">Passing Parameters to Templates</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;10.1.2 <a href=
    "#tunnel-params">Tunnel Parameters</a><br />
    &#160;&#160;&#160;&#160;10.2 <a href="#attribute-sets">Named
    Attribute Sets</a><br />
    &#160;&#160;&#160;&#160;10.3 <a href=
    "#stylesheet-functions">Stylesheet Functions</a><br />
    11 <a href="#creating-new-nodes">Creating Nodes and
    Sequences</a><br />
    &#160;&#160;&#160;&#160;11.1 <a href=
    "#literal-result-element">Literal Result Elements</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.1 <a href=
    "#setting-annotation-for-lre">Setting the Type Annotation for
    Literal Result Elements</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.2 <a href=
    "#attributes-for-lres">Attribute Nodes for Literal Result
    Elements</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.3 <a href=
    "#lre-namespaces">Namespace Nodes for Literal Result
    Elements</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.1.4 <a href=
    "#namespace-aliasing">Namespace Aliasing</a><br />
    &#160;&#160;&#160;&#160;11.2 <a href="#xsl-element">Creating
    Element Nodes Using xsl:element</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.2.1 <a href=
    "#annotation-for-constructed-element">Setting the Type
    Annotation for a Constructed Element Node</a><br />
    &#160;&#160;&#160;&#160;11.3 <a href=
    "#creating-attributes">Creating Attribute Nodes Using
    xsl:attribute</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.3.1 <a href=
    "#annotation-for-constructed-attribute">Setting the Type
    Annotation for a Constructed Attribute Node</a><br />
    &#160;&#160;&#160;&#160;11.4 <a href=
    "#creating-text-nodes">Creating Text Nodes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.1 <a href=
    "#literal-text-nodes">Literal Text Nodes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.2 <a href=
    "#xsl-text">Creating Text Nodes Using xsl:text</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.4.3 <a href=
    "#value-of">Generating Text with xsl:value-of</a><br />
    &#160;&#160;&#160;&#160;11.5 <a href=
    "#creating-document-nodes">Creating Document Nodes</a><br />
    &#160;&#160;&#160;&#160;11.6 <a href=
    "#creating-processing-instructions">Creating Processing
    Instructions</a><br />
    &#160;&#160;&#160;&#160;11.7 <a href=
    "#creating-namespace-nodes">Creating Namespace Nodes</a><br />
    &#160;&#160;&#160;&#160;11.8 <a href=
    "#creating-comments">Creating Comments</a><br />
    &#160;&#160;&#160;&#160;11.9 <a href="#copying">Copying
    Nodes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.1 <a href=
    "#shallow-copy">Shallow Copy</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;11.9.2 <a href=
    "#copy-of">Deep Copy</a><br />
    &#160;&#160;&#160;&#160;11.10 <a href=
    "#constructing-sequences">Constructing Sequences</a><br />
    12 <a href="#number">Numbering</a><br />
    &#160;&#160;&#160;&#160;12.1 <a href=
    "#formatting-supplied-number">Formatting a Supplied
    Number</a><br />
    &#160;&#160;&#160;&#160;12.2 <a href=
    "#numbering-based-on-position">Numbering based on Position in a
    Document</a><br />
    &#160;&#160;&#160;&#160;12.3 <a href="#convert">Number to
    String Conversion Attributes</a><br />
    13 <a href="#sorting">Sorting</a><br />
    &#160;&#160;&#160;&#160;13.1 <a href="#xsl-sort">The xsl:sort
    Element</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.1 <a href=
    "#sorting-process">The Sorting Process</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.2 <a href=
    "#comparing-sort-keys">Comparing Sort Key Values</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;13.1.3 <a href=
    "#collating-sequences">Sorting Using Collations</a><br />
    &#160;&#160;&#160;&#160;13.2 <a href=
    "#creating-sorted-sequence">Creating a Sorted
    Sequence</a><br />
    &#160;&#160;&#160;&#160;13.3 <a href=
    "#sorted-iteration">Processing a Sequence in Sorted
    Order</a><br />
    14 <a href="#grouping">Grouping</a><br />
    &#160;&#160;&#160;&#160;14.1 <a href="#current-group">The
    Current Group</a><br />
    &#160;&#160;&#160;&#160;14.2 <a href=
    "#current-grouping-key">The Current Grouping Key</a><br />
    &#160;&#160;&#160;&#160;14.3 <a href="#xsl-for-each-group">The
    xsl:for-each-group Element</a><br />
    &#160;&#160;&#160;&#160;14.4 <a href=
    "#grouping-examples">Examples of Grouping</a><br />
    15 <a href="#regular-expressions">Regular Expressions</a><br />
    &#160;&#160;&#160;&#160;15.1 <a href="#analyze-string">The
    xsl:analyze-string instruction</a><br />
    &#160;&#160;&#160;&#160;15.2 <a href="#regex-group">Captured
    Substrings</a><br />
    &#160;&#160;&#160;&#160;15.3 <a href="#regex-examples">Examples
    of Regular Expression Matching</a><br />
    16 <a href="#add-func">Additional Functions</a><br />
    &#160;&#160;&#160;&#160;16.1 <a href="#document">Multiple
    Source Documents</a><br />
    &#160;&#160;&#160;&#160;16.2 <a href="#unparsed-text">Reading
    Text Files</a><br />
    &#160;&#160;&#160;&#160;16.3 <a href="#key">Keys</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.3.1 <a href=
    "#xsl-key">The xsl:key Declaration</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.3.2 <a href=
    "#keys">The key Function</a><br />
    &#160;&#160;&#160;&#160;16.4 <a href="#format-number">Number
    Formatting</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.4.1 <a href=
    "#defining-decimal-format">Defining a Decimal Format</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.4.2 <a href=
    "#processing-picture-string">Processing the Picture
    String</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.4.3 <a href=
    "#analysing-picture-string">Analysing the Picture
    String</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.4.4 <a href=
    "#formatting-the-number">Formatting the Number</a><br />
    &#160;&#160;&#160;&#160;16.5 <a href="#format-date">Formatting
    Dates and Times</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.5.1 <a href=
    "#date-picture-string">The Picture String</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.5.2 <a href=
    "#lang-cal-country">The Language, Calendar, and Country
    Arguments</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.5.3 <a href=
    "#date-time-examples">Examples of Date and Time
    Formatting</a><br />
    &#160;&#160;&#160;&#160;16.6 <a href="#misc-func">Miscellaneous
    Additional Functions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.6.1 <a href=
    "#current-function">current</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.6.2 <a href=
    "#unparsed-entity-uri">unparsed-entity-uri</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.6.3 <a href=
    "#unparsed-entity-public-id">unparsed-entity-public-id</a><br />

    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.6.4 <a href=
    "#generate-id">generate-id</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;16.6.5 <a href=
    "#system-property">system-property</a><br />
    17 <a href="#message">Messages</a><br />
    18 <a href="#extension">Extensibility and Fallback</a><br />
    &#160;&#160;&#160;&#160;18.1 <a href=
    "#extension-functions">Extension Functions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.1 <a href=
    "#testing-function-availability">Testing Availability of
    Functions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.2 <a href=
    "#calling-extension-functions">Calling Extension
    Functions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.3 <a href=
    "#external-objects">External Objects</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.1.4 <a href=
    "#testing-type-availability">Testing Availability of
    Types</a><br />
    &#160;&#160;&#160;&#160;18.2 <a href=
    "#extension-instruction">Extension Instructions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.1 <a href=
    "#designating-extension-namespace">Designating an Extension
    Namespace</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.2 <a href=
    "#testing-instruction-available">Testing Availability of
    Instructions</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;18.2.3 <a href=
    "#fallback">Fallback</a><br />
    19 <a href="#result-trees">Final Result Trees</a><br />
    &#160;&#160;&#160;&#160;19.1 <a href=
    "#creating-result-trees">Creating Final Result Trees</a><br />
    &#160;&#160;&#160;&#160;19.2 <a href=
    "#validation">Validation</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.2.1 <a href=
    "#validating-constructed-nodes">Validating Constructed Elements
    and Attributes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.2.1.1
    <a href="#validating-using-validation-attribute">Validation
    using the [xsl:]validation Attribute</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.2.1.2
    <a href="#validation-xsl-type">Validation using the [xsl:]type
    Attribute</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.2.1.3
    <a href="#validation-process">The Validation Process</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;19.2.2 <a href=
    "#validating-document-nodes">Validating Document
    Nodes</a><br />
    20 <a href="#serialization">Serialization</a><br />
    &#160;&#160;&#160;&#160;20.1 <a href=
    "#character-maps">Character Maps</a><br />
    &#160;&#160;&#160;&#160;20.2 <a href=
    "#disable-output-escaping">Disabling Output Escaping</a><br />
    21 <a href="#conformance">Conformance</a><br />
    &#160;&#160;&#160;&#160;21.1 <a href="#basic-conformance">Basic
    XSLT Processor</a><br />
    &#160;&#160;&#160;&#160;21.2 <a href=
    "#schema-aware-conformance">Schema-Aware XSLT
    Processor</a><br />
    &#160;&#160;&#160;&#160;21.3 <a href=
    "#serialization-feature">Serialization Feature</a><br />
    &#160;&#160;&#160;&#160;21.4 <a href=
    "#backwards-compatibility-feature">Backwards Compatibility
    Feature</a><br /></p>

    <h3><a name="appendices" id="appendices"></a>Appendices</h3>

    <p class="toc">A <a href="#references">References</a><br />
    &#160;&#160;&#160;&#160;A.1 <a href=
    "#normative-references">Normative References</a><br />
    &#160;&#160;&#160;&#160;A.2 <a href="#other-references">Other
    References</a><br />
    B <a href="#xslt-mime-definition">The XSLT Media Type</a><br />
    &#160;&#160;&#160;&#160;B.1 <a href=
    "#media-type-registration">Registration of MIME Media Type
    application/xslt+xml</a><br />
    &#160;&#160;&#160;&#160;B.2 <a href=
    "#media-type-fragid">Fragment Identifiers</a><br />
    C <a href="#glossary">Glossary</a> (Non-Normative)<br />
    D <a href="#element-syntax-summary">Element Syntax Summary</a>
    (Non-Normative)<br />
    E <a href="#error-summary">Summary of Error Conditions</a>
    (Non-Normative)<br />
    F <a href="#implementation-defined-features">Checklist of
    Implementation-Defined Features</a> (Non-Normative)<br />
    G <a href="#schema-for-xslt">Schema for XSLT Stylesheets</a>
    (Non-Normative)<br />
    H <a href="#acknowledgements">Acknowledgements</a>
    (Non-Normative)<br />
    I <a href="#requirements-checklist">Checklist of
    Requirements</a> (Non-Normative)<br />
    J <a href="#changes">Changes from XSLT 1.0</a>
    (Non-Normative)<br />
    &#160;&#160;&#160;&#160;J.1 <a href=
    "#incompatibilities">Incompatible Changes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.1 <a href=
    "#incompatibility-stripping">Tree construction: whitespace
    stripping</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.2 <a href=
    "#incompatibility-serialization">Changes in Serialization
    Behavior</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.3 <a href=
    "#backwards-compatibility-behavior">Backwards Compatibility
    Behavior</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.4 <a href=
    "#incompatibility-without-schema">Incompatibility in the
    Absence of a Schema</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.5 <a href=
    "#compatibility-with-schema">Compatibility in the Presence of a
    Schema</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.1.6 <a href=
    "#xpath-compatibility">XPath 2.0 Backwards
    Compatibility</a><br />
    &#160;&#160;&#160;&#160;J.2 <a href="#changes-since-1.0">New
    Functionality</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.1 <a href=
    "#pervasive-changes">Pervasive changes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.2 <a href=
    "#major-features">Major Features</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.3 <a href=
    "#minor-changes">Minor Changes</a><br />
    &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;J.2.4 <a href=
    "#changes-2007-01">Changes since Proposed
    Recommendation</a><br /></p>
  </div>
  <hr />

  <div class="body">
    <div class="div1">
      <h2><a name="introduction" id="introduction"></a>1
      Introduction</h2>

      <div class="div2">
        <h3><a name="what-is-xslt" id="what-is-xslt"></a>1.1 What
        is XSLT?</h3>

        <p>This specification defines the syntax and semantics of
        the XSLT 2.0 language.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-stylesheet" id="dt-stylesheet" title="stylesheet"></a>A
        transformation in the XSLT language is expressed in the
        form of a <b>stylesheet</b>, whose syntax is well-formed
        XML <a href="#REC-xml">[XML 1.0]</a> conforming to the
        Namespaces in XML Recommendation <a href=
        "#REC-xml-names">[Namespaces in XML 1.0]</a>.<span class=
        "definition">]</span></p>

        <p>A stylesheet generally includes elements that are
        defined by XSLT as well as elements that are not defined by
        XSLT. XSLT-defined elements are distinguished by use of the
        namespace <code>http://www.w3.org/1999/XSL/Transform</code>
        (see <a href="#xslt-namespace"><i>3.1 XSLT
        Namespace</i></a>), which is referred to in this
        specification as the <a title="XSLT namespace" href=
        "#dt-xslt-namespace">XSLT namespace</a>. Thus this
        specification is a definition of the syntax and semantics
        of the XSLT namespace.</p>

        <p>The term <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> reflects the fact that one
        of the important roles of XSLT is to add styling
        information to an XML source document, by transforming it
        into a document consisting of XSL formatting objects (see
        <a href="#xsl">[Extensible Stylesheet Language (XSL)]</a>),
        or into another presentation-oriented format such as HTML,
        XHTML, or SVG. However, XSLT is used for a wide range of
        transformation tasks, not exclusively for formatting and
        presentation applications.</p>

        <p>A transformation expressed in XSLT describes rules for
        transforming zero or more source trees into one or more
        result trees. The structure of these trees is described in
        <a href="#xpath-datamodel">[Data Model]</a>. The
        transformation is achieved by a set of <a title=
        "template rule" href="#dt-template-rule">template
        rules</a>. A template rule associates a <a title="pattern"
        href="#dt-pattern">pattern</a>, which matches nodes in the
        source document, with a <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>.
        In many cases, evaluating the sequence constructor will
        cause new nodes to be constructed, which can be used to
        produce part of a result tree. The structure of the result
        trees can be completely different from the structure of the
        source trees. In constructing a result tree, nodes from the
        source trees can be filtered and reordered, and arbitrary
        structure can be added. This mechanism allows a <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> to be
        applicable to a wide class of documents that have similar
        source tree structures.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-principal-stylesheet-module" id=
        "dt-principal-stylesheet-module" title=
        "principal stylesheet module"></a>A <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> may consist of several
        <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet modules</a>, contained
        in different XML documents. For a given transformation, one
        of these functions as the <b>principal stylesheet
        module</b>. The complete <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> is assembled by finding the
        <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet modules</a> referenced
        directly or indirectly from the principal stylesheet module
        using <a href=
        "#element-include"><code>xsl:include</code></a> and
        <a href="#element-import"><code>xsl:import</code></a>
        elements: see <a href="#include"><i>3.10.2 Stylesheet
        Inclusion</i></a> and <a href="#import"><i>3.10.3
        Stylesheet Import</i></a>.<span class=
        "definition">]</span></p>
      </div>

      <div class="div2">
        <h3><a name="whats-new-in-xslt2" id=
        "whats-new-in-xslt2"></a>1.2 What's New in XSLT 2.0?</h3>

        <p>XSLT 1.0 was published in November 1999, and version 2.0
        represents a significant increase in the capability of the
        language. A detailed list of changes is included in
        <a href="#changes"><i>J Changes from XSLT 1.0</i></a>. XSLT
        2.0 has been developed in parallel with XPath 2.0 (see
        <a href="#xpath20">[XPath 2.0]</a>), so the changes to
        XPath must be considered alongside the changes to XSLT.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="concepts" id="concepts"></a>2 Concepts</h2>

      <div class="div2">
        <h3><a name="terminology" id="terminology"></a>2.1
        Terminology</h3>

        <p>For a full glossary of terms, see <a href=
        "#glossary"><i>C Glossary</i></a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-processor" id="dt-processor" title="processor"></a>The
        software responsible for transforming source trees into
        result trees using an XSLT stylesheet is referred to as the
        <b>processor</b>. This is sometimes expanded to <em>XSLT
        processor</em> to avoid any confusion with other
        processors, for example an XML processor.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-implementation" id="dt-implementation" title=
        "implementation"></a>A specific product that performs the
        functions of an <a title="processor" href=
        "#dt-processor">XSLT processor</a> is referred to as an
        <b>implementation</b> <span class=
        "definition">]</span>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-result-tree" id="dt-result-tree" title=
        "result tree"></a>The term <b>result tree</b> is used to
        refer to any tree constructed by <a title="instruction"
        href="#dt-instruction">instructions</a> in the stylesheet.
        A result tree is either a <a title="final result tree"
        href="#dt-final-result-tree">final result tree</a> or a
        <a title="temporary tree" href=
        "#dt-temporary-tree">temporary tree</a>.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-final-result-tree" id="dt-final-result-tree" title=
        "final result tree"></a>A <b>final result tree</b> is a
        <a title="result tree" href="#dt-result-tree">result
        tree</a> that forms part of the final output of a
        transformation. Once created, the contents of a final
        result tree are not accessible within the stylesheet
        itself.<span class="definition">]</span> The <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction always creates a final result tree, and a final
        result tree may also be created implicitly by the <a title=
        "initial template" href="#dt-initial-template">initial
        template</a>. The conditions under which this happens are
        described in <a href="#executing-a-transformation"><i>2.4
        Executing a Transformation</i></a>. A final result tree
        <span class="verb">may</span> be serialized as described in
        <a href="#serialization"><i>20 Serialization</i></a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-source-tree" id="dt-source-tree" title=
        "source tree"></a>The term <b>source tree</b> means any
        tree provided as input to the transformation. This includes
        the document containing the <a title="initial context node"
        href="#dt-initial-context-node">initial context node</a> if
        any, documents containing nodes supplied as the values of
        <a title="stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameters</a>,
        documents obtained from the results of functions such as
        <a href="#function-document"><code>document</code></a>,
        <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup>, and <a href=
        "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
        collection</code></a><sup><small>FO</small></sup>, and
        documents returned by extension functions or extension
        instructions. In the context of a particular XSLT
        instruction, the term <b>source tree</b> means any tree
        provided as input to that instruction; this may be a source
        tree of the transformation as a whole, or it may be a
        <a title="temporary tree" href=
        "#dt-temporary-tree">temporary tree</a> produced during the
        course of the transformation.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-temporary-tree" id="dt-temporary-tree" title=
        "temporary tree"></a>The term <b>temporary tree</b> means
        any tree that is neither a <a title="source tree" href=
        "#dt-source-tree">source tree</a> nor a <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a>.<span class="definition">]</span> Temporary
        trees are used to hold intermediate results during the
        execution of the transformation.</p>

        <p>In this specification the phrases <span class=
        "verb">must</span>, <span class="verb">must not</span>,
        <span class="verb">should</span>, <span class="verb">should
        not</span>, <span class="verb">may</span>, <span class=
        "verb">required</span>, and <span class=
        "verb">recommended</span> are to be interpreted as
        described in <a href="#RFC2119">[RFC2119]</a>.</p>

        <p>Where the phrase <span class="verb">must</span>,
        <span class="verb">must not</span>, or <span class=
        "verb">required</span> relates to the behavior of the XSLT
        processor, then an implementation is not conformant unless
        it behaves as specified, subject to the more detailed rules
        in <a href="#conformance"><i>21 Conformance</i></a>.</p>

        <p>Where the phrase <span class="verb">must</span>,
        <span class="verb">must not</span>, or <span class=
        "verb">required</span> relates to a stylesheet, then the
        processor <span class="verb">must</span> enforce this
        constraint on stylesheets by reporting an error if the
        constraint is not satisfied.</p>

        <p>Where the phrase <span class="verb">should</span>,
        <span class="verb">should not</span>, or <span class=
        "verb">recommended</span> relates to a stylesheet, then a
        processor <span class="verb">may</span> produce warning
        messages if the constraint is not satisfied, but
        <span class="verb">must not</span> treat this as an
        error.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-implementation-defined" id="dt-implementation-defined"
        title="implementation-defined"></a>In this specification,
        the term <b>implementation-defined</b> refers to a feature
        where the implementation is allowed some flexibility, and
        where the choices made by the implementation <span class=
        "verb">must</span> be described in documentation that
        accompanies any conformance claim.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-implementation-dependent" id=
        "dt-implementation-dependent" title=
        "implementation-dependent"></a>The term
        <b>implementation-dependent</b> refers to a feature where
        the behavior <span class="verb">may</span> vary from one
        implementation to another, and where the vendor is not
        expected to provide a full specification of the
        behavior.<span class="definition">]</span> (This might
        apply, for example, to limits on the size of source
        documents that can be transformed.)</p>

        <p>In all cases where this specification leaves the
        behavior implementation-defined or
        implementation-dependent, the implementation has the option
        of providing mechanisms that allow the user to influence
        the behavior.</p>

        <p>A paragraph labeled as a <b>Note</b> or described as an
        <b>example</b> is non-normative.</p>

        <p>Many terms used in this document are defined in the
        XPath specification <a href="#xpath20">[XPath 2.0]</a> or
        the XDM specification <a href="#xpath-datamodel">[Data
        Model]</a>. Particular attention is drawn to the
        following:</p>

        <ul>
          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-atomization" id="dt-atomization" title=
            "atomize"></a>The term <b>atomization</b> is defined in
            <a href=
            "http://www.w3.org/TR/xpath20/#id-atomization">Section
            2.4.2 Atomization</a><sup><small>XP</small></sup>. It
            is a process that takes as input a sequence of nodes
            and atomic values, and returns a sequence of atomic
            values, in which the nodes are replaced by their typed
            values as defined in <a href="#xpath-datamodel">[Data
            Model]</a>.<span class="definition">]</span> For some
            nodes (for example, elements with element-only
            content), atomization generates a <a title=
            "dynamic error" href="#dt-dynamic-error">dynamic
            error</a>.</p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-typed-value" id="dt-typed-value" title=
            "typed value"></a>The term <b>typed value</b> is
            defined in <a href=
            "http://www.w3.org/TR/xpath-datamodel/#dm-typed-value">Section
            5.15 typed-value
            Accessor</a><sup><small>DM</small></sup>. Every node
            except an element defined in the schema with
            element-only content has a <a title="string value"
            href="#dt-string-value">typed value</a>. For example,
            the <a title="typed value" href="#dt-typed-value">typed
            value</a> of an attribute of type
            <code>xs:IDREFS</code> is a sequence of zero or more
            <code>xs:IDREF</code> values.<span class=
            "definition">]</span></p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-string-value" id="dt-string-value" title=
            "string value"></a>The term <b>string value</b> is
            defined in <a href=
            "http://www.w3.org/TR/xpath-datamodel/#dm-string-value">
            Section 5.13 string-value
            Accessor</a><sup><small>DM</small></sup>. Every node
            has a <a title="string value" href=
            "#dt-string-value">string value</a>. For example, the
            <a title="string value" href="#dt-string-value">string
            value</a> of an element is the concatenation of the
            <a title="string value" href="#dt-string-value">string
            values</a> of all its descendant text
            nodes.<span class="definition">]</span></p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-compatibility-mode" id="dt-compatibility-mode"
            title="XPath 1.0 compatibility mode"></a>The term
            <b>XPath 1.0 compatibility mode</b> is defined in
            <a href=
            "http://www.w3.org/TR/xpath20/#static_context">Section
            2.1.1 Static Context</a><sup><small>XP</small></sup>.
            This is a setting in the static context of an XPath
            expression; it has two values, <code>true</code> and
            <code>false</code>. When the value is set to true, the
            semantics of function calls and certain other
            operations are adjusted to give a greater degree of
            backwards compatibility between XPath 2.0 and XPath
            1.0.<span class="definition">]</span></p>
          </li>
        </ul>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-core-function" id="dt-core-function" title=
        "core function"></a>The term <b>core function</b> means a
        function that is specified in <a href=
        "#xpath-functions">[Functions and Operators]</a> and that
        is in the <a title="standard function namespace" href=
        "#dt-standard-function-namespace">standard function
        namespace</a>.<span class="definition">]</span></p>
      </div>

      <div class="div2">
        <h3><a name="notation" id="notation"></a>2.2 Notation</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-xslt-element" id="dt-xslt-element" title=
        "XSLT element"></a>An <b>XSLT element</b> is an element in
        the <a title="XSLT namespace" href=
        "#dt-xslt-namespace">XSLT namespace</a> whose syntax and
        semantics are defined in this specification.<span class=
        "definition">]</span> For a non-normative list of XSLT
        elements, see <a href="#element-syntax-summary"><i>D
        Element Syntax Summary</i></a>.</p>

        <p>In this document the specification of each <a title=
        "XSLT element" href="#dt-xslt-element">XSLT element</a> is
        preceded by a summary of its syntax in the form of a model
        for elements of that element type. A full list of all these
        specifications can be found in <a href=
        "#element-syntax-summary"><i>D Element Syntax
        Summary</i></a>. The meaning of syntax summary notation is
        as follows:</p>

        <ul>
          <li>
            <p>An attribute that is <span class=
            "verb">required</span> is shown with its name in bold.
            An attribute that may be omitted is shown with a
            question mark following its name.</p>
          </li>

          <li>
            <p>An attribute that is <a title="deprecated" href=
            "#dt-deprecated">deprecated</a> is shown in a grayed
            font within square brackets.</p>
          </li>

          <li>
            <p>The string that occurs in the place of an attribute
            value specifies the allowed values of the attribute. If
            this is surrounded by curly brackets
            (<code>{...}</code>), then the attribute value is
            treated as an <a title="attribute value template" href=
            "#dt-attribute-value-template">attribute value
            template</a>, and the string occurring within curly
            brackets specifies the allowed values of the result of
            evaluating the attribute value template. Alternative
            allowed values are separated by <code>|</code>. A
            quoted string indicates a value equal to that specific
            string. An unquoted, italicized name specifies a
            particular type of value.</p>

            <p>In all cases where this specification states that
            the value of an attribute <span class=
            "verb">must</span> be one of a limited set of values,
            leading and trailing whitespace in the attribute value
            is ignored. In the case of an <a title=
            "attribute value template" href=
            "#dt-attribute-value-template">attribute value
            template</a>, this applies to the <a title=
            "effective value" href="#dt-effective-value">effective
            value</a> obtained when the attribute value template is
            expanded.</p>
          </li>

          <li>
            <p>Unless the element is <span class=
            "verb">required</span> to be empty, the model element
            contains a comment specifying the allowed content. The
            allowed content is specified in a similar way to an
            element type declaration in XML; <em>sequence
            constructor</em> means that any mixture of text nodes,
            <a title="literal result element" href=
            "#dt-literal-result-element">literal result
            elements</a>, <a title="extension instruction" href=
            "#dt-extension-instruction">extension instructions</a>,
            and <a title="XSLT element" href=
            "#dt-xslt-element">XSLT elements</a> from the <a title=
            "instruction" href="#dt-instruction">instruction</a>
            category is allowed; <em>other-declarations</em> means
            that any mixture of XSLT elements from the <a title=
            "declaration" href="#dt-declaration">declaration</a>
            category, other than <a href=
            "#element-import"><code>xsl:import</code></a>, is
            allowed, together with <a title=
            "user-defined data element" href=
            "#dt-data-element">user-defined data elements</a>.</p>
          </li>

          <li>
            <p>The element is prefaced by comments indicating if it
            belongs to the <code>instruction</code> category or
            <code>declaration</code> category or both. The category
            of an element only affects whether it is allowed in the
            content of elements that allow a <a title=
            "sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a> or
            <em>other-declarations</em>.</p>
          </li>
        </ul>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e659" id="d5e659"></a>Example: Syntax
            Notation
          </div>

          <p>This example illustrates the notation used to describe
          <a title="XSLT element" href="#dt-xslt-element">XSLT
          elements</a>.</p>

          <p class="element-syntax"><a name=
          "element-example-element" id=
          "element-example-element"></a><code>&lt;!-- Category:
          instruction --&gt;<br />
          &lt;xsl:example-element<br />
          &#160;&#160;<b>select</b> = <var>expression</var><br />
          &#160;&#160;debug? = { "yes" | "no" }&gt;<br />
          &#160;&#160;&lt;!-- Content: ((<a href=
          "#element-variable">xsl:variable</a> | <a href=
          "#element-param">xsl:param</a>)*, <a href=
          "#element-sequence">xsl:sequence</a>) --&gt;<br />
          &lt;/xsl:example-element&gt;</code></p>

          <p>This example defines a (non-existent) element
          <code>xsl:example-element</code>. The element is
          classified as an instruction. It takes a mandatory
          <code>select</code> attribute, whose value is an XPath
          <a title="expression" href=
          "#dt-expression">expression</a>, and an optional
          <code>debug</code> attribute, whose value <span class=
          "verb">must</span> be either <code>yes</code> or
          <code>no</code>; the curly brackets indicate that the
          value can be defined as an <a title=
          "attribute value template" href=
          "#dt-attribute-value-template">attribute value
          template</a>, allowing a value such as
          <code>debug="{$debug}"</code>, where the <a title=
          "variable" href="#dt-variable">variable</a>
          <code>debug</code> is evaluated to yield
          <code>"yes"</code> or <code>"no"</code> at run-time.</p>

          <p>The content of an <code>xsl:example-element</code>
          instruction is defined to be a sequence of zero or more
          <a href="#element-variable"><code>xsl:variable</code></a>
          and <a href="#element-param"><code>xsl:param</code></a>
          elements, followed by an <a href=
          "#element-sequence"><code>xsl:sequence</code></a>
          element.</p>
        </div>

        <p><a name="err-XTSE0010" id="err-XTSE0010"><span class=
        "error">[ERR XTSE0010]</span></a> A <a title="static error"
        href="#dt-static-error">static error</a> is signaled if an
        XSLT-defined element is used in a context where it is not
        permitted, if a <span class="verb">required</span>
        attribute is omitted, or if the content of the element does
        not correspond to the content that is allowed for the
        element.</p>

        <p>Attributes are validated as follows. These rules apply
        to the value of the attribute after removing leading and
        trailing whitespace.</p>

        <ul>
          <li>
            <p><a name="err-XTSE0020" id=
            "err-XTSE0020"><span class="error">[ERR
            XTSE0020]</span></a> It is a <a title="static error"
            href="#dt-static-error">static error</a> if an
            attribute (other than an attribute written using curly
            brackets in a position where an <a title=
            "attribute value template" href=
            "#dt-attribute-value-template">attribute value
            template</a> is permitted) contains a value that is not
            one of the permitted values for that attribute.</p>
          </li>

          <li>
            <p><a name="err-XTDE0030" id=
            "err-XTDE0030"><span class="error">[ERR
            XTDE0030]</span></a> It is a <a title=
            "non-recoverable dynamic error" href=
            "#dt-nonrec-dynamic-error">non-recoverable dynamic
            error</a> if the <a title="effective value" href=
            "#dt-effective-value">effective value</a> of an
            attribute written using curly brackets, in a position
            where an <a title="attribute value template" href=
            "#dt-attribute-value-template">attribute value
            template</a> is permitted, is a value that is not one
            of the permitted values for that attribute. If the
            processor is able to detect the error statically (for
            example, when any XPath expressions within the curly
            brackets can be evaluated statically), then the
            processor may optionally signal this as a static
            error.</p>
          </li>
        </ul>

        <p>Special rules apply if the construct appears in part of
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> that is processed with
        <a title="forwards-compatible behavior" href=
        "#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a>: see <a href="#forwards"><i>3.9
        Forwards-Compatible Processing</i></a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-deprecated" id="dt-deprecated" title=
        "deprecated"></a>Some constructs defined in this
        specification are described as being <b>deprecated</b>. The
        use of this term implies that stylesheet authors
        <span class="verb">should not</span> use the construct, and
        that the construct may be removed in a later version of
        this specification.<span class="definition">]</span> All
        constructs that are <a title="deprecated" href=
        "#dt-deprecated">deprecated</a> in this specification are
        also (as it happens) optional features that <a title=
        "implementation" href=
        "#dt-implementation">implementations</a> are <span class=
        "verb">not required</span> to provide.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This working draft includes a non-normative XML Schema
          for XSLT <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a> (see
          <a href="#schema-for-xslt"><i>G Schema for XSLT
          Stylesheets</i></a>). The syntax summaries described in
          this section are normative.</p>
        </div>

        <p>XSLT defines a set of standard functions which are
        additional to those defined in <a href=
        "#xpath-functions">[Functions and Operators]</a>. The
        signatures of these functions are described using the same
        notation as used in <a href="#xpath-functions">[Functions
        and Operators]</a>. The names of these functions are all in
        the <a title="standard function namespace" href=
        "#dt-standard-function-namespace">standard function
        namespace</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="initiating" id="initiating"></a>2.3 Initiating
        a Transformation</h3>

        <p>This document does not specify any application
        programming interfaces or other interfaces for initiating a
        transformation. This section, however, describes the
        information that is supplied when a transformation is
        initiated. Except where otherwise indicated, the
        information is <span class="verb">required</span>.</p>

        <p>Implementations <span class="verb">may</span> allow a
        transformation to run as two or more phases, for example
        parsing, compilation and execution. Such a distinction is
        outside the scope of this specification, which treats
        transformation as a single process controlled using a set
        of <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet modules</a>, supplied in
        the form of XML documents.</p>

        <p>The following information is supplied to execute a
        transformation:</p>

        <ul>
          <li>
            <p>The <a title="stylesheet module" href=
            "#dt-stylesheet-module">stylesheet module</a> that is
            to act as the <a title="principal stylesheet module"
            href="#dt-principal-stylesheet-module">principal
            stylesheet module</a> for the transformation. The
            complete <a title="stylesheet" href=
            "#dt-stylesheet">stylesheet</a> is assembled by
            recursively expanding the <a href=
            "#element-import"><code>xsl:import</code></a> and
            <a href="#element-include"><code>xsl:include</code></a>
            declarations in the principal stylesheet module, as
            described in <a href="#include"><i>3.10.2 Stylesheet
            Inclusion</i></a> and <a href="#import"><i>3.10.3
            Stylesheet Import</i></a>.</p>
          </li>

          <li>
            <p>A set (possibly empty) of values for <a title=
            "stylesheet parameter" href=
            "#dt-stylesheet-parameter">stylesheet parameters</a>
            (see <a href="#global-variables"><i>9.5 Global
            Variables and Parameters</i></a>). These values are
            available for use within <a title="expression" href=
            "#dt-expression">expressions</a> in the <a title=
            "stylesheet" href="#dt-stylesheet">stylesheet</a>.</p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-initial-context-node" id="dt-initial-context-node"
            title="initial context node"></a>A node that acts as
            the <b>initial context node</b> for the transformation.
            This node is accessible within the <a title=
            "stylesheet" href="#dt-stylesheet">stylesheet</a> as
            the initial value of the XPath <a title="expression"
            href="#dt-expression">expressions</a> <code>.</code>
            (dot) and <code>self::node()</code>, as described in
            <a href="#focus"><i>5.4.3.1 Maintaining Position: the
            Focus</i></a><span class="definition">]</span>.</p>

            <p>If no initial context node is supplied, then the
            <a title="context item" href="#dt-context-item">context
            item</a>, <a title="context position" href=
            "#dt-context-position">context position</a>, and
            <a title="context size" href="#dt-context-size">context
            size</a> will initially be undefined, and the
            evaluation of any expression that references these
            values will result in a dynamic error. (Note that the
            initial context size and context position will always
            be 1 (one) when an initial context node is supplied,
            and will be undefined if no initial context node is
            supplied).</p>
          </li>

          <li>
            <p>Optionally, the name of a <a title="named template"
            href="#dt-named-template">named template</a> which is
            to be executed as the entry point to the
            transformation. This template <span class=
            "verb">must</span> exist within the <a title=
            "stylesheet" href="#dt-stylesheet">stylesheet</a>. If
            no named template is supplied, then the transformation
            starts with the <a title="template rule" href=
            "#dt-template-rule">template rule</a> that best matches
            the <a title="initial context node" href=
            "#dt-initial-context-node">initial context node</a>,
            according to the rules defined in <a href=
            "#conflict"><i>6.4 Conflict Resolution for Template
            Rules</i></a>. Either a named template, or an initial
            context node, or both, <span class="verb">must</span>
            be supplied.</p>
          </li>

          <li>
            <p>Optionally, an initial <a title="mode" href=
            "#dt-mode">mode</a>. <span>This <span class=
            "verb">must</span> either be the default mode, or a
            mode that is explicitly named in the <code>mode</code>
            attribute of an <a href=
            "#element-template"><code>xsl:template</code></a>
            declaration within the stylesheet</span>. If an initial
            mode is supplied, then in searching for the <a title=
            "template rule" href="#dt-template-rule">template
            rule</a> that best matches the <a title=
            "initial context node" href=
            "#dt-initial-context-node">initial context node</a>,
            the processor considers only those rules that apply to
            the initial mode. If no initial mode is supplied, the
            <a title="default mode" href="#dt-default-mode">default
            mode</a> is used.</p>
          </li>

          <li>
            <p>A base output URI. <span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-base-output-uri" id="dt-base-output-uri" title=
            "base output URI"></a> The <b>base output URI</b> is a
            URI to be used as the base URI when resolving a
            relative URI allocated to a <a title=
            "final result tree" href="#dt-final-result-tree">final
            result tree</a>. If the transformation generates more
            than one final result tree, then typically each one
            will be allocated a URI relative to this base URI.
            <span class="definition">]</span> <span>The way in
            which a base output URI is established is <a title=
            "implementation-defined" href=
            "#dt-implementation-defined">implementation-defined</a>.</span></p>
          </li>

          <li>
            <p>A mechanism for obtaining a document node and a
            media type, given an absolute URI. The total set of
            available documents (modeled as a mapping from URIs to
            document nodes) forms part of the context for
            evaluating XPath expressions, specifically the <a href=
            "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
            <small>FO</small></sup> function. The XSLT <a href=
            "#function-document"><code>document</code></a> function
            additionally requires the media type of the resource
            representation, for use in interpreting any fragment
            identifier present within a URI Reference.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>The set of documents that are available to the
              stylesheet is <a title="implementation-dependent"
              href=
              "#dt-implementation-dependent">implementation-dependent</a>,
              as is the processing that is carried out to construct
              a tree representing the resource retrieved using a
              given URI. Some possible ways of constructing a
              document (specifically, rules for constructing a
              document from an Infoset or from a PSVI) are
              described in <a href="#xpath-datamodel">[Data
              Model]</a>.</p>
            </div>
          </li>
        </ul>

        <p><a name="err-XTDE0040" id="err-XTDE0040"><span class=
        "error">[ERR XTDE0040]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the invocation of the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> specifies a template
        name that does not match the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> of a named
        template defined in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>.</p>

        <p><a name="err-XTDE0045" id="err-XTDE0045"><span class=
        "error">[ERR XTDE0045]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the invocation of the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> specifies an initial
        <a title="mode" href="#dt-mode">mode</a> (other than the
        default mode) that does not match the <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> in the
        <code>mode</code> attribute of any template defined in the
        <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>.</p>

        <p><a name="err-XTDE0047" id="err-XTDE0047"><span class=
        "error">[ERR XTDE0047]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the invocation of the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> specifies both an
        initial <a title="mode" href="#dt-mode">mode</a> and an
        initial template.</p>

        <p><a name="err-XTDE0050" id="err-XTDE0050"><span class=
        "error">[ERR XTDE0050]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the stylesheet that is invoked declares a
        visible <a title="stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameter</a> with
        <code>required="yes"</code> and no value for this parameter
        is supplied during the invocation of the stylesheet. A
        stylesheet parameter is visible if it is not masked by
        another global variable or parameter with the same name and
        higher <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-initial-template" id="dt-initial-template" title=
        "initial template"></a>The transformation is performed by
        evaluating an <b>initial template</b>. If a <a title=
        "named template" href="#dt-named-template">named
        template</a> is supplied when the transformation is
        initiated, then this is the initial template;
        <span>otherwise, the initial template is the <a title=
        "template rule" href="#dt-template-rule">template rule</a>
        selected according to the rules of the <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction for processing the <a title=
        "initial context node" href=
        "#dt-initial-context-node">initial context node</a> in the
        initial <a title="mode" href=
        "#dt-mode">mode</a>.</span><span class=
        "definition">]</span></p>

        <p>Parameters passed to the transformation by the client
        application are matched against <a title=
        "stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameters</a> (see
        <a href="#global-variables"><i>9.5 Global Variables and
        Parameters</i></a>), not against the <a title=
        "template parameter" href="#dt-template-parameter">template
        parameters</a> declared within the <a title=
        "initial template" href="#dt-initial-template">initial
        template</a>. All <a title="template parameter" href=
        "#dt-template-parameter">template parameters</a> within the
        initial template to be executed will take their default
        values.</p>

        <p><a name="err-XTDE0060" id="err-XTDE0060"><span class=
        "error">[ERR XTDE0060]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="initial template" href=
        "#dt-initial-template">initial template</a> defines a
        <a title="template parameter" href=
        "#dt-template-parameter">template parameter</a> that
        specifies <code>required="yes"</code>.</p>

        <p>A <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> can process further source
        documents in addition to those supplied when the
        transformation is invoked. These additional documents can
        be loaded using the functions <a href=
        "#function-document"><code>document</code></a> (see
        <a href="#document"><i>16.1 Multiple Source
        Documents</i></a>) or <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup> or <a href=
        "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
        collection</code></a><sup><small>FO</small></sup> (see
        <a href="#xpath-functions">[Functions and Operators]</a>),
        or they can be supplied as <a title="stylesheet parameter"
        href="#dt-stylesheet-parameter">stylesheet parameters</a>
        (see <a href="#global-variables"><i>9.5 Global Variables
        and Parameters</i></a>), or as the result of an <a title=
        "extension function" href=
        "#dt-extension-function">extension function</a> (see
        <a href="#extension-functions"><i>18.1 Extension
        Functions</i></a>).</p>
      </div>

      <div class="div2">
        <h3><a name="executing-a-transformation" id=
        "executing-a-transformation"></a>2.4 Executing a
        Transformation</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-template-rule" id="dt-template-rule" title=
        "template rule"></a>A stylesheet contains a set of
        <b>template rules</b> (see <a href="#rules"><i>6 Template
        Rules</i></a>). A template rule has three parts: a
        <a title="pattern" href="#dt-pattern">pattern</a> that is
        matched against nodes, a (possibly empty) set of <a title=
        "template parameter" href="#dt-template-parameter">template
        parameters</a>, and a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that is
        evaluated to produce a sequence of items.<span class=
        "definition">]</span> In many cases these items are newly
        constructed nodes, which are then written to a <a title=
        "result tree" href="#dt-result-tree">result tree</a>.</p>

        <p>A transformation as a whole is executed by evaluating
        the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> of the
        <a title="initial template" href=
        "#dt-initial-template">initial template</a> as described in
        <a href="#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>.</p>

        <p>If the initial template has an <code>as</code>
        attribute, then the result sequence of the initial template
        is checked against the required type in the same way as for
        any other template. If this result sequence is non-empty,
        then it is used to construct an implicit <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a>, following the rules described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>: the effect is as if the initial
        template <var>T</var> were called by an implicit template
        of the form:</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:template name="IMPLICIT"&gt;
  &lt;xsl:result-document href=""&gt;
    &lt;xsl:call-template name="T"/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;
</pre>
        </div>

        <p>An implicit result tree is also created when the result
        sequence is empty, provided that no <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction has been evaluated during the course of the
        transformation. In this situation the implicit result tree
        will consist of a document node with no children.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This means that there is always at least one result
          tree. It also means that if the content of the initial
          template is a single <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction, as in the example above, then only one
          result tree is produced, not two. It is useful to make
          the result document explicit as this is the only way of
          invoking document-level validation.</p>

          <p>If the result of the initial template is non-empty,
          and an explicit <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction has been evaluated with the empty attribute
          <code>href=""</code>, then an error will occur
          <span class="error">[see <a href="#err-XTDE1490">ERR
          XTDE1490</a>]</span>, since it is not possible to create
          two final result trees with the same URI.</p>
        </div>

        <p>A <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> is a
        sequence of sibling nodes in the stylesheet, each of which
        is either an <a title="XSLT instruction" href=
        "#dt-xslt-instruction">XSLT instruction</a>, a <a title=
        "literal result element" href=
        "#dt-literal-result-element">literal result element</a>, a
        text node, or an <a title="extension instruction" href=
        "#dt-extension-instruction">extension instruction</a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-instruction" id="dt-instruction" title=
        "instruction"></a>An <b>instruction</b> is either an
        <a title="XSLT instruction" href=
        "#dt-xslt-instruction">XSLT instruction</a> or an <a title=
        "extension instruction" href=
        "#dt-extension-instruction">extension
        instruction</a>.<span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-xslt-instruction" id="dt-xslt-instruction" title=
        "XSLT instruction"></a>An <b>XSLT instruction</b> is an
        <a title="XSLT element" href="#dt-xslt-element">XSLT
        element</a> whose syntax summary in this specification
        contains the annotation <code>&lt;!-- category: instruction
        --&gt;</code>.<span class="definition">]</span></p>

        <p><a title="extension instruction" href=
        "#dt-extension-instruction">Extension instructions</a> are
        described in <a href="#extension-instruction"><i>18.2
        Extension Instructions</i></a>.</p>

        <p>The main categories of <a title="XSLT instruction" href=
        "#dt-xslt-instruction">XSLT instruction</a> are as
        follows:</p>

        <ul>
          <li>
            <p>instructions that create new nodes: <span><a href=
            "#element-document"><code>xsl:document</code></a></span>,
            <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href=
            "#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
            <a href=
            "#element-comment"><code>xsl:comment</code></a>,
            <a href=
            "#element-value-of"><code>xsl:value-of</code></a>,
            <a href="#element-text"><code>xsl:text</code></a>,
            <a href=
            "#element-namespace"><code>xsl:namespace</code></a>;</p>
          </li>

          <li>
            <p>an instruction that returns an arbitrary sequence by
            evaluating an XPath expression: <a href=
            "#element-sequence"><code>xsl:sequence</code></a>;</p>
          </li>

          <li>
            <p>instructions that cause conditional or repeated
            evaluation of nested instructions: <a href=
            "#element-if"><code>xsl:if</code></a>, <a href=
            "#element-choose"><code>xsl:choose</code></a>, <a href=
            "#element-for-each"><code>xsl:for-each</code></a>,
            <a href=
            "#element-for-each-group"><code>xsl:for-each-group</code></a>;</p>
          </li>

          <li>
            <p>instructions that invoke templates: <a href=
            "#element-apply-templates"><code>xsl:apply-templates</code></a>,
            <a href=
            "#element-apply-imports"><code>xsl:apply-imports</code></a>,
            <a href=
            "#element-call-template"><code>xsl:call-template</code></a>,
            <a href=
            "#element-next-match"><code>xsl:next-match</code></a>;</p>
          </li>

          <li>
            <p>Instructions that declare variables: <a href=
            "#element-variable"><code>xsl:variable</code></a>,
            <a href=
            "#element-param"><code>xsl:param</code></a>;</p>
          </li>

          <li>
            <p>other specialized instructions: <a href=
            "#element-number"><code>xsl:number</code></a>, <a href=
            "#element-analyze-string"><code>xsl:analyze-string</code></a>,
            <a href=
            "#element-message"><code>xsl:message</code></a>,
            <a href=
            "#element-result-document"><code>xsl:result-document</code></a>.</p>
          </li>
        </ul>

        <p>Often, a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> will
        include an <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction, which selects a sequence of nodes to be
        processed. Each of the selected nodes is processed by
        searching the stylesheet for a matching <a title=
        "template rule" href="#dt-template-rule">template rule</a>
        and evaluating the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> of that
        template rule. The resulting sequences of items are
        concatenated, in order, to give the result of the <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction, as described in <a href=
        "#applying-templates"><i>6.3 Applying Template
        Rules</i></a>; this sequence is often added to a <a title=
        "result tree" href="#dt-result-tree">result tree</a>. Since
        the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructors</a> of the
        selected <a title="template rule" href=
        "#dt-template-rule">template rules</a> may themselves
        contain <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instructions, this results in a cycle of selecting nodes,
        identifying <a title="template rule" href=
        "#dt-template-rule">template rules</a>, constructing
        sequences, and constructing <a title="result tree" href=
        "#dt-result-tree">result trees</a>, that recurses through a
        <a title="source tree" href="#dt-source-tree">source
        tree</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="context" id="context"></a>2.5 The Evaluation
        Context</h3>

        <p>The results of some expressions and instructions in a
        stylesheet may depend on information provided contextually.
        This context information is divided into two categories:
        the static context, which is known during static analysis
        of the stylesheet, and the dynamic context, which is not
        known until the stylesheet is evaluated. Although
        information in the static context is known at analysis
        time, it is sometimes used during stylesheet
        evaluation.</p>

        <p>Some context information can be set by means of
        declarations within the stylesheet itself. For example, the
        namespace bindings used for any XPath expression are
        determined by the namespace declarations present in
        containing elements in the stylesheet. Other information
        may be supplied externally or implicitly: an example is the
        current date and time.</p>

        <p>The context information used in processing an XSLT
        stylesheet includes as a subset all the context information
        required when evaluating XPath expressions. The XPath 2.0
        specification defines a static and dynamic context that the
        host language (in this case, XSLT) may initialize, which
        affects the results of XPath expressions used in that
        context. XSLT augments the context with additional
        information: this additional information is used firstly by
        XSLT constructs outside the scope of XPath (for example,
        the <a href="#element-sort"><code>xsl:sort</code></a>
        element), and secondly, by functions that are defined in
        the XSLT specification (such as <a href=
        "#function-key"><code>key</code></a> and <a href=
        "#function-format-number"><code>format-number</code></a>)
        that are available for use in XPath expressions appearing
        within a stylesheet.</p>

        <p>The static context for an expression or other construct
        in a stylesheet is determined by the place in which it
        appears lexically. The details vary for different
        components of the static context, but in general, elements
        within a stylesheet module affect the static context for
        their descendant elements within the same stylesheet
        module.</p>

        <p>The dynamic context is maintained as a stack. When an
        instruction or expression is evaluated, it may add dynamic
        context information to the stack; when evaluation is
        complete, the dynamic context reverts to its previous
        state. An expression that accesses information from the
        dynamic context always uses the value at the top of the
        stack.</p>

        <p>The most commonly used component of the dynamic context
        is the <a title="context item" href=
        "#dt-context-item">context item</a>. This is an implicit
        variable whose value is the item (it may be a node or an
        atomic value) currently being processed. The value of the
        context item can be referenced within an XPath expression
        using the expression <code>.</code> (dot).</p>

        <p>Full details of the static and dynamic context are
        provided in <a href="#static-and-dynamic-context"><i>5.4
        The Static and Dynamic Context</i></a>.</p>
      </div>

      <div class="div2">
        <h3><a name="parsing-and-serialization" id=
        "parsing-and-serialization"></a>2.6 Parsing and
        Serialization</h3>

        <p>An XSLT <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> describes a process that
        constructs a set of <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a> from a set
        of <a title="source tree" href="#dt-source-tree">source
        trees</a>.</p>

        <p>The <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> does not describe how a
        <a title="source tree" href="#dt-source-tree">source
        tree</a> is constructed. <span>Some possible ways of
        constructing source trees are described in <a href=
        "#xpath-datamodel">[Data Model]</a>.</span> Frequently an
        <a title="implementation" href=
        "#dt-implementation">implementation</a> will operate in
        conjunction with an XML parser (or more strictly, in the
        terminology of <a href="#REC-xml">[XML 1.0]</a>, an <em>XML
        processor</em>), to build a source tree from an input XML
        document. An implementation <span class="verb">may</span>
        also provide an application programming interface allowing
        the tree to be constructed directly, or allowing it to be
        supplied in the form of a DOM Document object (see <a href=
        "#DOM-Level-2-Core">[DOM Level 2]</a>). This is outside the
        scope of this specification. Users should be aware,
        however, that since the input to the transformation is a
        tree conforming to the <span>XDM</span> data model as
        described in <a href="#xpath-datamodel">[Data Model]</a>,
        constructs that might exist in the original XML document,
        or in the DOM, but which are not within the scope of the
        data model, cannot be processed by the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> and
        cannot be guaranteed to remain unchanged in the
        transformation output. Such constructs include CDATA
        section boundaries, the use of entity references, and the
        DOCTYPE declaration and internal DTD subset.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-serialization" id="dt-serialization" title=
        "serialization"></a>A frequent requirement is to output a
        <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> as an XML
        document (or in other formats such as HTML). This process
        is referred to as <b>serialization</b>.<span class=
        "definition">]</span></p>

        <p>Like parsing, serialization is not part of the
        transformation process, and it is not <span class=
        "verb">required</span> that an XSLT processor <span class=
        "verb">must</span> be able to perform serialization.
        However, for pragmatic reasons, this specification
        describes declarations (the <a href=
        "#element-output"><code>xsl:output</code></a> element and
        the <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declarations, see <a href="#serialization"><i>20
        Serialization</i></a>), and attributes on the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction, that allow a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> to specify the desired
        properties of a serialized output file. <span>When
        serialization is not being performed, either because the
        implementation does not support the serialization option,
        or because the user is executing the transformation in a
        way that does not invoke serialization, then the content of
        the <a href="#element-output"><code>xsl:output</code></a>
        and <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declarations has no effect. Under these circumstances the
        processor <span class="verb">may</span> report any errors
        in an <a href="#element-output"><code>xsl:output</code></a>
        or <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declaration, or in the serialization attributes of <a href=
        "#element-result-document"><code>xsl:result-document</code></a>,</span>
        but is not <span class="verb">required</span> to do so.</p>
      </div>

      <div class="div2">
        <h3><a name="extensibility" id="extensibility"></a>2.7
        Extensibility</h3>

        <p>XSLT defines a number of features that allow the
        language to be extended by implementers, or, if
        implementers choose to provide the capability, by users.
        These features have been designed, so far as possible, so
        that they can be used without sacrificing interoperability.
        Extensions other than those explicitly defined in this
        specification are not permitted.</p>

        <p>These features are all based on XML namespaces;
        namespaces are used to ensure that the extensions provided
        by one implementer do not clash with those of a different
        implementer.</p>

        <p>The most common way of extending the language is by
        providing additional functions, which can be invoked from
        XPath expressions. These are known as <a title=
        "extension function" href=
        "#dt-extension-function">extension functions</a>, and are
        described in <a href="#extension-functions"><i>18.1
        Extension Functions</i></a>.</p>

        <p>It is also permissible to extend the language by
        providing new <a title="instruction" href=
        "#dt-instruction">instructions</a>. These are referred to
        as <a title="extension instruction" href=
        "#dt-extension-instruction">extension instructions</a>, and
        are described in <a href="#extension-instruction"><i>18.2
        Extension Instructions</i></a>. A stylesheet that uses
        extension instructions must declare that it is doing so by
        using the <code>[xsl:]extension-element-prefixes</code>
        attribute.</p>

        <p>Extension instructions and extension functions defined
        according to these rules <span class="verb">may</span> be
        provided by the implementer of the XSLT processor, and the
        implementer <span class="verb">may</span> also provide
        facilities to allow users to create further extension
        instructions and extension functions.</p>

        <p>This specification defines how extension instructions
        and extension functions are invoked, but the facilities for
        creating new extension instructions and extension functions
        are <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>.
        For further details, see <a href="#extension"><i>18
        Extensibility and Fallback</i></a>.</p>

        <p>The XSLT language can also be extended by the use of
        <a title="extension attribute" href=
        "#dt-extension-attribute">extension attributes</a> (see
        <a href="#extension-attributes"><i>3.3 Extension
        Attributes</i></a>), and by means of <a title=
        "user-defined data element" href=
        "#dt-data-element">user-defined data elements</a> (see
        <a href="#user-defined-top-level"><i>3.6.2 User-defined
        Data Elements</i></a>).</p>
      </div>

      <div class="div2">
        <h3><a name="stylesheets-and-schemas" id=
        "stylesheets-and-schemas"></a>2.8 Stylesheets and
        <span>XML</span> Schemas</h3>

        <p>An XSLT <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> can make use of information
        from a schema. An XSLT transformation can take place in the
        absence of a schema (and, indeed, in the absence of a DTD),
        but where the source document has undergone schema validity
        assessment, the XSLT processor has access to the type
        information associated with individual nodes, not merely to
        the untyped text.</p>

        <p>Information from a schema can be used both statically
        (when the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> is compiled), and
        dynamically (during evaluation of the stylesheet to
        transform a source document).</p>

        <p>There are places within a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, and within XPath <a title=
        "expression" href="#dt-expression">expressions</a> and
        <a title="pattern" href="#dt-pattern">patterns</a> in a
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>,
        where it is possible to refer to named type definitions in
        a schema, or to element and attribute declarations. For
        example, it is possible to declare the types expected for
        the parameters of a function. This is done using the
        <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</a><sup>
        <small>XP</small></sup> syntax defined in <a href=
        "#xpath20">[XPath 2.0]</a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-schema-component" id="dt-schema-component" title=
        "schema component"></a>Type definitions and element and
        attribute declarations are referred to collectively as
        <b>schema components</b>.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-in-scope-schema-component" id=
        "dt-in-scope-schema-component" title=
        "in-scope schema component"></a>The <a title=
        "schema component" href="#dt-schema-component">schema
        components</a> that may be referenced by name in a
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        are referred to as the <b>in-scope schema components</b>.
        This set is the same throughout all the modules of a
        stylesheet.<span class="definition">]</span></p>

        <p>The conformance rules for XSLT 2.0, defined in <a href=
        "#conformance"><i>21 Conformance</i></a>, distinguish
        between a <a title="basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a> and a
        <a title="schema-aware XSLT processor" href=
        "#dt-schema-aware-xslt-processor">schema-aware XSLT
        processor</a>. As the names suggest, a basic XSLT processor
        does not support the features of XSLT that require access
        to schema information, either statically or dynamically. A
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        that works with a basic XSLT processor will produce the
        same results with a schema-aware XSLT processor
        <span>provided that the source documents are untyped (that
        is, they are not validated against a schema). However, if
        source documents are validated against a schema then the
        results may be different from the case where they are not
        validated. Some constructs that work on untyped data may
        fail with typed data (for example, an attribute of type
        <code>xs:date</code> cannot be used as an argument of the
        <a href=
        "http://www.w3.org/TR/xpath-functions/#func-substring"><code>
        substring</code></a><sup><small>FO</small></sup> function)
        and other constructs may produce different results
        depending on the data type (for example, given the element
        <code>&lt;product price="10.00"
        discount="2.00"/&gt;</code>, the expression <code>@price gt
        @discount</code> will return true if the attributes have
        type <code>xs:decimal</code>, but will return false if they
        are untyped).</span></p>

        <p>There is a standard set of type definitions that are
        always available as <a title="in-scope schema component"
        href="#dt-in-scope-schema-component">in-scope schema
        components</a> in every stylesheet. These are defined in
        <a href="#built-in-types"><i>3.13 Built-in Types</i></a>.
        The set of built-in types varies between a <a title=
        "basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a> and a
        <a title="schema-aware XSLT processor" href=
        "#dt-schema-aware-xslt-processor">schema-aware XSLT
        processor</a>.</p>

        <p>The remainder of this section describes facilities that
        are available only with a <a title=
        "schema-aware XSLT processor" href=
        "#dt-schema-aware-xslt-processor">schema-aware XSLT
        processor</a>.</p>

        <p>Additional <a title="schema component" href=
        "#dt-schema-component">schema components</a> (type
        definitions, element declarations, and attribute
        declarations) may be added to the <a title=
        "in-scope schema component" href=
        "#dt-in-scope-schema-component">in-scope schema
        components</a> by means of the <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration in a stylesheet.</p>

        <p>The <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration may reference an external schema document by
        means of a URI, or it may contain an inline
        <code>xs:schema</code> element.</p>

        <p>It is only necessary to import a schema explicitly if
        <span>one or more of its <a title="schema component" href=
        "#dt-schema-component">schema components</a> are referenced
        explicitly by name</span> in the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a>; it is not necessary
        to import a schema merely because the stylesheet is used to
        process a source document that has been assessed against
        that schema. It is possible to make use of the information
        resulting from schema assessment (for example, the fact
        that a particular attribute holds a date) even if no schema
        has been imported by the stylesheet.</p>

        <p>Further, importing a schema does not of itself say
        anything about the type of the source document that the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        is expected to process. The imported type definitions can
        be used for temporary nodes or for nodes on a <a title=
        "result tree" href="#dt-result-tree">result tree</a> just
        as much as for nodes <span>in source documents. It is
        possible to make assertions about the type of an input
        document by means of tests within the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a>. For
        example:</span></p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e1763" id="d5e1763"></a>Example: Asserting
            the Required Type of the Source Document
          </div>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="document-node(schema-element(my:invoice))" priority="2"&gt;
. . .
&lt;/xsl:template&gt;

&lt;xsl:template match="document-node()" priority="1"&gt;
  &lt;xsl:message terminate="yes"&gt;Source document is not an invoice&lt;/xsl:message&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>This example will cause the transformation to fail
          with an error message unless the document element of the
          source document is valid against the top-level element
          declaration <code>my:invoice</code>, and has been
          annotated as such.</p>
        </div>

        <p>It is possible that a source document may contain nodes
        whose <a title="type annotation" href="#dt-annotation">type
        annotation</a> is not one of the types imported by the
        stylesheet. This creates a potential problem because in the
        case of an expression such as <code>data(.) instance of
        xs:integer</code> the system needs to know whether the type
        named in the type annotation of the context node is derived
        by restriction from the type <code>xs:integer</code>. This
        information is not explicitly available in an <span>XDM
        tree</span>, as defined in <a href="#xpath-datamodel">[Data
        Model]</a>. The implementation may choose one of several
        strategies for dealing with this situation:</p>

        <ol class="enumar">
          <li>
            <p>The processor may signal a <a title=
            "non-recoverable dynamic error" href=
            "#dt-nonrec-dynamic-error">non-recoverable dynamic
            error</a> if a source document is found to contain a
            <a title="type annotation" href="#dt-annotation">type
            annotation</a> that is not known to the processor.</p>
          </li>

          <li>
            <p>The processor may maintain additional metadata,
            beyond that described in <a href=
            "#xpath-datamodel">[Data Model]</a>, that allows the
            source document to be processed as if all the necessary
            schema information had been imported using <a href=
            "#element-import-schema"><code>xsl:import-schema</code></a>.
            Such metadata might be held in the data structure
            representing the source document itself, or it might be
            held in a system catalog or repository.</p>
          </li>

          <li>
            <p>The processor may be configured to use a fixed set
            of schemas, which are automatically used to validate
            all source documents before they can be supplied as
            input to a transformation. In this case it is
            impossible for a source document to have a <a title=
            "type annotation" href="#dt-annotation">type
            annotation</a> that the processor is not aware of.</p>
          </li>

          <li>
            <p>The processor may be configured to treat the source
            document as if no schema processing had been performed,
            that is, effectively to strip all type annotations from
            elements and attributes on input, marking them instead
            as having type <span><code>xs:untyped</code></span> and
            <span><code>xs:untypedAtomic</code></span>
            respectively.</p>
          </li>
        </ol>

        <p>Where a stylesheet author chooses to make assertions
        about the types of nodes or of <a title="variable" href=
        "#dt-variable">variables</a> and <a title="parameter" href=
        "#dt-parameter">parameters</a>, it is possible for an XSLT
        processor to perform static analysis of the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> (that is,
        analysis in the absence of any source document). Such
        analysis <span class="verb">may</span> reveal errors that
        would otherwise not be discovered until the transformation
        is actually executed. An XSLT processor is not <span class=
        "verb">required</span> to perform such static
        type-checking. <span>Under some circumstances (see <a href=
        "#errors"><i>2.9 Error Handling</i></a>) type errors that
        are detected early <span class="verb">may</span> be
        reported as static errors. In addition an implementation
        <span class="verb">may</span> report any condition found
        during static analysis as a warning, provided that this
        does not prevent the stylesheet being evaluated as
        described by this specification.</span></p>

        <p>A <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> can also control the
        <a title="type annotation" href="#dt-annotation">type
        annotations</a> of nodes that it constructs in a <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a>, or in <a title="temporary tree" href=
        "#dt-temporary-tree">temporary trees</a>. This can be done
        in a number of ways.</p>

        <ul>
          <li>
            <p>It is possible to request explicit validation of a
            complete document, that is, a tree rooted at a document
            node. This applies both to temporary trees constructed
            using the <a href=
            "#element-document"><code>xsl:document</code></a> (or
            <a href="#element-copy"><code>xsl:copy</code></a>)
            instruction and also to <a title="final result tree"
            href="#dt-final-result-tree">final result trees</a>
            constructed using <a href=
            "#element-result-document"><code>xsl:result-document</code></a>.
            Validation is either strict or lax, as described in
            <a href="#xmlschema-1">[XML Schema Part 1]</a>. If
            validation of a <a title="result tree" href=
            "#dt-result-tree">result tree</a> fails (strictly
            speaking, if the outcome of the validity assessment is
            <code>invalid</code>), then the transformation fails,
            but in all other cases, the element and attribute nodes
            of the tree will be annotated with the names of the
            types to which these nodes conform. These <a title=
            "type annotation" href="#dt-annotation">type
            annotations</a> will be discarded if the result tree is
            serialized as an XML document, but they remain
            available when the result tree is passed to an
            application (perhaps another <a title="stylesheet"
            href="#dt-stylesheet">stylesheet</a>) for further
            processing.</p>
          </li>

          <li>
            <p>It is also possible to validate individual element
            and attribute nodes as they are constructed. This is
            done using the <code>type</code> and
            <code>validation</code> attributes of the <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>, and
            <a href="#element-copy-of"><code>xsl:copy-of</code></a>
            instructions, or the <code>xsl:type</code> and
            <code>xsl:validation</code> attributes of a literal
            result element.</p>
          </li>

          <li>
            <p>When elements, attributes, or document nodes are
            copied, either explicitly using the <a href=
            "#element-copy"><code>xsl:copy</code></a> or <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>
            instructions, or implicitly when nodes in a sequence
            are attached to a new parent node, the options
            <code>validation="strip"</code> and
            <code>validation="preserve"</code> are available, to
            control whether existing <a title="type annotation"
            href="#dt-annotation">type annotations</a> are to be
            retained or not.</p>
          </li>
        </ul>

        <p>When nodes in a <a title="temporary tree" href=
        "#dt-temporary-tree">temporary tree</a> are validated, type
        information is available for use by operations carried out
        on the temporary tree, in the same way as for a source
        document that has undergone schema assessment.</p>

        <p>For details of how validation of element and attribute
        nodes works, see <a href="#validation"><i>19.2
        Validation</i></a>.</p>
      </div>

      <div class="div2">
        <h3><a name="errors" id="errors"></a>2.9 Error
        Handling</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-static-error" id="dt-static-error" title=
        "static error"></a>An error that is detected by examining a
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        before execution starts (that is, before the source
        document and values of stylesheet parameters are available)
        is referred to as a <b>static error</b>.<span class=
        "definition">]</span></p>

        <p>Errors classified in this specification as static errors
        <span class="verb">must</span> be signaled by all
        implementations: that is, the <a title="processor" href=
        "#dt-processor">processor</a> <span class=
        "verb">must</span> indicate that the error is present. A
        static error <span class="verb">must</span> be signaled
        even if it occurs in a part of the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> that is never
        evaluated. Static errors are never recoverable. After
        signaling a static error, a processor <span class=
        "verb">may</span> continue for the purpose of signaling
        additional errors, but it <span class="verb">must</span>
        eventually terminate abnormally without producing any
        <span><a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a></span>.</p>

        <p>There is an exception to this rule when the stylesheet
        specifies <a title="forwards-compatible behavior" href=
        "#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a> (see <a href="#forwards"><i>3.9
        Forwards-Compatible Processing</i></a>).</p>

        <p>Generally, errors in the structure of the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a>, or in
        the syntax of XPath <a title="expression" href=
        "#dt-expression">expressions</a> contained in the
        stylesheet, are classified as <a title="static error" href=
        "#dt-static-error">static errors</a>. Where this
        specification states that an element in the stylesheet
        <span class="verb">must</span> or <span class="verb">must
        not</span> appear in a certain position, or that it
        <span class="verb">must</span> or <span class="verb">must
        not</span> have a particular attribute, or that an
        attribute <span class="verb">must</span> or <span class=
        "verb">must not</span> have a value satisfying specified
        conditions, then any contravention of this rule is a static
        error unless otherwise specified.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-dynamic-error" id="dt-dynamic-error" title=
        "dynamic error"></a>An error that is not detected until a
        source document is being transformed is referred to as a
        <b>dynamic error</b>.<span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-recoverable-error" id="dt-recoverable-error" title=
        "recoverable error"></a>Some dynamic errors are classed as
        <b>recoverable errors</b>. When a recoverable error occurs,
        this specification allows the processor either to signal
        the error (by reporting the error condition and terminating
        execution) or to take a defined recovery action and
        continue processing.<span class="definition">]</span> It is
        <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        whether the error is signaled or the recovery action is
        taken.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-optional-recovery-action" id=
        "dt-optional-recovery-action" title=
        "optional recovery action"></a>If an implementation chooses
        to recover from a <a title="recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a>, it
        <span class="verb">must</span> take the <b>optional
        recovery action</b> defined for that error condition in
        this specification.<span class="definition">]</span></p>

        <p>When the implementation makes the choice between
        signaling a dynamic error or recovering, it is not
        restricted in how it makes the choice; for example, it
        <span class="verb">may</span> provide options that can be
        set by the user. When an implementation chooses to recover
        from a dynamic error, it <span><span class=
        "verb">may</span></span> also take other action, such as
        logging a warning message.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-nonrec-dynamic-error" id="dt-nonrec-dynamic-error"
        title="non-recoverable dynamic error"></a>A <a title=
        "dynamic error" href="#dt-dynamic-error">dynamic error</a>
        that is not recoverable is referred to as a
        <b>non-recoverable dynamic error</b>. When a
        non-recoverable dynamic error occurs, the <a title=
        "processor" href="#dt-processor">processor</a> <span class=
        "verb">must</span> signal the error, and the transformation
        fails.<span class="definition">]</span></p>

        <p>Because different implementations may optimize execution
        of the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> in different ways, the
        detection of dynamic errors is to some degree <a title=
        "implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>.
        In cases where an implementation is able to produce the
        <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a> without
        evaluating a particular construct, the implementation is
        never <span class="verb">required</span> to evaluate that
        construct solely in order to determine whether doing so
        causes a dynamic error. For example, if a <a title=
        "variable" href="#dt-variable">variable</a> is declared but
        never referenced, an implementation <span class=
        "verb">may</span> choose whether or not to evaluate the
        variable declaration, which means that if evaluating the
        variable declaration causes a dynamic error, some
        implementations will signal this error and others will
        not.</p>

        <p>There are some cases where this specification requires
        that a construct <span class="verb">must not</span> be
        evaluated: for example, the content of an <a href=
        "#element-if"><code>xsl:if</code></a> instruction
        <span class="verb">must not</span> be evaluated if the test
        condition is false. This means that an implementation
        <span class="verb">must not</span> signal any dynamic
        errors that would arise if the construct were
        evaluated.</p>

        <p>An implementation <span class="verb">may</span> signal a
        <a title="dynamic error" href="#dt-dynamic-error">dynamic
        error</a> before any source document is available, but only
        if it can determine that the error would be signaled for
        every possible source document and every possible set of
        parameter values. For example, some <a title="" href=
        "#circularity">circularity</a> errors fall into this
        category: see <a href="#circularity"><i>9.8 Circular
        Definitions</i></a>.</p>

        <p>The XPath specification states (see <a href=
        "http://www.w3.org/TR/xpath20/#id-kinds-of-errors">Section
        2.3.1 Kinds of Errors</a><sup><small>XP</small></sup>) that
        if any expression (at any level) can be evaluated during
        the analysis phase (because all its explicit operands are
        known and it has no dependencies on the dynamic context),
        then any error in performing this evaluation <span class=
        "verb">may</span> be reported as a static error. For XPath
        expressions used in an XSLT stylesheet, however, any such
        errors <span class="verb">must not</span> be reported as
        static errors in the stylesheet unless they would occur in
        every possible evaluation of that stylesheet; instead, they
        must be signaled as dynamic errors, and signaled only if
        the XPath expression is actually evaluated.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e2144" id="d5e2144"></a>Example: Errors in
            Constant Subexpressions
          </div>

          <p>An XPath processor may report statically that the
          expression <code>1 div 0</code> fails with a "divide by
          zero" error. But suppose this XPath expression occurs in
          an XSLT construct such as:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;
</pre>
          </div>

          <p>Then the XSLT processor must not report an error,
          because the relevant XPath construct appears in a context
          where it will never be executed by an XSLT 2.0 processor.
          (An XSLT 1.0 processor will execute this code
          successfully, returning positive infinity, because it
          uses double arithmetic rather than decimal
          arithmetic.)</p>
        </div>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-type-error" id="dt-type-error" title=
        "type errors"></a>Certain errors are classified as <b>type
        errors</b>. A type error occurs when the value supplied as
        input to an operation is of the wrong type for that
        operation, for example when an integer is supplied to an
        operation that expects a node.<span class=
        "definition">]</span> If a type error occurs in an
        instruction that is actually evaluated, then it
        <span class="verb">must</span> be signaled <span>in the
        same way as a <a title="non-recoverable dynamic error"
        href="#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a>. Alternatively, an implementation <span class=
        "verb">may</span> signal a type error during the analysis
        phase</span> in the same way as a <a title="static error"
        href="#dt-static-error">static error</a>, even if it occurs
        in part of the stylesheet that is never evaluated, provided
        it can establish that execution of a particular construct
        would never succeed.</p>

        <p>It is <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        whether type errors are signaled statically.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e2186" id="d5e2186"></a>Example: A Type
            Error
          </div>

          <p>The following construct contains a type error, because
          <code>42</code> is not allowed as an operand of the
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction. An implementation <span class=
          "verb">may</span> optionally signal this as a static
          error, even though the offending instruction will never
          be evaluated, and the type error would therefore never be
          signaled as a dynamic error.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:if test="false()"&gt;
  &lt;xsl:apply-templates select="42"/&gt;
&lt;/xsl:if&gt;
</pre>
          </div>

          <p>On the other hand, in the following example it is not
          possible to determine statically whether the operand of
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          will have a suitable dynamic type. An implementation
          <span class="verb">may</span> produce a warning in such
          cases, but it <span class="verb">must not</span> treat it
          as an error.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:apply-templates select="$p"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>If more than one error arises, an implementation is not
        <span class="verb">required</span> to signal any errors
        other than the first one that it detects. It is <a title=
        "implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>
        which of the several errors is signaled. This applies both
        to static errors and to dynamic errors. An implementation
        is allowed to signal more than one error, but if any errors
        have been signaled, it <span class="verb">must not</span>
        finish as if the transformation were successful.</p>

        <p>When a transformation signals one or more dynamic
        errors, the final state of any persistent resources updated
        by the transformation is <a title=
        "implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>.
        Implementations are not <span class="verb">required</span>
        to restore such resources to their initial state. In
        particular, where a transformation produces multiple result
        documents, it is possible that one or more serialized
        result documents <span class="verb">may</span> be written
        successfully before the transformation terminates, but the
        application cannot rely on this behavior.</p>

        <p>Everything said above about error handling applies
        equally to errors in evaluating XSLT instructions, and
        errors in evaluating XPath <a title="expression" href=
        "#dt-expression">expressions</a>. Static errors and dynamic
        errors may occur in both cases.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-serialization-error" id="dt-serialization-error" title=
        "serialization error"></a>If a transformation has
        successfully produced a <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a>, it is still
        possible that errors may occur in serializing the result
        tree. For example, it may be impossible to serialize the
        result tree using the encoding selected by the user. Such
        an error is referred to as a <b>serialization
        error</b>.<span class="definition">]</span> <span>If the
        processor performs serialization, then it <span class=
        "verb">must</span> do so as specified in <a href=
        "#serialization"><i>20 Serialization</i></a>, and in
        particular it <span class="verb">must</span> signal any
        serialization errors that occur.</span></p>

        <p>Errors are identified by a QName. For errors defined in
        this specification, the namespace of the QName is always
        <code>http://www.w3.org/2005/xqt-errors</code> (and is
        therefore not given explicitly), while the local part is an
        8-character code in the form <var>PPSSNNNN</var>. Here
        <var>PP</var> is always <code>XT</code> (meaning XSLT), and
        <var>SS</var> is one of <code>SE</code> (static error),
        <code>DE</code> (dynamic error), <code>RE</code>
        (recoverable dynamic error), or <code>TE</code> (type
        error). Note that the allocation of an error to one of
        these categories is purely for convenience and carries no
        normative implications about the way the error is handled.
        Many errors, for example, can be reported either
        dynamically or statically.</p>

        <p>These error codes are used to label error conditions in
        this specification, and are summarized in <a href=
        "#error-summary"><i>E Summary of Error Conditions</i></a>).
        They are provided primarily for ease of reference.
        Implementations <span class="verb">may</span> use these
        codes when signaling errors, but they are not <span class=
        "verb">required</span> to do so. An API specification,
        however, <span class="verb">may</span> require the use of
        error codes based on these QNames. Additional errors
        defined by an implementation (or by an application)
        <span class="verb">may</span> use QNames in an
        implementation-defined (or user-defined) namespace without
        risk of collision.</p>

        <p>Errors defined in the <a href="#xpath20">[XPath 2.0]</a>
        and <a href="#xpath-functions">[Functions and
        Operators]</a> specifications use QNames with a similar
        structure, in the same namespace. When errors occur in
        processing XPath expressions, an XSLT processor
        <span class="verb">should</span> use the original error
        code reported by the XPath processor, unless a more
        specific XSLT error code is available.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="stylesheet-structure" id=
      "stylesheet-structure"></a>3 Stylesheet Structure</h2>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-stylesheet-module" id="dt-stylesheet-module" title=
      "stylesheet module"></a>A <a title="stylesheet" href=
      "#dt-stylesheet">stylesheet</a> consists of one or more
      <b>stylesheet modules</b>, each one forming all or part of an
      XML document.<span class="definition">]</span></p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>A stylesheet module is represented by an <span>XDM
        element node</span> (see <a href="#xpath-datamodel">[Data
        Model]</a>). <span>In the case of a standard stylesheet
        module, this will be an <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a> or
        <a href="#element-transform"><code>xsl:transform</code></a>
        element. In the case of a simplified stylesheet module, it
        can be any element (not in the <a title="XSLT namespace"
        href="#dt-xslt-namespace">XSLT namespace</a>) that has an
        <code>xsl:version</code> attribute.</span></p>

        <p>Although stylesheet modules will commonly be maintained
        in the form of documents conforming to XML 1.0 or XML 1.1,
        this specification does not mandate such a representation.
        As with <a title="source tree" href=
        "#dt-source-tree">source trees</a>, the way in which
        stylesheet modules are constructed, from textual XML or
        otherwise, is outside the scope of this specification.</p>
      </div>

      <p>A stylesheet module is either a standard stylesheet module
      or a simplified stylesheet module:</p>

      <ul>
        <li>
          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-standard-stylesheet-module" id=
          "dt-standard-stylesheet-module" title=
          "standard stylesheet module"></a>A <b>standard stylesheet
          module</b> is a tree, or part of a tree, consisting of an
          <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a> or
          <a href=
          "#element-transform"><code>xsl:transform</code></a>
          element (see <a href="#stylesheet-element"><i>3.6
          Stylesheet Element</i></a>) together with its descendant
          nodes and associated attributes and
          namespaces.<span class="definition">]</span></p>
        </li>

        <li>
          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-simplified-stylesheet-module" id=
          "dt-simplified-stylesheet-module" title=
          "simplified stylesheet module"></a>A <b>simplified
          stylesheet module</b> is a tree, or part of a tree,
          consisting of a <a title="literal result element" href=
          "#dt-literal-result-element">literal result element</a>
          together with its descendant nodes and associated
          attributes and namespaces. This element is not itself in
          the XSLT namespace, but it <span class="verb">must</span>
          have an <code>xsl:version</code> attribute, which implies
          that it <span class="verb">must</span> have a namespace
          node that declares a binding for the XSLT namespace. For
          further details see <a href=
          "#simplified-stylesheet"><i>3.7 Simplified Stylesheet
          Modules</i></a>. <span class="definition">]</span></p>
        </li>
      </ul>

      <p>Both forms of stylesheet module (standard and simplified)
      can exist either as an entire XML document, or embedded as
      part of another XML document, typically <span>but not
      necessarily</span> a source document that is to be processed
      using the stylesheet.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-standalone-stylesheet-module" id=
      "dt-standalone-stylesheet-module" title=
      "standalone stylesheet module"></a>A <b>standalone stylesheet
      module</b> is a stylesheet module that comprises the whole of
      an XML document.<span class="definition">]</span></p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-embedded-stylesheet-module" id=
      "dt-embedded-stylesheet-module" title=
      "embedded stylesheet module"></a>An <b>embedded stylesheet
      module</b> is a stylesheet module that is embedded within
      another XML document, typically the source document that is
      being transformed.<span class="definition">]</span> (see
      <a href="#embedded"><i>3.11 Embedded Stylesheet
      Modules</i></a>).</p>

      <p>There are thus four kinds of stylesheet module:</p>

      <blockquote>
        <p>standalone standard stylesheet modules<br />
        standalone simplified stylesheet modules<br />
        embedded standard stylesheet modules<br />
        embedded simplified stylesheet modules</p>
      </blockquote>

      <div class="div2">
        <h3><a name="xslt-namespace" id="xslt-namespace"></a>3.1
        XSLT Namespace</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-xslt-namespace" id="dt-xslt-namespace" title=
        "XSLT namespace"></a>The <b>XSLT namespace</b> has the URI
        <code>http://www.w3.org/1999/XSL/Transform</code>. It is
        used to identify elements, attributes, and other names that
        have a special meaning defined in this
        specification.<span class="definition">]</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The <code>1999</code> in the URI indicates the year in
          which the URI was allocated by the W3C. It does not
          indicate the version of XSLT being used, which is
          specified by attributes (see <a href=
          "#stylesheet-element"><i>3.6 Stylesheet Element</i></a>
          and <a href="#simplified-stylesheet"><i>3.7 Simplified
          Stylesheet Modules</i></a>).</p>
        </div>

        <p>XSLT <a title="processor" href=
        "#dt-processor">processors</a> <span class=
        "verb">must</span> use the XML namespaces mechanism
        <a href="#REC-xml-names">[Namespaces in XML 1.0]</a> to
        recognize elements and attributes from this namespace.
        Elements from the XSLT namespace are recognized only in the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        and not in the source document. The complete list of
        XSLT-defined elements is specified in <a href=
        "#element-syntax-summary"><i>D Element Syntax
        Summary</i></a>. <a title="implementation" href=
        "#dt-implementation">Implementations</a> <span class=
        "verb">must not</span> extend the XSLT namespace with
        additional elements or attributes. Instead, any extension
        <span class="verb">must</span> be in a separate namespace.
        Any namespace that is used for additional instruction
        elements <span class="verb">must</span> be identified by
        means of the <a title="extension instruction" href=
        "#dt-extension-instruction">extension instruction</a>
        mechanism specified in <a href=
        "#extension-instruction"><i>18.2 Extension
        Instructions</i></a>.</p>

        <p>This specification uses a prefix of <code>xsl:</code>
        for referring to elements in the XSLT namespace. However,
        XSLT stylesheets are free to use any prefix, provided that
        there is a namespace declaration that binds the prefix to
        the URI of the XSLT namespace.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Throughout this specification, an element or attribute
          that is in no namespace, or an <a title="expanded-QName"
          href="#dt-expanded-qname">expanded-QName</a> whose
          namespace part is an empty sequence, is referred to as
          having a <b>null namespace URI</b>.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The conventions used for the names of <a title=
          "XSLT element" href="#dt-xslt-element">XSLT elements</a>,
          attributes and functions are that names are all
          lower-case, use hyphens to separate words, and use
          abbreviations only if they already appear in the syntax
          of a related language such as XML or HTML. Names of types
          defined in XML Schema however, are regarded as single
          words and are capitalized exactly as in XML Schema. This
          sometimes leads to composite function names such as
          <a href=
          "http://www.w3.org/TR/xpath-functions/#func-current-dateTime">
          <code>current-dateTime</code></a><sup><small>FO</small></sup>.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="reserved-namespaces" id=
        "reserved-namespaces"></a>3.2 Reserved Namespaces</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-reserved-namespace" id="dt-reserved-namespace" title=
        "reserved namespace"></a>The XSLT namespace, together with
        certain other namespaces recognized by an XSLT processor,
        are classified as <b>reserved namespaces</b> and
        <span class="verb">must</span> be used only as specified in
        this and related specifications.<span class=
        "definition">]</span> The reserved namespaces are those
        listed below.</p>

        <ul>
          <li>
            <p>The <a title="XSLT namespace" href=
            "#dt-xslt-namespace">XSLT namespace</a>, described in
            <a href="#xslt-namespace"><i>3.1 XSLT
            Namespace</i></a>, is reserved.</p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-standard-function-namespace" id=
            "dt-standard-function-namespace" title=
            "standard function namespace"></a>The <b>standard
            function namespace</b>
            <code>http://www.w3.org/2005/xpath-functions</code> is
            used for functions in the function library defined in
            <a href="#xpath-functions">[Functions and
            Operators]</a> and standard functions defined in this
            specification.<span class="definition">]</span></p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "xml-namespace" id="xml-namespace" title=
            "XML namespace"></a>The <b>XML namespace</b>,
            <span>defined in <a href="#REC-xml-names">[Namespaces
            in XML 1.0]</a> as
            <code>http://www.w3.org/XML/1998/namespace</code></span>,
            is used for attributes such as <code>xml:lang</code>,
            <code>xml:space</code>, and
            <code>xml:id</code>.<span class=
            "definition">]</span></p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-schema-namespace" id="dt-schema-namespace" title=
            "schema namespace"></a>The <b>schema namespace</b>
            <code>http://www.w3.org/2001/XMLSchema</code> is used
            as defined in <a href="#xmlschema-1">[XML Schema Part
            1]</a> <span class="definition">]</span>. In a
            <a title="stylesheet" href=
            "#dt-stylesheet">stylesheet</a> this namespace may be
            used to refer to built-in schema datatypes and to the
            constructor functions associated with those
            datatypes.</p>
          </li>

          <li>
            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-schema-instance-namespace" id=
            "dt-schema-instance-namespace" title=
            "schema instance namespace"></a>The <b>schema instance
            namespace</b>
            <code>http://www.w3.org/2001/XMLSchema-instance</code>
            is used as defined in <a href="#xmlschema-1">[XML
            Schema Part 1]</a> <span class="definition">]</span>.
            Attributes in this namespace, if they appear in a
            <a title="stylesheet" href=
            "#dt-stylesheet">stylesheet</a>, are treated by the
            XSLT processor in the same way as any other
            attributes.</p>
          </li>
        </ul>

        <p>Reserved namespaces may be used without restriction to
        refer to the names of elements and attributes in source
        documents and result documents. As far as the XSLT
        processor is concerned, reserved namespaces other than the
        XSLT namespace may be used without restriction in the names
        of <a title="literal result element" href=
        "#dt-literal-result-element">literal result elements</a>
        and <a title="user-defined data element" href=
        "#dt-data-element">user-defined data elements</a>, and in
        the names of attributes of literal result elements or of
        <a title="XSLT element" href="#dt-xslt-element">XSLT
        <span>elements</span></a>: but other processors
        <span class="verb">may</span> impose restrictions or attach
        special meaning to them. Reserved namespaces <span class=
        "verb">must not</span> be used, however, in the names of
        stylesheet-defined objects such as <a title="variable"
        href="#dt-variable">variables</a> and <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet functions</a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>With the exception of the XML namespace, any of the
          above namespaces that are used in a stylesheet must be
          explicitly declared with a namespace declaration.
          Although conventional prefixes are used for these
          namespaces in this specification, any prefix may be used
          in a user stylesheet.</p>
        </div>

        <p><a name="err-XTSE0080" id="err-XTSE0080"><span class=
        "error">[ERR XTSE0080]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> to
        use a <a title="reserved namespace" href=
        "#dt-reserved-namespace">reserved namespace</a> in the name
        of a <a title="named template" href=
        "#dt-named-template">named template</a>, a <a title="mode"
        href="#dt-mode">mode</a>, an <a title="attribute set" href=
        "#dt-attribute-set">attribute set</a>, a <a title="key"
        href="#dt-key">key</a>, a <a title="decimal format" href=
        "#dt-decimal-format">decimal-format</a>, a <a title=
        "variable" href="#dt-variable">variable</a> or <a title=
        "parameter" href="#dt-parameter">parameter</a>, a <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a>, a named
        <a title="output definition" href=
        "#dt-output-definition">output definition</a>, or a
        <a title="character map" href="#dt-character-map">character
        map</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="extension-attributes" id=
        "extension-attributes"></a>3.3 Extension Attributes</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-extension-attribute" id="dt-extension-attribute" title=
        "extension attribute"></a>An element from the XSLT
        namespace may have any attribute not from the XSLT
        namespace, provided that the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> (see <a href=
        "#xpath20">[XPath 2.0]</a>) of the attribute has a non-null
        namespace URI. These attributes are referred to as
        <b>extension attributes</b>.<span class=
        "definition">]</span> The presence of an extension
        attribute <span class="verb">must not</span> cause the
        <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a> produced by
        the transformation to be different from the result trees
        that a conformant XSLT 2.0 processor might produce. They
        <span class="verb">must not</span> cause the processor to
        fail to signal an error that a conformant processor is
        required to signal. This means that an extension attribute
        <span class="verb">must not</span> change the effect of any
        <a title="instruction" href=
        "#dt-instruction">instruction</a> except to the extent that
        the effect is <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a> or
        <a title="implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>.</p>

        <p>Furthermore, if serialization is performed using one of
        the serialization methods <code>xml</code>,
        <code>xhtml</code>, <code>html</code>, or <code>text</code>
        described in <a href="#serialization"><i>20
        Serialization</i></a>, the presence of an extension
        attribute must not cause the serializer to behave in a way
        that is inconsistent with the mandatory provisions of that
        specification.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p><a title="extension attribute" href=
          "#dt-extension-attribute">Extension attributes</a> may be
          used to modify the behavior of <a title=
          "extension function" href=
          "#dt-extension-function">extension functions</a> and
          <a title="extension instruction" href=
          "#dt-extension-instruction">extension instructions</a>.
          They may be used to select processing options in cases
          where the specification leaves the behavior <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          or <a title="implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>.
          They may also be used for optimization hints, for
          diagnostics, or for documentation.</p>

          <p><a title="extension attribute" href=
          "#dt-extension-attribute">Extension attributes</a>
          <span class="verb">may</span> also be used to influence
          the behavior of the serialization methods
          <code>xml</code>, <code>xhtml</code>, <code>html</code>,
          or <code>text</code>, to the extent that the behavior of
          the serialization method is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          or <a title="implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>.
          For example, an extension attribute might be used to
          define the amount of indentation to be used when
          <code>indent="yes"</code> is specified. If a
          serialization method other than one of these four is
          requested (using a prefixed QName in the method
          parameter) then extension attributes may influence its
          behavior in arbitrary ways. Extension attributes
          <span class="verb">must not</span> be used to cause the
          four standard serialization methods to behave in a
          non-conformant way, for example by failing to report
          serialization errors that a serializer is <span class=
          "verb">required</span> to report. An implementation that
          wishes to provide such options must create a new
          serialization method for the purpose.</p>

          <p>An implementation that does not recognize the name of
          an extension attribute, or that does not recognize its
          value, <span class="verb">must</span> perform the
          transformation as if the extension attribute were not
          present. As always, it is permissible to produce warning
          messages.</p>

          <p>The namespace used for an extension attribute will be
          copied to the <a title="result tree" href=
          "#dt-result-tree">result tree</a> in the normal way if it
          is in scope for a <a title="literal result element" href=
          "#dt-literal-result-element">literal result element</a>.
          This can be prevented using the
          <code>[xsl:]exclude-result-prefixes</code> attribute.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e2801" id="d5e2801"></a>Example: An
            Extension Attribute for <code>xsl:message</code>
          </div>

          <p>The following code might be used to indicate to a
          particular implementation that the <a href=
          "#element-message"><code>xsl:message</code></a>
          instruction is to ask the user for confirmation before
          continuing with the transformation:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:message
    abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;Phase 1 complete&lt;/xsl:message&gt;
</pre>
          </div>

          <p>Implementations that do not recognize the namespace
          <code>http://vendor.example.com/xslt/extensions</code>
          will simply ignore the extra attribute, and evaluate the
          <a href="#element-message"><code>xsl:message</code></a>
          instruction in the normal way.</p>
        </div>

        <p><a name="err-XTSE0090" id="err-XTSE0090"><span class=
        "error">[ERR XTSE0090]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> for
        an element from the XSLT namespace to have an attribute
        whose namespace is either null (that is, an attribute with
        an unprefixed name) or the XSLT namespace, other than
        attributes defined for the element in this document.</p>
      </div>

      <div class="div2">
        <h3><a name="xslt-media-type" id="xslt-media-type"></a>3.4
        XSLT Media Type</h3>

        <p>The media type <code>application/xslt+xml</code> will be
        registered for XSLT stylesheet modules.</p>

        <p>The proposed definition of the media type is at <a href=
        "#xslt-mime-definition"><i>B The XSLT Media
        Type</i></a></p>

        <p>This media type <span class="verb">should</span> be used
        for an XML document containing a <a title=
        "standard stylesheet module" href=
        "#dt-standard-stylesheet-module">standard stylesheet
        module</a> at its top level, and it <span class=
        "verb">may</span> also be used for a <a title=
        "simplified stylesheet module" href=
        "#dt-simplified-stylesheet-module">simplified stylesheet
        module</a>. It <span class="verb">should not</span> be used
        for an XML document containing an <a title=
        "embedded stylesheet module" href=
        "#dt-embedded-stylesheet-module">embedded stylesheet
        module</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="standard-attributes" id=
        "standard-attributes"></a>3.5 Standard Attributes</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-standard-attributes" id="dt-standard-attributes" title=
        "standard attributes"></a>There are a number of <b>standard
        attributes</b> that may appear on any <a title=
        "XSLT element" href="#dt-xslt-element">XSLT element</a>:
        specifically <code>version</code>,
        <code>exclude-result-prefixes</code>,
        <code>extension-element-prefixes</code>,
        <code>xpath-default-namespace</code><span>,
        <code>default-collation</code>, and
        <code>use-when</code>.</span><span class=
        "definition">]</span></p>

        <p>These attributes may also appear on a <a title=
        "literal result element" href=
        "#dt-literal-result-element">literal result element</a>,
        but in this case, to distinguish them from user-defined
        attributes, the names of the attributes are in the
        <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
        namespace</a>. They are thus typically written as
        <code>xsl:version</code>,
        <code>xsl:exclude-result-prefixes</code>,
        <code>xsl:extension-element-prefixes</code>,
        <code>xsl:xpath-default-namespace</code><span>,
        <code>xsl:default-collation</code>, or
        <code>xsl:use-when</code></span>.</p>

        <p>It is <span class="verb">recommended</span> that all
        these attributes should also be permitted on <a title=
        "extension instruction" href=
        "#dt-extension-instruction">extension instructions</a>, but
        this is at the discretion of the implementer of each
        extension instruction. They <span class="verb">may</span>
        also be permitted on <a title="user-defined data element"
        href="#dt-data-element">user-defined data elements</a>,
        though they will only have any useful effect in the case of
        data elements that are designed to behave like XSLT
        declarations or instructions.</p>

        <p>In the following descriptions, these attributes are
        referred to generically as <code>[xsl:]version</code>, and
        so on.</p>

        <p>These attributes all affect the element they appear on,
        <span>together with any elements and attributes that have
        that element as an ancestor</span>. The two forms with and
        without the XSLT namespace have the same effect; the XSLT
        namespace is used for the attribute if and only if its
        parent element is <em>not</em> in the XSLT namespace.</p>

        <p>In the case of <code>[xsl:]version</code>,
        <code>[xsl:]xpath-default-namespace</code>, and
        <code>[xsl:]default-collation</code>, the value can be
        overridden by a different value for the same attribute
        appearing on a descendant element. The effective value of
        the attribute for a particular stylesheet element is
        determined by the innermost <span>ancestor-or-self</span>
        element on which the attribute appears.</p>

        <p>In an <a title="embedded stylesheet module" href=
        "#dt-embedded-stylesheet-module">embedded stylesheet
        module</a>, <a title="standard attributes" href=
        "#dt-standard-attributes">standard attributes</a> appearing
        on ancestors of the outermost element of the stylesheet
        module have no effect.</p>

        <p>In the case of
        <code>[xsl:]exclude-result-prefixes</code> and
        <code>[xsl:]extension-element-prefixes</code> the values
        are cumulative. For these attributes, the value is given as
        a whitespace-separated list of namespace prefixes, and the
        effective value for an element is the combined set of
        namespace URIs designated by the prefixes that appear in
        this attribute for that element and any of its ancestor
        elements. Again, the two forms with and without the XSLT
        namespace are equivalent.</p>

        <p>The effect of the <code>[xsl:]use-when</code> attribute
        is described in <a href="#conditional-inclusion"><i>3.12
        Conditional Element Inclusion</i></a>.</p>

        <p>Because these attributes may appear on any <a title=
        "XSLT element" href="#dt-xslt-element">XSLT element</a>,
        they are not listed in the syntax summary of each
        individual element. Instead they are listed and described
        in the entry for the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a> and
        <a href="#element-transform"><code>xsl:transform</code></a>
        elements only. This reflects the fact that these attributes
        are often used on the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element only, in which case they apply to the entire
        <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a>.</p>

        <p>Note that the effect of these attributes does
        <em>not</em> extend to <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet modules</a> referenced
        by <a href="#element-include"><code>xsl:include</code></a>
        or <a href="#element-import"><code>xsl:import</code></a>
        declarations.</p>

        <p>For the detailed effect of each attribute, see the
        following sections:</p>

        <dl>
          <dt class="label"><code>[xsl:]version</code></dt>

          <dd>
            <p>see <a href="#backwards"><i>3.8 Backwards-Compatible
            Processing</i></a> and <a href="#forwards"><i>3.9
            Forwards-Compatible Processing</i></a></p>
          </dd>

          <dt class="label">
          <code>[xsl:]xpath-default-namespace</code></dt>

          <dd>
            <p>see <a href="#unprefixed-qnames"><i>5.2 Unprefixed
            QNames in Expressions and Patterns</i></a></p>
          </dd>

          <dt class="label">
          <code>[xsl:]exclude-result-prefixes</code></dt>

          <dd>
            <p>see <a href="#lre-namespaces"><i>11.1.3 Namespace
            Nodes for Literal Result Elements</i></a></p>
          </dd>

          <dt class="label">
          <code>[xsl:]extension-element-prefixes</code></dt>

          <dd>
            <p>see <a href="#extension-instruction"><i>18.2
            Extension Instructions</i></a></p>
          </dd>

          <dt class="label"><code>[xsl:]use-when</code></dt>

          <dd>
            <p>see <a href="#conditional-inclusion"><i>3.12
            Conditional Element Inclusion</i></a></p>
          </dd>

          <dt class="label">
          <code>[xsl:]default-collation</code></dt>

          <dd>
            <p>see <a href="#default-collation-attribute"><i>3.6.1
            The default-collation attribute</i></a></p>
          </dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a name="stylesheet-element" id=
        "stylesheet-element"></a>3.6 Stylesheet Element</h3>

        <p class="element-syntax"><a name="element-stylesheet" id=
        "element-stylesheet"></a><code>&lt;xsl:stylesheet<br />
        &#160;&#160;id? = <var>id</var><br />
        &#160;&#160;extension-element-prefixes? =
        <var>tokens</var><br />
        &#160;&#160;exclude-result-prefixes? =
        <var>tokens</var><br />
        &#160;&#160;<b>version</b> = <var>number</var><br />
        &#160;&#160;xpath-default-namespace? = <var>uri</var><br />
        &#160;&#160;default-validation? = "preserve" |
        "strip"<br />
        &#160;&#160;default-collation? = <var>uri-list</var><br />
        &#160;&#160;input-type-annotations? = "preserve" | "strip"
        | "unspecified"&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-import">xsl:import</a>*,
        <var>other-declarations</var>) --&gt;<br />
        &lt;/xsl:stylesheet&gt;</code></p>

        <p class="element-syntax"><a name="element-transform" id=
        "element-transform"></a><code>&lt;xsl:transform<br />
        &#160;&#160;id? = <var>id</var><br />
        &#160;&#160;extension-element-prefixes? =
        <var>tokens</var><br />
        &#160;&#160;exclude-result-prefixes? =
        <var>tokens</var><br />
        &#160;&#160;<b>version</b> = <var>number</var><br />
        &#160;&#160;xpath-default-namespace? = <var>uri</var><br />
        &#160;&#160;default-validation? = "preserve" |
        "strip"<br />
        &#160;&#160;default-collation? = <var>uri-list</var><br />
        &#160;&#160;input-type-annotations? = "preserve" | "strip"
        | "unspecified"&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-import">xsl:import</a>*,
        <var>other-declarations</var>) --&gt;<br />
        &lt;/xsl:transform&gt;</code></p>

        <p>A stylesheet module is represented by an <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element in an XML document. <a href=
        "#element-transform"><code>xsl:transform</code></a> is
        allowed as a synonym for <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>;
        everything this specification says about the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element applies equally to <a href=
        "#element-transform"><code>xsl:transform</code></a>.</p>

        <p>An <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element <span class="verb">must</span> have a
        <code>version</code> attribute, indicating the version of
        XSLT that the stylesheet <span>module</span> requires.</p>

        <p><a name="err-XTSE0110" id="err-XTSE0110"><span class=
        "error">[ERR XTSE0110]</span></a> The value of the
        <code>version</code> attribute <span class=
        "verb">must</span> be a number: specifically, it
        <span class="verb">must</span> be a <span>a valid instance
        of the type <code>xs:decimal</code> as defined in <a href=
        "#xmlschema-2">[XML Schema Part 2]</a></span>. For this
        version of XSLT, the value <span class="verb">should</span>
        normally be <code>2.0</code>. A value of <code>1.0</code>
        indicates that the stylesheet module was written with the
        intention that it <span class="verb">should</span> be
        processed using an XSLT 1.0 processor.</p>

        <p>If a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> that specifies
        <code>[xsl:]version="1.0"</code> in the outermost element
        of the <a title="principal stylesheet module" href=
        "#dt-principal-stylesheet-module">principal stylesheet
        module</a> (that is, <code>version="1.0"</code> in the case
        of a <a title="standard stylesheet module" href=
        "#dt-standard-stylesheet-module">standard stylesheet
        module</a>, or <code>xsl:version="1.0"</code> in the case
        of a <a title="simplified stylesheet module" href=
        "#dt-simplified-stylesheet-module">simplified stylesheet
        module</a>) is submitted to an XSLT 2.0 processor, the
        processor <span class="verb">should</span> output a warning
        advising the user of possible incompatibilities, unless the
        user has requested otherwise. The processor <span class=
        "verb">must</span> then process the stylesheet using the
        rules for <a title="backwards compatible behavior" href=
        "#dt-backwards-compatible-behavior">backwards-compatible
        behavior</a>. These rules require that if the processor
        does not support <a title="backwards compatible behavior"
        href=
        "#dt-backwards-compatible-behavior">backwards-compatible
        behavior</a>, it <span class="verb">must</span> signal an
        error and <span class="verb">must not</span> execute the
        transformation.</p>

        <p>When the value of the <code>version</code> attribute is
        greater than 2.0, <a title="forwards-compatible behavior"
        href="#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a> is enabled (see <a href="#forwards"><i>3.9
        Forwards-Compatible Processing</i></a>).</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>XSLT 1.0 allowed the <code>[xsl:]version</code>
          attribute to take any numeric value, and specified that
          if the value was not equal to 1.0, the <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> would
          be executed in forwards compatible mode. XSLT 2.0
          continues to allow the attribute to take any unsigned
          decimal value. A software product that includes both an
          XSLT 1.0 processor and an XSLT 2.0 processor (or that can
          execute as either) may use the <code>[xsl:]version</code>
          attribute to decide which processor to invoke; such
          behavior is outside the scope of this specification. When
          the stylesheet is executed with an XSLT 2.0 processor,
          the value <code>1.0</code> is taken to indicate that the
          stylesheet <span>module</span> was written with XSLT 1.0
          in mind: if this value appears on the outermost element
          of the principal stylesheet module then an XSLT 2.0
          processor will either reject the stylesheet or execute it
          in backwards compatible mode, as described above. Setting
          <code>version="2.0"</code> indicates that the <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> is to
          be executed with neither backwards nor forwards
          compatible behavior enabled. Any other value less than
          <code>2.0</code> enables backwards compatible behavior,
          while any value greater than <code>2.0</code> enables
          forwards compatible behavior.</p>

          <p>When developing a <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that is designed to
          execute under either XSLT 1.0 or XSLT 2.0, the
          recommended practice is to create two alternative
          <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a>, one
          specifying <code>version="1.0"</code>, and the other
          specifying <code>version="2.0"</code>; these modules can
          use <a href=
          "#element-include"><code>xsl:include</code></a> or
          <a href="#element-import"><code>xsl:import</code></a> to
          incorporate the common code. When running under an XSLT
          1.0 processor, the <code>version="1.0"</code> module can
          be selected as the <a title="principal stylesheet module"
          href="#dt-principal-stylesheet-module">principal
          stylesheet module</a>; when running under an XSLT 2.0
          processor, the <code>version="2.0"</code> module can be
          selected as the <a title="principal stylesheet module"
          href="#dt-principal-stylesheet-module">principal
          stylesheet module</a>. Stylesheet modules that are
          included or imported should specify
          <code>version="2.0"</code> if they make use of XSLT 2.0
          facilities, and <code>version="1.0"</code> otherwise.</p>
        </div>

        <p>The effect of the <code>input-type-annotations</code>
        attribute is described in <a href=
        "#stripping-annotations"><i>4.3 Stripping Type Annotations
        from a Source Tree</i></a>.</p>

        <p>The <code>default-validation</code> attribute defines
        the default value of the <code>validation</code> attribute
        of all <span><a href=
        "#element-document"><code>xsl:document</code></a></span>,
        <a href="#element-element"><code>xsl:element</code></a>,
        <a href=
        "#element-attribute"><code>xsl:attribute</code></a>,
        <a href="#element-copy"><code>xsl:copy</code></a>, <a href=
        "#element-copy-of"><code>xsl:copy-of</code></a>, and
        <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instructions, and of the <code>xsl:validation</code>
        attribute of all <a title="literal result element" href=
        "#dt-literal-result-element">literal result elements</a>.
        It also determines the validation applied to the implicit
        <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> created in
        the absence of an <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction. This default applies within the <a title=
        "stylesheet module" href="#dt-stylesheet-module">stylesheet
        module</a>: it does not extend to included or imported
        stylesheet modules. If the attribute is omitted, the
        default is <code>strip</code>. <span>The permitted values
        are <code>preserve</code> and <code>strip</code>.</span>
        For details of the effect of this attribute, see <a href=
        "#validation"><i>19.2 Validation</i></a>.</p>

        <p><a name="err-XTSE0120" id="err-XTSE0120"><span class=
        "error">[ERR XTSE0120]</span></a> An <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element <span class="verb">must not</span> have any text
        node children. (This rule applies after stripping of
        <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text nodes</a> as
        described in <a href="#stylesheet-stripping"><i>4.2
        Stripping Whitespace from the Stylesheet</i></a>.)</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-top-level" id="dt-top-level" title="top-level"></a>An
        element occurring as a child of an <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element is called a <b>top-level</b> element.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-declaration" id="dt-declaration" title=
        "declaration"></a>Top-level elements fall into two
        categories: declarations, and user-defined data elements.
        Top-level elements whose names are in the <a title=
        "XSLT namespace" href="#dt-xslt-namespace">XSLT
        namespace</a> are <b>declarations</b>. Top-level elements
        in any other namespace are <a title=
        "user-defined data element" href=
        "#dt-data-element">user-defined data elements</a> (see
        <a href="#user-defined-top-level"><i>3.6.2 User-defined
        Data Elements</i></a>)<span class=
        "definition">]</span>.</p>

        <p>The <a title="declaration" href=
        "#dt-declaration">declaration</a> elements permitted in the
        <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element are:</p>

        <blockquote>
          <p><a href=
          "#element-import"><code>xsl:import</code></a><br />
          <a href=
          "#element-include"><code>xsl:include</code></a><br />
          <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a><br />

          <a href=
          "#element-character-map"><code>xsl:character-map</code></a><br />

          <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a><br />

          <a href=
          "#element-function"><code>xsl:function</code></a><br />
          <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a><br />

          <a href="#element-key"><code>xsl:key</code></a><br />
          <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a><br />

          <a href=
          "#element-output"><code>xsl:output</code></a><br />
          <a href="#element-param"><code>xsl:param</code></a><br />
          <a href=
          "#element-preserve-space"><code>xsl:preserve-space</code></a><br />

          <a href=
          "#element-strip-space"><code>xsl:strip-space</code></a><br />

          <a href=
          "#element-template"><code>xsl:template</code></a><br />
          <a href=
          "#element-variable"><code>xsl:variable</code></a></p>
        </blockquote>

        <p>Note that the <a href=
        "#element-variable"><code>xsl:variable</code></a> and
        <a href="#element-param"><code>xsl:param</code></a>
        elements can act either as <a title="declaration" href=
        "#dt-declaration">declarations</a> or as <a title=
        "instruction" href="#dt-instruction">instructions</a>. A
        global variable or parameter is defined using a
        declaration; a local variable or parameter using an
        instruction.</p>

        <p>If there are <a href=
        "#element-import"><code>xsl:import</code></a> elements,
        these <span class="verb">must</span> come before any other
        elements. Apart from this, the child elements of the
        <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element may appear in any order. The ordering of these
        elements does not affect the results of the transformation
        unless there are conflicting declarations (for example, two
        template rules with the same priority that match the same
        node). In general, it is an error for a <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> to
        contain such conflicting declarations, but in some cases
        the processor is allowed to recover from the error by
        choosing the declaration that appears last in the
        stylesheet.</p>

        <div class="div3">
          <h4><a name="default-collation-attribute" id=
          "default-collation-attribute"></a>3.6.1 The
          <code>default-collation</code> attribute</h4>

          <p>The <code>default-collation</code> attribute is a
          <a title="standard attributes" href=
          "#dt-standard-attributes">standard attribute</a> that may
          appear on any element in the XSLT namespace, or (as
          <code>xsl:default-collation</code>) on a <a title=
          "literal result element" href=
          "#dt-literal-result-element">literal result
          element</a>.</p>

          <p>The attribute is used to specify the default collation
          used by all XPath expressions appearing in the attributes
          of this element, or attributes of descendant elements,
          unless overridden by another
          <code>default-collation</code> attribute on an inner
          element. It also determines the collation used by certain
          XSLT constructs (such as <a href=
          "#element-key"><code>xsl:key</code></a> and <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>)
          within its scope.</p>

          <p>The value of the attribute is a whitespace-separated
          list of collation URIs. <span>If any of these URIs is a
          relative URI, then it is resolved relative to the base
          URI of the attribute's parent element. If the
          implementation recognizes one or more of the resulting
          absolute collation URIs</span>, then it uses the first
          one that it recognizes as the default collation.</p>

          <p><a name="err-XTSE0125" id="err-XTSE0125"><span class=
          "error">[ERR XTSE0125]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the value of an <code>[xsl:]default-collation</code>
          attribute<span>, after resolving against the base
          URI,</span> contains no URI that the implementation
          recognizes as a collation URI.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The reason the attribute allows a list of collation
            URIs is that collation URIs will often be meaningful
            only to one particular XSLT implementation. Stylesheets
            designed to run with several different implementations
            can therefore specify several different collation URIs,
            one for use with each. To avoid the above error
            condition, it is possible to specify the Unicode
            Codepoint Collation as the last collation URI in the
            list.</p>
          </div>

          <p>The <code>[xsl:]default-collation</code> attribute
          does not affect the collation used by
          <code>xsl:sort</code>.</p>
        </div>

        <div class="div3">
          <h4><a name="user-defined-top-level" id=
          "user-defined-top-level"></a>3.6.2 User-defined Data
          Elements</h4>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-data-element" id="dt-data-element" title=
          "user-defined data element"></a>In addition to <a title=
          "declaration" href="#dt-declaration">declarations</a>,
          the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element may contain any element not from the <a title=
          "XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, provided that the <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of the element
          has a non-null namespace URI. Such elements are referred
          to as <b>user-defined data elements</b>.<span class=
          "definition">]</span></p>

          <p><a name="err-XTSE0130" id="err-XTSE0130"><span class=
          "error">[ERR XTSE0130]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element has a child element whose name has a null
          namespace URI.</p>

          <p>An implementation <span class="verb">may</span> attach
          <span>an <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a></span>
          meaning to user-defined data elements that appear in
          <span>particular namespaces</span>. The set of namespaces
          that are recognized for such data elements is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          The presence of a user-defined data element <span class=
          "verb">must not</span> change the behavior of <a title=
          "XSLT element" href="#dt-xslt-element">XSLT elements</a>
          and functions defined in this document; for example, it
          is not permitted for a user-defined data element to
          specify that <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          should use different rules to resolve conflicts.
          <span>The constraints on what user-defined data elements
          can and cannot do are exactly the same as the constraints
          on <a title="extension attribute" href=
          "#dt-extension-attribute">extension attributes</a>,
          described in <a href="#extension-attributes"><i>3.3
          Extension Attributes</i></a>.</span> Thus, an
          implementation is always free to ignore user-defined data
          elements, and <span class="verb">must</span> ignore such
          data elements without giving an error if it does not
          recognize the namespace URI.</p>

          <p>User-defined data elements can provide, for
          example,</p>

          <ul>
            <li>
              <p>information used by <a title=
              "extension instruction" href=
              "#dt-extension-instruction">extension
              instructions</a> or <a title="extension function"
              href="#dt-extension-function">extension functions</a>
              (see <a href="#extension"><i>18 Extensibility and
              Fallback</i></a>),</p>
            </li>

            <li>
              <p>information about what to do with any <a title=
              "final result tree" href=
              "#dt-final-result-tree">final result tree</a>,</p>
            </li>

            <li>
              <p>information about how to construct <a title=
              "source tree" href="#dt-source-tree">source
              trees</a>,</p>
            </li>

            <li>
              <p>optimization hints for the <a title="processor"
              href="#dt-processor">processor</a>,</p>
            </li>

            <li>
              <p>metadata about the stylesheet,</p>
            </li>

            <li>
              <p>structured documentation for the stylesheet.</p>
            </li>
          </ul>

          <p>A <a title="user-defined data element" href=
          "#dt-data-element">user-defined data element</a>
          <span class="verb">must not</span> precede an <a href=
          "#element-import"><code>xsl:import</code></a> element
          within a <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a>
          <span><span class="error">[see <a href=
          "#err-XTSE0200">ERR XTSE0200</a>]</span></span></p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="simplified-stylesheet" id=
        "simplified-stylesheet"></a>3.7 Simplified Stylesheet
        Modules</h3>

        <p>A simplified syntax is allowed for a <a title=
        "stylesheet module" href="#dt-stylesheet-module">stylesheet
        module</a> that defines only a single template rule for the
        document node. The stylesheet module may consist of just a
        <a title="literal result element" href=
        "#dt-literal-result-element">literal result element</a>
        (see <a href="#literal-result-element"><i>11.1 Literal
        Result Elements</i></a>) together with its contents.
        <span>The literal result element must have an
        <code>xsl:version</code> attribute (and it must therefore
        also declare the XSLT namespace).</span> Such a stylesheet
        <span>module</span> is equivalent to a standard stylesheet
        module whose <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element contains a <a title="template rule" href=
        "#dt-template-rule">template rule</a> containing the
        literal result element, <span>minus its
        <code>xsl:version</code> attribute</span>; the template
        rule has a match <a title="pattern" href=
        "#dt-pattern">pattern</a> of <code>/</code>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e3741" id="d5e3741"></a>Example: A
            Simplified Stylesheet
          </div>

          <p>For example:</p>

          <div class="exampleInner">
            <pre>
&lt;html xsl:version="2.0"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xmlns="http://www.w3.org/1999/xhtml"&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
          </div>

          <p>has the same meaning as</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;xsl:template match="/"&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Expense Report Summary&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Total Amount: &lt;xsl:value-of select="expense-report/total"/&gt;&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre>
          </div>

          <p>Note that it is not possible, using a simplified
          stylesheet, to request that the serialized output
          contains a <code>DOCTYPE</code> declaration. This can
          only be done by using a standard stylesheet module, and
          using the <a href=
          "#element-output"><code>xsl:output</code></a>
          element.</p>
        </div>

        <p>More formally, a simplified stylesheet module is
        equivalent to the standard stylesheet module that would be
        generated by applying the following transformation to the
        simplified stylesheet module, invoking the transformation
        by calling the <a title="named template" href=
        "#dt-named-template">named template</a>
        <code>expand</code>, with the containing literal result
        element as the <a title="context node" href=
        "#dt-context-node">context node</a>:</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:attribute name="version" select="@xsl:version"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match"&gt;/&lt;/xsl:attribute&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;  

&lt;/xsl:stylesheet&gt;
</pre>
        </div>

        <p><a name="err-XTSE0150" id="err-XTSE0150"><span class=
        "error">[ERR XTSE0150]</span></a> A <a title=
        "literal result element" href=
        "#dt-literal-result-element">literal result element</a>
        that is used as the outermost element of a simplified
        stylesheet module <span class="verb">must</span> have an
        <code>xsl:version</code> attribute. This indicates the
        version of XSLT that the stylesheet requires. For this
        version of XSLT, the value will normally be
        <code>2.0</code>; the value <span class="verb">must</span>
        be a <span>valid instance of the type
        <code>xs:decimal</code> as defined in <a href=
        "#xmlschema-2">[XML Schema Part 2]</a></span>.</p>

        <p>Other <a title="literal result element" href=
        "#dt-literal-result-element">literal result elements</a>
        may also have an <code>xsl:version</code> attribute. When
        the <code>xsl:version</code> attribute is numerically less
        than <code>2.0</code>, backwards-compatible processing
        behavior is enabled (see <a href="#backwards"><i>3.8
        Backwards-Compatible Processing</i></a>). When the
        <code>xsl:version</code> attribute is numerically greater
        than <code>2.0</code>, <a title=
        "forwards-compatible behavior" href=
        "#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a> is enabled (see <a href="#forwards"><i>3.9
        Forwards-Compatible Processing</i></a>).</p>

        <p>The allowed content of a literal result element when
        used as a simplified stylesheet is the same as when it
        occurs within a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>. Thus,
        a literal result element used as the document element of a
        simplified stylesheet cannot contain <a title="declaration"
        href="#dt-declaration">declarations</a>. <span>Simplified
        stylesheets therefore cannot use <a title="global variable"
        href="#dt-global-variable">global variables</a>, <a title=
        "stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameters</a>,
        <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet functions</a>,
        <a title="key" href="#dt-key">keys</a>, <a title=
        "attribute set" href=
        "#dt-attribute-set">attribute-sets</a>, or <a title=
        "output definition" href="#dt-output-definition">output
        definitions</a>. In turn this means that the only useful
        way to initiate the transformation is to supply a document
        node as the <a title="initial context node" href=
        "#dt-initial-context-node">initial context node</a>, to be
        matched by the implicit <code>match="/"</code> template
        rule using the <a title="default mode" href=
        "#dt-default-mode">default mode</a>.</span></p>
      </div>

      <div class="div2">
        <h3><a name="backwards" id="backwards"></a>3.8
        Backwards-Compatible Processing</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-backwards-compatible-behavior" id=
        "dt-backwards-compatible-behavior" title=
        "backwards compatible behavior"></a>An element enables
        backwards-compatible behavior for itself, its attributes,
        its descendants and their attributes if it has an
        <code>[xsl:]version</code> attribute (see <a href=
        "#standard-attributes"><i>3.5 Standard Attributes</i></a>)
        whose value is less than <code>2.0</code>.<span class=
        "definition">]</span></p>

        <p>An element that has an <code>[xsl:]version</code>
        attribute whose value is greater than or equal to
        <code>2.0</code> disables backwards-compatible behavior for
        itself, its attributes, its descendants and their
        attributes. The compatibility behavior established by an
        element overrides any compatibility behavior established by
        an ancestor element.</p>

        <p>If an attribute containing an XPath <a title=
        "expression" href="#dt-expression">expression</a> is
        processed with backwards-compatible behavior, then the
        expression is evaluated with <a title=
        "XPath 1.0 compatibility mode" href=
        "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
        set to <code>true</code>. For details of this mode, see
        <a href=
        "http://www.w3.org/TR/xpath20/#static_context">Section
        2.1.1 Static Context</a><sup><small>XP</small></sup>.
        <span>Furthermore, in such an expression any function call
        for which no implementation is available (unless it uses
        the <a title="standard function namespace" href=
        "#dt-standard-function-namespace">standard function
        namespace</a>) is bound to a fallback error function whose
        effect when evaluated is to raise a dynamic error
        <span class="error">[see <a href="#err-XTDE1425">ERR
        XTDE1425</a>]</span> . The effect is that with
        backwards-compatible behavior enabled, calls on <a title=
        "extension function" href=
        "#dt-extension-function">extension functions</a> that are
        not available in a particular implementation do not cause
        an error unless the function call is actually evaluated.
        For further details, see <a href=
        "#extension-functions"><i>18.1 Extension
        Functions</i></a>.</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This might appear to contradict the specification of
          XPath 2.0, which states that a static error [XPST0017] is
          raised when an expression contains a call to a function
          that is not present (with matching name and arity) in the
          static context. This apparent contradiction is resolved
          by specifying that the XSLT processor constructs a static
          context for the expression in which every possible
          function name and arity (other than names in the
          <a title="standard function namespace" href=
          "#dt-standard-function-namespace">standard function
          namespace</a>) is present; when no other implementation
          of the function is available, the function call is bound
          to a fallback error function whose run-time effect is to
          raise a dynamic error.</p>
        </div>

        <p>Certain XSLT constructs also produce different results
        when backwards-compatible behavior is enabled. This is
        described separately for each such construct.</p>

        <p>These rules do not apply to the <a href=
        "#element-output"><code>xsl:output</code></a> element,
        whose <code>version</code> attribute has an entirely
        different purpose: it is used to define the version of the
        output method to be used for serialization.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p><span>By making use of backwards-compatible behavior,
          it is possible to write the stylesheet in a way that
          ensures that its results when processed with an XSLT 2.0
          processor are identical to the effects of processing the
          same stylesheet using an XSLT 1.0 processor.</span> The
          differences are described (non-normatively) in <a href=
          "#incompatibilities"><i>J.1 Incompatible Changes</i></a>.
          To assist with transition, some parts of a stylesheet may
          be processed with backwards compatible behavior enabled,
          and other parts with this behavior disabled. All data
          values manipulated by an XSLT 2.0 processor are defined
          by the <span>XDM</span> data model, whether or not the
          relevant expressions use backwards compatible behavior.
          Because the same data model is used in both cases,
          expressions are fully composable. The result of
          evaluating instructions or expressions with backwards
          compatible behavior is fully defined in the XSLT 2.0 and
          XPath 2.0 specifications, it is not defined by reference
          to the XSLT 1.0 and XPath 1.0 specifications.</p>
        </div>

        <p>It is <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        whether a particular XSLT 2.0 implementation supports
        backwards-compatible behavior.</p>

        <p><a name="err-XTDE0160" id="err-XTDE0160"><span class=
        "error">[ERR XTDE0160]</span></a> If an implementation does
        not support backwards-compatible behavior, then it is a
        <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if any element is evaluated that enables
        backwards-compatible behavior.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>To write a stylesheet that works with both XSLT 1.0
          and 2.0 processors, while making selective use of XSLT
          2.0 facilities, it is necessary to understand both the
          rules for backwards-compatible behavior in XSLT 2.0, and
          the rules for forwards-compatible behavior in XSLT 1.0.
          If the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element specifies <code>version="2.0"</code>, then an
          XSLT 1.0 processor will ignore XSLT 2.0 <a title=
          "declaration" href="#dt-declaration">declarations</a>
          that were not defined in XSLT 1.0, for example <a href=
          "#element-function"><code>xsl:function</code></a> and
          <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>.
          If any new XSLT 2.0 instructions are used (for example
          <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          or <a href=
          "#element-namespace"><code>xsl:namespace</code></a>), or
          if new XPath 2.0 features are used (for example, new
          functions, or syntax such as conditional expressions, or
          calls to a function defined using <a href=
          "#element-function"><code>xsl:function</code></a>), then
          the stylesheet must provide fallback behavior that relies
          on XSLT 1.0 and XPath 1.0 facilities only. The fallback
          behavior can be invoked by using the <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          instruction, or by testing the results of the <a href=
          "#function-function-available"><code>function-available</code></a>
          or <a href=
          "#function-element-available"><code>element-available</code></a>
          functions, or by testing the value of the
          <code>xsl:version</code> property returned by the
          <a href="#function-system-property"><code>system-property</code></a>
          function.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="forwards" id="forwards"></a>3.9
        Forwards-Compatible Processing</h3>

        <p>The intent of forwards-compatible behavior is to make it
        possible to write a stylesheet that takes advantage of
        features introduced in some version of XSLT subsequent to
        XSLT 2.0, while retaining the ability to execute the
        stylesheet with an XSLT 2.0 processor using appropriate
        fallback behavior.</p>

        <p>It is always possible to write conditional code to run
        under different XSLT versions by using the
        <code>use-when</code> feature described in <a href=
        "#conditional-inclusion"><i>3.12 Conditional Element
        Inclusion</i></a>. The rules for forwards-compatible
        behavior supplement this mechanism in two ways:</p>

        <ul>
          <li>
            <p>certain constructs in the stylesheet that mean
            nothing to an XSLT 2.0 processor are ignored, rather
            than being treated as errors.</p>
          </li>

          <li>
            <p>explicit fallback behavior can be defined for
            instructions defined in a future XSLT release, using
            the <a href=
            "#element-fallback"><code>xsl:fallback</code></a>
            instruction.</p>
          </li>
        </ul>

        <p>The detailed rules follow.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-forwards-compatible-behavior" id=
        "dt-forwards-compatible-behavior" title=
        "forwards-compatible behavior"></a>An element enables
        <b>forwards-compatible behavior</b> for itself, its
        attributes, its descendants and their attributes if it has
        an <code>[xsl:]version</code> attribute (see <a href=
        "#standard-attributes"><i>3.5 Standard Attributes</i></a>)
        whose value is greater than <code>2.0</code>.<span class=
        "definition">]</span></p>

        <p>An element that has an <code>[xsl:]version</code>
        attribute whose value is less than or equal to
        <code>2.0</code> disables forwards-compatible behavior for
        itself, its attributes, its descendants and their
        attributes. The compatibility behavior established by an
        element overrides any compatibility behavior established by
        an ancestor element.</p>

        <p>These rules do not apply to the <code>version</code>
        attribute of the <a href=
        "#element-output"><code>xsl:output</code></a> element,
        which has an entirely different purpose: it is used to
        define the version of the output method to be used for
        serialization.</p>

        <p>Within a section of a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> where forwards-compatible
        behavior is enabled:</p>

        <ul>
          <li>
            <p>if an element in the XSLT namespace appears as a
            child of the <a href=
            "#element-stylesheet"><code>xsl:stylesheet</code></a>
            element, and XSLT 2.0 does not allow such elements to
            occur as children of the <a href=
            "#element-stylesheet"><code>xsl:stylesheet</code></a>
            element, then the element and its content <span class=
            "verb">must</span> be ignored.</p>
          </li>

          <li>
            <p>if an element has an attribute that XSLT 2.0 does
            not allow the element to have, then the attribute
            <span class="verb">must</span> be ignored.</p>
          </li>

          <li>
            <p>if an element in the XSLT namespace appears as part
            of a <a title="sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a>,
            and XSLT 2.0 does not allow such elements to appear as
            part of a sequence constructor, then:</p>

            <ol class="enumar">
              <li>
                <p>If the element has one or more <a href=
                "#element-fallback"><code>xsl:fallback</code></a>
                children, then no error is reported either
                statically or dynamically, and the result of
                evaluating the instruction is the concatenation of
                the sequences formed by evaluating the sequence
                constructors within its <a href=
                "#element-fallback"><code>xsl:fallback</code></a>
                children, in document order. Siblings of the
                <a href=
                "#element-fallback"><code>xsl:fallback</code></a>
                elements are ignored, even if they are valid XSLT
                2.0 instructions.</p>
              </li>

              <li>
                <p>If the element has no <a href=
                "#element-fallback"><code>xsl:fallback</code></a>
                children, then a static error is reported in the
                same way as if forwards-compatible behavior were
                not enabled.</p>
              </li>
            </ol>
          </li>
        </ul>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e4106" id="d5e4106"></a>Example: Forwards
            Compatible Behavior
          </div>

          <p><span>For example, an XSLT 2.0 <a title="processor"
          href="#dt-processor">processor</a> will</span> process
          the following stylesheet without error, although the
          stylesheet includes elements from the <a title=
          "XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a> that are not defined in this
          specification:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
</pre>
          </div>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>If a stylesheet depends crucially on a <a title=
          "declaration" href="#dt-declaration">declaration</a>
          introduced by a version of XSLT after 2.0, then the
          stylesheet can use an <a href=
          "#element-message"><code>xsl:message</code></a> element
          with <code>terminate="yes"</code> (see <a href=
          "#message"><i>17 Messages</i></a>) to ensure that
          implementations that conform to an earlier version of
          XSLT will not silently ignore the <a title="declaration"
          href="#dt-declaration">declaration</a>.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e4139" id="d5e4139"></a>Example: Testing the
            XSLT Version
          </div>

          <p>For example,</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="combining-modules" id=
        "combining-modules"></a>3.10 Combining Stylesheet
        Modules</h3>

        <p>XSLT provides two mechanisms to construct a <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> from
        multiple <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet modules</a>:</p>

        <ul>
          <li>
            <p>an inclusion mechanism that allows stylesheet
            modules to be combined without changing the semantics
            of the modules being combined, and</p>
          </li>

          <li>
            <p>an import mechanism that allows stylesheet modules
            to override each other.</p>
          </li>
        </ul>

        <div class="div3">
          <h4><a name="locating-modules" id=
          "locating-modules"></a>3.10.1 Locating Stylesheet
          Modules</h4>

          <p>The include and import mechanisms use two
          declarations, <a href=
          "#element-include"><code>xsl:include</code></a> and
          <a href="#element-import"><code>xsl:import</code></a>,
          which are defined in the sections that follow.</p>

          <p>These declarations use an <code>href</code> attribute,
          whose value is a <a title="URI Reference" href=
          "#dt-uri-reference">URI reference</a>, to identify the
          <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a> to be
          included or imported. If the value of this attribute is a
          relative URI, it is resolved <span>as described in
          <a href="#uri-references"><i>5.8 URI
          References</i></a></span>.</p>

          <p>After resolving against the base URI, the way in which
          the URI reference is used to locate a
          <span>representation of a <a title="stylesheet module"
          href="#dt-stylesheet-module">stylesheet module</a>, and
          the way in which the stylesheet module is constructed
          from that representation, are</span> <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          In particular, it is implementation-defined which URI
          schemes are supported, whether fragment identifiers are
          supported, and what media types are supported.
          Conventionally, the URI is a reference to a resource
          containing the stylesheet module as a source XML
          document, or it may include a fragment identifier that
          selects an embedded stylesheet module within a source XML
          document; but the implementation is free to use other
          mechanisms to locate the stylesheet module identified by
          the URI reference.</p>

          <p>The referenced <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a> may be any
          of the four kinds of stylesheet module: that is, it may
          be <a title="standalone stylesheet module" href=
          "#dt-standalone-stylesheet-module">standalone</a> or
          <a title="embedded stylesheet module" href=
          "#dt-embedded-stylesheet-module">embedded</a>, and it may
          be <a title="standard stylesheet module" href=
          "#dt-standard-stylesheet-module">standard</a> or
          <a title="simplified stylesheet module" href=
          "#dt-simplified-stylesheet-module">simplified</a>. If it
          is a <a title="simplified stylesheet module" href=
          "#dt-simplified-stylesheet-module">simplified stylesheet
          module</a> then it is transformed into the equivalent
          <a title="standard stylesheet module" href=
          "#dt-standard-stylesheet-module">standard stylesheet
          module</a> by applying the transformation described in
          <a href="#simplified-stylesheet"><i>3.7 Simplified
          Stylesheet Modules</i></a>.</p>

          <p>Implementations <span class="verb">may</span> choose
          to accept URI references containing a fragment identifier
          defined by reference to the XPointer specification (see
          <a href="#xptr-framework">[XPointer Framework]</a>). Note
          that if the implementation does not support the use of
          fragment identifiers in the URI reference, then it will
          not be possible to include an <a title=
          "embedded stylesheet module" href=
          "#dt-embedded-stylesheet-module">embedded stylesheet
          module</a>.</p>

          <p><a name="err-XTSE0165" id="err-XTSE0165"><span class=
          "error">[ERR XTSE0165]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the processor is not able to retrieve the resource
          identified by the URI reference, or if the resource that
          is retrieved does not contain a stylesheet module
          conforming to this specification.</p>
        </div>

        <div class="div3">
          <h4><a name="include" id="include"></a>3.10.2 Stylesheet
          Inclusion</h4>

          <p class="element-syntax"><a name="element-include" id=
          "element-include"></a><code>&lt;!-- Category: declaration
          --&gt;<br />
          &lt;xsl:include<br />
          &#160;&#160;<b>href</b> =
          <var>uri-reference</var>&#160;/&gt;</code></p>

          <p>A stylesheet module may include another stylesheet
          module using an <a href=
          "#element-include"><code>xsl:include</code></a>
          declaration.</p>

          <p>The <a href=
          "#element-include"><code>xsl:include</code></a>
          declaration has a <span class="verb">required</span>
          <code>href</code> attribute whose value is a URI
          reference identifying the stylesheet module to be
          included. This attribute is used as described in <a href=
          "#locating-modules"><i>3.10.1 Locating Stylesheet
          Modules</i></a>.</p>

          <p><a name="err-XTSE0170" id="err-XTSE0170"><span class=
          "error">[ERR XTSE0170]</span></a> An <a href=
          "#element-include"><code>xsl:include</code></a> element
          <span class="verb">must</span> be a <a title="top-level"
          href="#dt-top-level">top-level</a> element.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-stylesheet-level" id="dt-stylesheet-level" title=
          "stylesheet level"></a>A <b>stylesheet level</b> is a
          collection of <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a> connected
          using <a href=
          "#element-include"><code>xsl:include</code></a>
          declarations: specifically, two stylesheet modules
          <var>A</var> and <var>B</var> are part of the same
          stylesheet level if one of them includes the other by
          means of an <a href=
          "#element-include"><code>xsl:include</code></a>
          declaration, or if there is a third stylesheet module
          <var>C</var> that is in the same stylesheet level as both
          <var>A</var> and <var>B</var>.<span class=
          "definition">]</span></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-declaration-order" id="dt-declaration-order" title=
          "declaration order"></a>The <a title="declaration" href=
          "#dt-declaration">declarations</a> within a <a title=
          "stylesheet level" href="#dt-stylesheet-level">stylesheet
          level</a> have a total ordering known as <b>declaration
          order</b>. The order of declarations within a stylesheet
          level is the same as the document order that would result
          if each stylesheet module were inserted textually in
          place of the <a href=
          "#element-include"><code>xsl:include</code></a> element
          that references it.<span class="definition">]</span> In
          other respects, however, the effect of <a href=
          "#element-include"><code>xsl:include</code></a> is not
          equivalent to the effect that would be obtained by
          textual inclusion.</p>

          <p><a name="err-XTSE0180" id="err-XTSE0180"><span class=
          "error">[ERR XTSE0180]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a stylesheet module directly or indirectly includes
          itself.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It is not intrinsically an error for a <a title=
            "stylesheet" href="#dt-stylesheet">stylesheet</a> to
            include the same module more than once. However, doing
            so can cause errors because of duplicate definitions.
            Such multiple inclusions are less obvious when they are
            indirect. For example, if stylesheet <var>B</var>
            includes stylesheet <var>A</var>, stylesheet
            <var>C</var> includes stylesheet <var>A</var>, and
            stylesheet <var>D</var> includes both stylesheet
            <var>B</var> and stylesheet <var>C</var>, then
            <var>A</var> will be included indirectly by
            <var>D</var> twice. If all of <var>B</var>,
            <var>C</var> and <var>D</var> are used as independent
            stylesheets, then the error can be avoided by
            separating everything in <var>B</var> other than the
            inclusion of <var>A</var> into a separate stylesheet
            <var>B'</var> and changing <var>B</var> to contain just
            inclusions of <var>B'</var> and <var>A</var>, similarly
            for <var>C</var>, and then changing <var>D</var> to
            include <var>A</var>, <var>B'</var>, <var>C'</var>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="import" id="import"></a>3.10.3 Stylesheet
          Import</h4>

          <p class="element-syntax"><a name="element-import" id=
          "element-import"></a><code>&lt;!-- Category: declaration
          --&gt;<br />
          &lt;xsl:import<br />
          &#160;&#160;<b>href</b> =
          <var>uri-reference</var>&#160;/&gt;</code></p>

          <p>A stylesheet module may import another <a title=
          "stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a> using an
          <a href="#element-import"><code>xsl:import</code></a>
          <a title="declaration" href=
          "#dt-declaration">declaration</a>. Importing a stylesheet
          <span>module</span> is the same as including it (see
          <a href="#include"><i>3.10.2 Stylesheet
          Inclusion</i></a>) except that <a title="template rule"
          href="#dt-template-rule">template rules</a> and other
          <a title="declaration" href=
          "#dt-declaration">declarations</a> in the importing
          <span>module</span> take precedence over template rules
          and declarations in the imported <span>module</span>;
          this is described in more detail below.</p>

          <p>The <a href=
          "#element-import"><code>xsl:import</code></a> declaration
          has a <span class="verb">required</span>
          <code>href</code> attribute whose value is a URI
          reference identifying the stylesheet module to be
          included. This attribute is used as described in <a href=
          "#locating-modules"><i>3.10.1 Locating Stylesheet
          Modules</i></a>.</p>

          <p><a name="err-XTSE0190" id="err-XTSE0190"><span class=
          "error">[ERR XTSE0190]</span></a> An <a href=
          "#element-import"><code>xsl:import</code></a> element
          <span class="verb">must</span> be a <a title="top-level"
          href="#dt-top-level">top-level</a> element.</p>

          <p><a name="err-XTSE0200" id="err-XTSE0200"><span class=
          "error">[ERR XTSE0200]</span></a> The <a href=
          "#element-import"><code>xsl:import</code></a> element
          children <span class="verb">must</span> precede all other
          element children of an <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element, including any <a href=
          "#element-include"><code>xsl:include</code></a> element
          children and any <a title="user-defined data element"
          href="#dt-data-element">user-defined data
          elements</a>.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e4538" id="d5e4538"></a>Example: Using
              <code>xsl:import</code>
            </div>

            <p>For example,</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:stylesheet version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;
</pre>
            </div>
          </div>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-import-tree" id="dt-import-tree" title=
          "import tree"></a>The <a title="stylesheet level" href=
          "#dt-stylesheet-level">stylesheet levels</a> making up a
          <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> are treated as forming an
          <b>import tree</b>. In the import tree, each stylesheet
          level has one child for each <a href=
          "#element-import"><code>xsl:import</code></a> declaration
          that it contains.<span class="definition">]</span> The
          ordering of the children is the <a title=
          "declaration order" href=
          "#dt-declaration-order">declaration order</a> of the
          <a href="#element-import"><code>xsl:import</code></a>
          declarations within their stylesheet level.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-import-precedence" id="dt-import-precedence" title=
          "import precedence"></a>A <a title="declaration" href=
          "#dt-declaration">declaration</a> <var>D</var> in the
          stylesheet is defined to have lower <b>import
          precedence</b> than another declaration <var>E</var> if
          the stylesheet level containing <var>D</var> would be
          visited before the stylesheet level containing
          <var>E</var> in a post-order traversal of the import tree
          (that is, a traversal of the import tree in which a
          stylesheet level is visited after its children). Two
          declarations within the same stylesheet level have the
          same import precedence.<span class=
          "definition">]</span></p>

          <p>For example, suppose</p>

          <ul>
            <li>
              <p>stylesheet module <var>A</var> imports stylesheet
              modules <var>B</var> and <var>C</var> in that
              order;</p>
            </li>

            <li>
              <p>stylesheet module <var>B</var> imports stylesheet
              module <var>D</var>;</p>
            </li>

            <li>
              <p>stylesheet module <var>C</var> imports stylesheet
              module <var>E</var>.</p>
            </li>
          </ul>

          <p>Then the import tree has the following structure:</p>

          <div class="exampleInner">
            <pre>
         A
         |
     +---+---+
     |       |
     B       C
     |       |
     D       E
</pre>
          </div>

          <p>The order of import precedence (lowest first) is
          <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>,
          <var>A</var>.</p>

          <p>In general, a <a title="declaration" href=
          "#dt-declaration">declaration</a> with higher import
          precedence takes precedence over a declaration with lower
          import precedence. This is defined in detail for each
          kind of declaration.</p>

          <p><a name="err-XTSE0210" id="err-XTSE0210"><span class=
          "error">[ERR XTSE0210]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a stylesheet module directly or indirectly imports
          itself.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The case where a stylesheet module with a particular
            URI is imported several times is not treated specially.
            The effect is exactly the same as if several stylesheet
            modules with different URIs but identical content were
            imported. This might or might not cause an error,
            depending on the content of the stylesheet module.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="embedded" id="embedded"></a>3.11 Embedded
        Stylesheet Modules</h3>

        <p>An <a title="embedded stylesheet module" href=
        "#dt-embedded-stylesheet-module">embedded stylesheet
        module</a> is a <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a> whose
        containing element is not the outermost element of the
        containing XML document. Both <a title=
        "standard stylesheet module" href=
        "#dt-standard-stylesheet-module">standard stylesheet
        modules</a> and <a title="simplified stylesheet module"
        href="#dt-simplified-stylesheet-module">simplified
        stylesheet modules</a> may be embedded in this way.</p>

        <p>Two situations where embedded stylesheets may be useful
        are:</p>

        <ul>
          <li>
            <p>The stylesheet may be embedded in the source
            document to be transformed.</p>
          </li>

          <li>
            <p>The stylesheet may be embedded in an XML document
            that describes a sequence of processing of which the
            XSLT transformation forms just one part.</p>
          </li>
        </ul>

        <p>The <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element <span class="verb">may</span> have an
        <code>id</code> attribute to facilitate reference to the
        stylesheet module within the containing document.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>In order for such an attribute value to be used as a
          fragment identifier in a URI, the <span>XDM attribute
          node</span> must generally have the <code>is-id</code>
          property: see <a href=
          "http://www.w3.org/TR/xpath-datamodel/#dm-is-id">Section
          5.5 is-id Accessor</a><sup><small>DM</small></sup>. This
          property will typically be set if the attribute is
          defined in a DTD as being of type <code>ID</code>, or if
          is defined in a schema as being of type
          <code>xs:ID</code>. It is also necessary that the media
          type of the containing document should support the use of
          ID values as fragment identifiers. Such support is
          widespread in existing products, and is expected to be
          endorsed in respect of the media type
          <code>application/xml</code> by a future revision of
          <a href="#RFC3023">[RFC3023]</a>.</p>

          <p>An alternative, if the implementation supports it, is
          to use an <code>xml:id</code> attribute. XSLT allows this
          attribute (like other namespaced attributes) to appear on
          any <a title="XSLT element" href="#dt-xslt-element">XSLT
          element</a>.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e4734" id="d5e4734"></a>Example: The
            <code>xml-stylesheet</code> Processing Instruction
          </div>

          <p>The following example shows how the
          <code>xml-stylesheet</code> processing instruction (see
          <a href="#xml-stylesheet">[XML Stylesheet]</a>) can be
          used to allow a source document to contain its own
          stylesheet. The URI reference uses a relative URI with a
          fragment identifier to locate the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element:</p>

          <div class="exampleInner">
            <pre>
&lt;?xml-stylesheet type="application/xslt+xml" href="#style1"?&gt;
&lt;!DOCTYPE doc SYSTEM "doc.dtd"&gt;
&lt;doc&gt;
&lt;head&gt;
&lt;xsl:stylesheet id="style1"
                version="2.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
&lt;xsl:import href="doc.xsl"/&gt;
&lt;xsl:template match="id('foo')"&gt;
  &lt;fo:block font-weight="bold"&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="xsl:stylesheet"&gt;
  &lt;!-- ignore --&gt;
&lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;para id="foo"&gt;
...
&lt;/para&gt;
&lt;/body&gt;
&lt;/doc&gt;
</pre>
          </div>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>A stylesheet module that is embedded in the document
          to which it is to be applied typically needs to contain a
          <a title="template rule" href=
          "#dt-template-rule">template rule</a> that specifies that
          <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          elements are to be ignored.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The above example uses the pseudo-attribute
          <code>type="application/xslt+xml"</code> in the
          <code>xml-stylesheet</code> processing instruction to
          denote an XSLT stylesheet. This usage is subject to
          <span>confirmation</span>: see <a href=
          "#xslt-media-type"><i>3.4 XSLT Media Type</i></a>. In the
          absence of a registered media type for XSLT stylesheets,
          some vendors' products have adopted different
          conventions, notably <code>type="text/xsl"</code>.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Support for the <code>xml-stylesheet</code> processing
          instruction is not required for conformance with this
          Recommendation. <span>Implementations are not constrained
          in the mechanisms they use to identify a stylesheet when
          a transformation is initiated: see <a href=
          "#initiating"><i>2.3 Initiating a
          Transformation</i></a>.</span></p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="conditional-inclusion" id=
        "conditional-inclusion"></a>3.12 Conditional Element
        Inclusion</h3>

        <p>Any element in the XSLT namespace may have a
        <code>use-when</code> attribute whose value is an XPath
        expression that can be evaluated statically. If the
        attribute is present and the <a href=
        "http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean
        value</a><sup><small>XP</small></sup> of the expression is
        false, then the element, together with all the nodes having
        that element as an ancestor, is effectively excluded from
        the <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a>. When a node
        is effectively excluded from a stylesheet module the
        stylesheet module has the same effect as if the node were
        not there. Among other things this means that no static or
        dynamic errors will be reported in respect of the element
        and its contents, other than errors in the
        <code>use-when</code> attribute itself.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This does not apply to XML parsing or validation
          errors, which will be reported in the usual way. <span>It
          also does not apply to attributes that are necessarily
          processed before <code>[xsl:]use-when</code>, examples
          being <code>xml:space</code> and
          <code>[xsl:]xpath-default-namespace</code></span>.</p>
        </div>

        <p>A <a title="literal result element" href=
        "#dt-literal-result-element">literal result element</a>,
        <span>or any other element within a <a title=
        "stylesheet module" href="#dt-stylesheet-module">stylesheet
        module</a> that is not in the XSLT namespace,</span> may
        similarly carry an <code>xsl:use-when</code> attribute.</p>

        <p>If the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a> or
        <a href="#element-transform"><code>xsl:transform</code></a>
        element itself is effectively excluded, the effect is to
        exclude all the children of the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a> or
        <a href="#element-transform"><code>xsl:transform</code></a>
        element, but not the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a> or
        <a href="#element-transform"><code>xsl:transform</code></a>
        element or its attributes.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This allows all the declarations that depend on the
          same condition to be included in one stylesheet module,
          and for their inclusion or exclusion to be controlled by
          a single <code>use-when</code> attribute at the level of
          the module.</p>
        </div>

        <p>Conditional element exclusion happens after stripping of
        whitespace text nodes from the stylesheet, as described in
        <a href="#stylesheet-stripping"><i>4.2 Stripping Whitespace
        from the Stylesheet</i></a>.</p>

        <p>There are no syntactic constraints on the XPath
        expression that can be used as the value of the
        <code>use-when</code> attribute. However, there are severe
        constraints on the information provided in its evaluation
        context. These constraints are designed to ensure that the
        expression can be evaluated at the earliest possible stage
        of stylesheet processing, without any dependency on
        information contained in the stylesheet itself or in any
        source document.</p>

        <p>Specifically, the components of the static and dynamic
        context are defined by the following two tables:</p>

        <table border="1" cellpadding="5" width="100%">
          <caption>
            Static Context Components for <code>use-when</code>
            Expressions
          </caption>
          <col align="left" width="30%" span="1" />
          <col align="left" span="1" />

          <thead>
            <tr>
              <th>Component</th>

              <th>Value</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td valign="top">XPath 1.0 compatibility mode</td>

              <td>false</td>
            </tr>

            <tr>
              <td valign="top">In scope namespaces</td>

              <td>determined by the in-scope namespaces for the
              containing element in the stylesheet</td>
            </tr>

            <tr>
              <td valign="top">Default element/type namespace</td>

              <td>determined by the
              <code>xpath-default-namespace</code> attribute if
              present (see <a href="#unprefixed-qnames"><i>5.2
              Unprefixed QNames in Expressions and
              Patterns</i></a>); otherwise the null namespace</td>
            </tr>

            <tr>
              <td valign="top">Default function namespace</td>

              <td>The <a title="standard function namespace" href=
              "#dt-standard-function-namespace">standard function
              namespace</a></td>
            </tr>

            <tr>
              <td valign="top">In scope type definitions</td>

              <td>The type definitions that would be available in
              the absence of any <a href=
              "#element-import-schema"><code>xsl:import-schema</code></a>
              declaration</td>
            </tr>

            <tr>
              <td valign="top">In scope element declarations</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">In scope attribute declarations</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">In scope variables</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">In scope functions</td>

              <td>The <a title="core function" href=
              "#dt-core-function">core functions</a> defined in
              <a href="#xpath-functions">[Functions and
              Operators]</a>, together with the functions <a href=
              "#function-element-available"><code>element-available</code></a>,
              <a href=
              "#function-function-available"><code>function-available</code></a>,
              <span><a href=
              "#function-type-available"><code>type-available</code></a>,</span>
              and <a href=
              "#function-system-property"><code>system-property</code></a>
              defined in this specification, plus <span>the set of
              extension functions that are present in the static
              context of every XPath expression (other than a
              use-when expression) within the content of the
              element that is the parent of the
              <code>use-when</code> attribute</span>. Note that
              <a title="stylesheet function" href=
              "#dt-stylesheet-function">stylesheet functions</a>
              are <em>not</em> included in the context, which means
              that the function <a href=
              "#function-function-available"><code>function-available</code></a>
              will return <code>false</code> in respect of such
              functions. <span>The effect of this rule is to ensure
              that <a href=
              "#function-function-available"><code>function-available</code></a>
              returns true in respect of functions that can be
              called within the scope of the <code>use-when</code>
              attribute. It also has the effect that these
              extensions functions will be recognized within the
              <code>use-when</code> attribute itself; however, the
              fact that a function is available in this sense gives
              no guarantee that a call on the function will
              succeed.</span></td>
            </tr>

            <tr>
              <td valign="top">In scope collations</td>

              <td>Implementation-defined</td>
            </tr>

            <tr>
              <td valign="top">Default collation</td>

              <td>The Unicode Codepoint Collation</td>
            </tr>

            <tr>
              <td valign="top">Base URI</td>

              <td>The base URI of the containing element in the
              stylesheet</td>
            </tr>

            <tr>
              <td valign="top">Statically known documents</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">Statically known collections</td>

              <td>None</td>
            </tr>
          </tbody>
        </table>

        <p>&#160;</p>

        <table border="1" cellpadding="5" width="100%">
          <caption>
            Dynamic Context Components for <code>use-when</code>
            Expressions
          </caption>
          <col align="left" width="30%" span="1" />
          <col align="left" span="1" />

          <thead>
            <tr>
              <th>Component</th>

              <th>Value</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td valign="top">Context item, position, and
              size</td>

              <td>Undefined</td>
            </tr>

            <tr>
              <td valign="top">Dynamic variables</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">Current date and time</td>

              <td>Implementation-defined</td>
            </tr>

            <tr>
              <td valign="top">Implicit timezone</td>

              <td>Implementation-defined</td>
            </tr>

            <tr>
              <td valign="top">Available documents</td>

              <td>None</td>
            </tr>

            <tr>
              <td valign="top">Available collections</td>

              <td>None</td>
            </tr>
          </tbody>
        </table>

        <p>Within a <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a>, all
        expressions contained in <code>[xsl:]use-when</code>
        attributes are evaluated in a single <a href=
        "http://www.w3.org/TR/xpath-functions/#execution-scope">execution
        scope</a><sup><small>FO</small></sup>. This need not be the
        same execution scope as that used for
        <code>[xsl]:use-when</code> expressions in other stylesheet
        modules, or as that used when evaluating XPath expressions
        appearing elsewhere in the stylesheet module. This means
        that a function such as <a href=
        "http://www.w3.org/TR/xpath-functions/#func-current-date"><code>
        current-date</code></a><sup><small>FO</small></sup> will
        return the same result when called in different
        <code>[xsl:]use-when</code> expressions within the same
        stylesheet module, but will not necessarily return the same
        result as the same call in an <code>[xsl:]use-when</code>
        expression within a different stylesheet module, or as a
        call on the same function executed during the
        transformation proper.</p>

        <p>The use of <code>[xsl:]use-when</code> is illustrated in
        the following examples.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e5094" id="d5e5094"></a>Example: Using
            Conditional Exclusion to Achieve Portability
          </div>

          <p>This example demonstrates the use of the
          <code>use-when</code> attribute to achieve portability of
          a stylesheet across schema-aware and non-schema-aware
          processors.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The effect of these declarations is that a
          non-schema-aware processor ignores the <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          declaration and the first template rule, and therefore
          generates no errors in respect of the schema-related
          constructs in these declarations.</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e5109" id="d5e5109"></a>Example: Including
            Variant Stylesheet Modules
          </div>

          <p>This example includes different stylesheet modules
          depending on which XSLT processor is in use.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="built-in-types" id="built-in-types"></a>3.13
        Built-in Types</h3>

        <p>Every XSLT 2.0 processor includes the following named
        type definitions in the <a title=
        "in-scope schema component" href=
        "#dt-in-scope-schema-component">in-scope schema
        components</a>:</p>

        <ul>
          <li>
            <p>All the primitive atomic types defined in <a href=
            "#xmlschema-2">[XML Schema Part 2]</a>, with the
            exception of <code>xs:NOTATION</code>. That is:
            <code>xs:string</code>, <code>xs:boolean</code>,
            <code>xs:decimal</code>, <code>xs:double</code>,
            <code>xs:float</code>, <code>xs:date</code>,
            <code>xs:time</code>, <code>xs:dateTime</code>,
            <code>xs:duration</code>, <code>xs:QName</code>,
            <code>xs:anyURI</code>, <code>xs:gDay</code>,
            <code>xs:gMonthDay</code>, <code>xs:gMonth</code>,
            <code>xs:gYearMonth</code>, <code>xs:gYear</code>,
            <code>xs:base64Binary</code>, and
            <code>xs:hexBinary</code>.</p>
          </li>

          <li>
            <p>The derived atomic type <code>xs:integer</code>
            defined in <a href="#xmlschema-2">[XML Schema Part
            2]</a>.</p>
          </li>

          <li>
            <p>The types <code>xs:anyType</code> and
            <code>xs:anySimpleType</code>.</p>
          </li>

          <li>
            <p>The following types defined in <a href=
            "#xpath20">[XPath 2.0]</a>:
            <span><code>xs:yearMonthDuration</code></span>,
            <span><code>xs:dayTimeDuration</code></span>,
            <span><code>xs:anyAtomicType</code></span>,
            <span><code>xs:untyped</code></span>, and
            <span><code>xs:untypedAtomic</code></span>.</p>
          </li>
        </ul>

        <p>A <a title="schema-aware XSLT processor" href=
        "#dt-schema-aware-xslt-processor">schema-aware XSLT
        processor</a> additionally supports:</p>

        <ul>
          <li>
            <p>All other built-in types defined in <a href=
            "#xmlschema-2">[XML Schema Part 2]</a></p>
          </li>

          <li>
            <p>User-defined types, and element and attribute
            declarations, that are imported using an <a href=
            "#element-import-schema"><code>xsl:import-schema</code></a>
            declaration as described in <a href=
            "#import-schema"><i>3.14 Importing Schema
            Components</i></a>. These may include both simple and
            complex types.</p>
          </li>
        </ul>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The names that are imported from the XML Schema
          namespace do not include all the names of top-level types
          defined in either the Schema for Schemas or the Schema
          for Datatypes. The Schema for Datatypes, as well as
          defining built-in types such as <code>xs:integer</code>
          and <code>xs:double</code>, also defines types that are
          intended for use only within the Schema for DataTypes,
          such as <code>xs:derivationControl</code>. A <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> that is
          designed to process XML Schema documents as its input or
          output may import the Schema for Schemas.</p>
        </div>

        <p>An implementation may define mechanisms that allow
        additional <a title="schema component" href=
        "#dt-schema-component">schema components</a> to be added to
        the <a title="in-scope schema component" href=
        "#dt-in-scope-schema-component">in-scope schema
        components</a> for the stylesheet. For example, the
        mechanisms used to define <a title="extension function"
        href="#dt-extension-function">extension functions</a> (see
        <a href="#extension-functions"><i>18.1 Extension
        Functions</i></a>) may also be used to import the types
        used in the interface to such functions.</p>

        <p>These <a title="schema component" href=
        "#dt-schema-component">schema components</a> are the only
        ones that may be referenced in XPath expressions within the
        stylesheet, or in the <code>[xsl:]type</code> and
        <code>as</code> attributes of those elements that permit
        these attributes.</p>

        <p>For a Basic XSLT Processor, schema built-in types that
        are not included in the static context (for example,
        <code>xs:NCName</code>) are "unknown types" in the sense of
        <a href=
        "http://www.w3.org/TR/xpath20/#id-sequencetype-matching">Section
        2.5.4 SequenceType
        Matching</a><sup><small>XP</small></sup>. In the language
        of that section, a Basic XSLT Processor <span class=
        "verb">must</span> be able to determine whether these
        unknown types are derived from known schema types such as
        <code>xs:string</code>. The purpose of this rule is to
        ensure that system functions such as <a href=
        "http://www.w3.org/TR/xpath-functions/#func-local-name-from-QName">
        <code>local-name-from-QName</code></a><sup><small>FO</small></sup>,
        which is defined to return an <code>xs:NCName</code>,
        behave correctly. A stylesheet that uses a Basic XSLT
        Processor will not be able to test whether the returned
        value is an <code>xs:NCName</code>, but it will be able to
        use it as if it were an <code>xs:string</code>.</p>
      </div>

      <div class="div2">
        <h3><a name="import-schema" id="import-schema"></a>3.14
        Importing Schema Components</h3>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The facilities described in this section are not
          available with a <a title="basic XSLT processor" href=
          "#dt-basic-xslt-processor">basic XSLT processor</a>. They
          require a <a title="schema-aware XSLT processor" href=
          "#dt-schema-aware-xslt-processor">schema-aware XSLT
          processor</a>, as described in <a href=
          "#conformance"><i>21 Conformance</i></a>.</p>
        </div>

        <p class="element-syntax"><a name="element-import-schema"
        id="element-import-schema"></a><code>&lt;!-- Category:
        declaration --&gt;<br />
        &lt;xsl:import-schema<br />
        &#160;&#160;namespace? = <var>uri-reference</var><br />
        &#160;&#160;schema-location? =
        <var>uri-reference</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
        &lt;/xsl:import-schema&gt;</code></p>

        <p>The <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration is used to identify <a title="schema component"
        href="#dt-schema-component">schema components</a> (that is,
        top-level type definitions and top-level element and
        attribute declarations) that need to be available
        statically, that is, before any source document is
        available. Names of such components used statically within
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> must refer to an <a title=
        "in-scope schema component" href=
        "#dt-in-scope-schema-component">in-scope schema
        component</a>, which means they must either be built-in
        types as defined in <a href="#built-in-types"><i>3.13
        Built-in Types</i></a>, or they must be imported using an
        <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration.</p>

        <p>The <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration identifies a namespace containing the names of
        the components to be imported (or indicates that components
        whose names are in no namespace are to be imported). The
        effect is that the names of top-level element and attribute
        declarations and type definitions from this namespace (or
        non-namespace) become available for use within XPath
        expressions in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, and within other
        stylesheet constructs such as the <code>type</code> and
        <code>as</code> attributes of various <a title=
        "XSLT element" href="#dt-xslt-element">XSLT
        elements</a>.</p>

        <p>The same schema components are available in all
        stylesheet modules; importing components in one stylesheet
        module makes them available throughout the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a>.</p>

        <p>The <code>namespace</code> and
        <code>schema-location</code> attributes are both
        optional.</p>

        <p>If the <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        element contains an <code>xs:schema</code> element, then
        the <code>schema-location</code> attribute must be absent,
        and the <code>namespace</code> attribute must either have
        the same value as the <code>targetNamespace</code>
        attribute of the <code>xs:schema</code> element (if
        present), or must be absent, in which case its effective
        value is that of the <code>targetNamespace</code> attribute
        of the <code>xs:schema</code> element if present or the
        zero-length string otherwise.</p>

        <p><a name="err-XTSE0215" id="err-XTSE0215"><span class=
        "error">[ERR XTSE0215]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        element that contains an <code>xs:schema</code> element has
        a <code>schema-location</code> attribute, or if it has a
        <code>namespace</code> attribute that conflicts with the
        target namespace of the contained schema.</p>

        <p>If two <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declarations specify the same namespace, or if both specify
        no namespace, then only the one with highest <a title=
        "import precedence" href="#dt-import-precedence">import
        precedence</a> is used. If this leaves more than one, then
        all the declarations at the highest import precedence are
        used (which may cause conflicts, as described below).</p>

        <p>After discarding any <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declarations under the above rule, the effect of the
        remaining <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declarations is defined in terms of a hypothetical document
        called the synthetic schema document, which is constructed
        as follows. The synthetic schema document defines an
        arbitrary target namespace that is different from any
        namespace actually used by the application, and it contains
        <code>xs:import</code> elements corresponding one-for-one
        with the <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declarations in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, with the following
        correspondence:</p>

        <ul>
          <li>
            <p>The <code>namespace</code> attribute of the
            <code>xs:import</code> element is copied from the
            <code>namespace</code> attribute of the <a href=
            "#element-import-schema"><code>xsl:import-schema</code></a>
            declaration if it is <span>explicitly present, or is
            implied by the <code>targetNamespace</code> attribute
            of a contained <code>xs:schema</code> element,</span>
            and is absent if it is absent.</p>
          </li>

          <li>
            <p>The <code>schemaLocation</code> attribute of the
            <code>xs:import</code> element is copied from the
            <code>schema-location</code> attribute of the <a href=
            "#element-import-schema"><code>xsl:import-schema</code></a>
            declaration if present, and is absent if it is absent.
            <span>If there is a contained <code>xs:schema</code>
            element, the effective value of the
            <code>schemaLocation</code> attribute is a URI
            referencing a document containing a copy of the
            <code>xs:schema</code> element.</span></p>
          </li>

          <li>
            <p>The base URI of the <code>xs:import</code> element
            is the same as the base URI of the <a href=
            "#element-import-schema"><code>xsl:import-schema</code></a>
            declaration.</p>
          </li>
        </ul>

        <p>The schema components included in the <a title=
        "in-scope schema component" href=
        "#dt-in-scope-schema-component">in-scope schema
        components</a> (that is, the components whose names are
        available for use within the stylesheet) are the top-level
        element and attribute declarations and type definitions
        that are available for reference within the synthetic
        schema document. See <a href="#xmlschema-1">[XML Schema
        Part 1]</a> (section 4.2.3, <em>References to schema
        components across namespaces</em>).</p>

        <p><a name="err-XTSE0220" id="err-XTSE0220"><span class=
        "error">[ERR XTSE0220]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the synthetic schema document does not satisfy the
        constraints described in <a href="#xmlschema-1">[XML Schema
        Part 1]</a> (section 5.1, <em>Errors in Schema Construction
        and Structure</em>). This includes, without loss of
        generality, conflicts such as multiple definitions of the
        same name.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The synthetic schema document does not need to be
          constructed by a real implementation. It is purely a
          mechanism for defining the semantics of <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          in terms of rules that already exist within the XML
          Schema specification. In particular, it implicitly
          defines the rules that determine whether the set of
          <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          declarations are mutually consistent.</p>

          <p>These rules do not cause names to be imported
          transitively. The fact that a name is available for
          reference within a schema document A does not of itself
          make the name available for reference in a stylesheet
          that imports the target namespace of schema document A.
          (See <a href="#xmlschema-1">[XML Schema Part 1]</a>
          section 3.15.3, Constraints on XML Representations of
          Schemas.) The stylesheet must import all the namespaces
          containing names that it actually references.</p>

          <p>The <code>namespace</code> attribute indicates that a
          schema for the given namespace is required by the
          <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>. This information may be
          enough on its own to enable an implementation to locate
          the required schema components. The
          <code>namespace</code> attribute may be omitted to
          indicate that a schema for names in no namespace is being
          imported. The zero-length string is not a valid namespace
          URI, and is therefore not a valid value for the
          <code>namespace</code> attribute.</p>

          <p>The <code>schema-location</code> attribute is a
          <a title="URI Reference" href="#dt-uri-reference">URI
          Reference</a> that gives a hint indicating where a schema
          document or other resource containing the required
          definitions may be found. It is likely that a <a title=
          "schema-aware XSLT processor" href=
          "#dt-schema-aware-xslt-processor">schema-aware XSLT
          processor</a> will be able to process a schema document
          found at this location.</p>

          <p>The XML Schema specification gives implementations
          flexibility in how to handle multiple imports for the
          same namespace. Multiple imports do not cause errors if
          the definitions do not conflict.</p>

          <p>A consequence of these rules is that it is not
          intrinsically an error if no schema document can be
          located for a namespace identified in an <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          declaration. This will cause an error only if it results
          in the stylesheet containing references to names that
          have not been imported.</p>

          <p>An inline schema document (using an
          <code>xs:schema</code> element as a child of the
          <code>xsl:import-schema</code> element) has the same
          status as an external schema document, in the sense that
          it acts as a hint for a source of schema components in
          the relevant namespace. To ensure that the inline schema
          document is always used, it is advisable to use a target
          namespace that is unique to this schema document.</p>
        </div>

        <p>The use of a namespace in an <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration does not by itself associate any namespace
        prefix with the namespace. If names from the namespace are
        used within the stylesheet module then a namespace
        declaration must be included in the stylesheet module, in
        the usual way.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e5611" id="d5e5611"></a>Example: An Inline
            Schema Document
          </div>

          <p>The following example shows an inline schema document.
          This declares a simple type <code>local:yes-no</code>,
          which the stylesheet then uses in the declaration of a
          variable.</p>

          <p>The example assumes the namespace declaration
          <code>xmlns:local="http://localhost/ns/yes-no"</code></p>

          <div class="exampleInner">
            <pre>
&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://localhost/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
    &lt;xs:simpleType name="local:yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xs:variable name="condition" select="'yes'" as="local:yes-no"/&gt;
</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="data-model" id="data-model"></a>4 Data
      Model</h2>

      <p>The data model used by XSLT is the XPath 2.0 and XQuery
      1.0 data model <span>(XDM)</span>, as defined in <a href=
      "#xpath-datamodel">[Data Model]</a>. XSLT operates on source,
      result and stylesheet documents using the same data
      model.</p>

      <p>This section elaborates on some particular features of
      <span>XDM</span> as it is used by XSLT:</p>

      <p>The rules in <a href="#stylesheet-stripping"><i>4.2
      Stripping Whitespace from the Stylesheet</i></a> and <a href=
      "#strip"><i>4.4 Stripping Whitespace from a Source
      Tree</i></a> make use of the concept of a whitespace text
      node.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-whitespace-text-node" id="dt-whitespace-text-node" title=
      "whitespace text node"></a>A <b>whitespace text node</b> is a
      text node whose content consists entirely of whitespace
      characters (that is, #x09, #x0A, #x0D, or #x20).<span class=
      "definition">]</span></p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>Features of a source XML document that are not
        represented in the <span>XDM tree</span> will have no
        effect on the operation of an XSLT stylesheet. Examples of
        such features are entity references, CDATA sections,
        character references, whitespace within element tags, and
        the choice of single or double quotes around attribute
        values.</p>
      </div>

      <div class="div2">
        <h3><a name="xml-versions" id="xml-versions"></a>4.1 XML
        Versions</h3>

        <p>The <span>XDM</span> data model defined in <a href=
        "#xpath-datamodel">[Data Model]</a> is capable of
        representing either an XML 1.0 document (conforming to
        <a href="#REC-xml">[XML 1.0]</a> and <a href=
        "#REC-xml-names">[Namespaces in XML 1.0]</a>) or an XML 1.1
        document (conforming to <a href="#xml11">[XML 1.1]</a> and
        <a href="#xml-names11">[Namespaces in XML 1.1]</a>), and it
        makes no distinction between the two. In principle,
        therefore, XSLT 2.0 can be used with either of these XML
        versions.</p>

        <p>Construction of the <span>XDM tree</span> is outside the
        scope of this specification, so XSLT 2.0 places no formal
        requirements on an XSLT processor to accept input from
        either XML 1.0 documents or XML 1.1 documents or both. This
        specification does define a serialization capability (see
        <a href="#serialization"><i>20 Serialization</i></a>),
        though from a conformance point of view it is an optional
        feature. Although facilities are described for serializing
        the <span>XDM tree</span> as either XML 1.0 or XML 1.1 (and
        controlling the choice), there is again no formal
        requirement on an XSLT processor to support either or both
        of these XML versions as serialization targets.</p>

        <p>Because the <span>XDM tree</span> is the same whether
        the original document was XML 1.0 or XML 1.1, the semantics
        of XSLT processing do not depend on the version of XML used
        by the original document. There is no reason in principle
        why all the input and output documents used in a single
        transformation must conform to the same version of XML.</p>

        <p>Some of the syntactic constructs in XSLT 2.0 and XPath
        2.0, for example the productions <a href=
        "http://www.w3.org/TR/2000/REC-xml-20001006#NT-Char">Char</a><sup>
        <small>XML</small></sup> and <a href=
        "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
        <small>Names</small></sup>, are defined by reference to the
        XML and XML Namespaces specifications. There are slight
        variations between the XML 1.0 and XML 1.1 versions of
        these productions. <span>Implementations <span class=
        "verb">may</span> support either version; it is
        <span class="verb">recommended</span> that an XSLT 2.0
        processor that implements the 1.1 versions <span class=
        "verb">should</span> also provide a mode that supports the
        1.0 versions. It is thus <a title="implementation-defined"
        href=
        "#dt-implementation-defined">implementation-defined</a>
        whether the XSLT processor supports XML 1.0 with XML
        Namespaces 1.0, or XML 1.1 with XML Namespaces 1.1, or
        supports both versions at user option.</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The specification referenced as <a href=
          "#REC-xml-names">[Namespaces in XML 1.0]</a> was actually
          published without a version number.</p>
        </div>

        <p>At the time of writing there is no published version of
        <a href="#xmlschema-2">[XML Schema Part 2]</a> that
        references the XML 1.1 specifications. This means that data
        types such as <code>xs:NCName</code> and <code>xs:ID</code>
        are constrained by the XML 1.0 rules, and do not allow the
        full range of values permitted by XML 1.1. This situation
        will not be resolved until a new version of <a href=
        "#xmlschema-2">[XML Schema Part 2]</a> becomes available;
        in the meantime, it is <span class=
        "verb">recommended</span> that implementers wishing to
        support XML 1.1 should consult <a href=
        "#SCHEMA-AND-XML-1.1">[XML Schema 1.0 and XML 1.1]</a> for
        guidance. An XSLT 2.0 processor that supports XML 1.1
        <span class="verb">should</span> implement the rules in
        later versions of <a href="#xmlschema-2">[XML Schema Part
        2]</a> as they become available.</p>
      </div>

      <div class="div2">
        <h3><a name="stylesheet-stripping" id=
        "stylesheet-stripping"></a>4.2 Stripping Whitespace from
        the Stylesheet</h3>

        <p>The tree representing the stylesheet is preprocessed as
        follows:</p>

        <ol class="enumar">
          <li>
            <p>All comments and processing instructions are
            removed.</p>
          </li>

          <li>
            <p>Any text nodes that are now adjacent to each other
            are merged.</p>
          </li>

          <li>
            <p>Any <a title="whitespace text node" href=
            "#dt-whitespace-text-node">whitespace text node</a>
            that satisfies both the following conditions is removed
            from the tree:</p>

            <ul>
              <li>
                <p>The parent of the text node is not an <a href=
                "#element-text"><code>xsl:text</code></a>
                element</p>
              </li>

              <li>
                <p>The text node does not have an ancestor element
                that has an <code>xml:space</code> attribute with a
                value of <code>preserve</code>, unless there is a
                closer ancestor element having an
                <code>xml:space</code> attribute with a value of
                <code>default</code>.</p>
              </li>
            </ul>
          </li>

          <li>
            <p>Any <a title="whitespace text node" href=
            "#dt-whitespace-text-node">whitespace text node</a>
            whose parent is one of the following elements is
            removed from the tree, regardless of any
            <code>xml:space</code> attributes:</p>

            <blockquote>
              <p><a href=
              "#element-analyze-string"><code>xsl:analyze-string</code></a><br />

              <a href=
              "#element-apply-imports"><code>xsl:apply-imports</code></a><br />

              <a href=
              "#element-apply-templates"><code>xsl:apply-templates</code></a><br />

              <a href=
              "#element-attribute-set"><code>xsl:attribute-set</code></a><br />

              <a href=
              "#element-call-template"><code>xsl:call-template</code></a><br />

              <a href=
              "#element-character-map"><code>xsl:character-map</code></a><br />

              <a href=
              "#element-choose"><code>xsl:choose</code></a><br />
              <a href=
              "#element-next-match"><code>xsl:next-match</code></a><br />

              <a href=
              "#element-stylesheet"><code>xsl:stylesheet</code></a><br />

              <a href=
              "#element-transform"><code>xsl:transform</code></a></p>
            </blockquote>
          </li>

          <li>
            <p>Any <a title="whitespace text node" href=
            "#dt-whitespace-text-node">whitespace text node</a>
            whose following-sibling node is an <a href=
            "#element-param"><code>xsl:param</code></a> or <a href=
            "#element-sort"><code>xsl:sort</code></a> element is
            removed from the tree, regardless of any
            <code>xml:space</code> attributes.</p>
          </li>
        </ol>

        <p><a name="err-XTSE0260" id="err-XTSE0260"><span class=
        "error">[ERR XTSE0260]</span></a> Within an <a title=
        "XSLT element" href="#dt-xslt-element">XSLT element</a>
        that is <span class="verb">required</span> to be empty, any
        content other than comments or processing instructions,
        including any <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text node</a>
        preserved using the <code>xml:space="preserve"</code>
        attribute, is a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Using <code>xml:space="preserve"</code> in parts of
          the stylesheet that contain <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructors</a> will
          cause all text nodes in that part of the stylesheet,
          including those that contain whitespace only, to be
          copied to the result of the sequence constructor. When
          the result of the sequence constructor is used to form
          the content of an element, this can cause errors if such
          text nodes are followed by attribute nodes generated
          using <a href=
          "#element-attribute"><code>xsl:attribute</code></a>.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>If an <code>xml:space</code> attribute is specified on
          a <a title="literal result element" href=
          "#dt-literal-result-element">literal result element</a>,
          it will be copied to the result tree in the same way as
          any other attribute.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="stripping-annotations" id=
        "stripping-annotations"></a>4.3 Stripping Type Annotations
        from a Source Tree</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-annotation" id="dt-annotation" title=
        "type annotation"></a>The term <b>type annotation</b> is
        used in this specification to refer to the value returned
        by the <code>dm:type-name</code> accessor of a node: see
        <a href=
        "http://www.w3.org/TR/xpath-datamodel/#dm-type-name">Section
        5.14 type-name
        Accessor</a><sup><small>DM</small></sup>.<span class=
        "definition">]</span></p>

        <p>There is sometimes a requirement to write stylesheets
        that produce the same results whether or not the source
        documents have been validated against a schema. To achieve
        this, an option is provided to remove any <a title=
        "type annotation" href="#dt-annotation">type
        annotations</a> on element and attribute nodes in a
        <a title="source tree" href="#dt-source-tree">source
        tree</a>, replacing them with an annotation of
        <span><code>xs:untyped</code></span> in the case of element
        nodes, and <span><code>xs:untypedAtomic</code></span> in
        the case of attribute nodes.</p>

        <p>Such stripping of <a title="type annotation" href=
        "#dt-annotation">type annotations</a> can be requested by
        specifying <code>input-type-annotations="strip"</code> on
        the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element. This attribute has three permitted values:
        <code>strip</code>, <code>preserve</code>, and
        <code>unspecified</code>. The default value is
        <code>unspecified</code>. Stripping of type annotations
        takes place if at least one <a title="stylesheet module"
        href="#dt-stylesheet-module">stylesheet module</a> in the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        specifies <code>input-type-annotations="strip"</code>.</p>

        <p><a name="err-XTSE0265" id="err-XTSE0265"><span class=
        "error">[ERR XTSE0265]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        there is a <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a> in the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        that specifies <code>input-type-annotations="strip"</code>
        and another <a title="stylesheet module" href=
        "#dt-stylesheet-module">stylesheet module</a> that
        specifies
        <code>input-type-annotations="preserve"</code>.</p>

        <p>The <a title="source tree" href="#dt-source-tree">source
        trees</a> to which this applies are the same as those
        affected by <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> and
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>:
        see <a href="#strip"><i>4.4 Stripping Whitespace from a
        Source Tree</i></a>.</p>

        <p>When type annotations are stripped, the following
        changes are made to the source tree:</p>

        <ul>
          <li>
            <p>The type annotation of every element node is changed
            to <code>xs:untyped</code></p>
          </li>

          <li>
            <p>The type annotation of every attribute node is
            changed to <code>xs:untypedAtomic</code></p>
          </li>

          <li>
            <p>The typed value of every element and attribute node
            is set to be the same as its string value, as an
            instance of <code>xs:untypedAtomic</code>.</p>
          </li>

          <li>
            <p>The <code>is-nilled</code> property of every element
            node is set to <code>false</code>.</p>
          </li>
        </ul>

        <p>The values of the <code>is-id</code> and
        <code>is-idrefs</code> properties are not changed.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Stripping type annotations does not necessarily return
          the document to the state it would be in had validation
          not taken place. In particular, any defaulted elements
          and attributes that were added to the tree by the
          validation process will still be present <span>, and
          elements and attributes validated as IDs will still be
          accessible using the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
          <small>FO</small></sup> function</span>.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="strip" id="strip"></a>4.4 Stripping Whitespace
        from a Source Tree</h3>

        <p>A <a title="source tree" href="#dt-source-tree">source
        tree</a> supplied as input to the transformation process
        may contain <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text nodes</a> that
        are of no interest, and that do not need to be retained by
        the transformation. Conceptually, an XSLT <a title=
        "processor" href="#dt-processor">processor</a> makes a copy
        of the source tree from which unwanted <a title=
        "whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text nodes</a> have
        been removed. This process is referred to as whitespace
        stripping.</p>

        <p>For the purposes of this section, the term <b>source
        tree</b> means the document containing the <a title=
        "initial context node" href=
        "#dt-initial-context-node">initial context node</a>, and
        any document returned by the functions <a href=
        "#function-document"><code>document</code></a>, <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup>, or <a href=
        "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
        collection</code></a><sup><small>FO</small></sup>. It does
        not include documents passed as the values of <a title=
        "stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameters</a> or
        returned from <a title="extension function" href=
        "#dt-extension-function">extension functions</a>.</p>

        <p>The stripping process takes as input a set of element
        names whose child <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text nodes</a> are to
        be preserved. The way in which this set of element names is
        established using the <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> and
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        declarations is described later in this section.</p>

        <p>A <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text node</a> is
        preserved if either of the following apply:</p>

        <ul>
          <li>
            <p>The element name of the parent of the text node is
            in the set of whitespace-preserving element names.</p>
          </li>

          <li>
            <p>An ancestor element of the text node has an
            <code>xml:space</code> attribute with a value of
            <code>preserve</code>, and no closer ancestor element
            has <code>xml:space</code> with a value of
            <code>default</code>.</p>
          </li>
        </ul>

        <p>Otherwise, the <a title="whitespace text node" href=
        "#dt-whitespace-text-node">whitespace text node</a> is
        stripped.</p>

        <p>The <code>xml:space</code> attributes are not removed
        from the tree.</p>

        <p class="element-syntax"><a name="element-strip-space" id=
        "element-strip-space"></a><code>&lt;!-- Category:
        declaration --&gt;<br />
        &lt;xsl:strip-space<br />
        &#160;&#160;<b>elements</b> =
        <var>tokens</var>&#160;/&gt;</code></p>

        <p class="element-syntax"><a name="element-preserve-space"
        id="element-preserve-space"></a><code>&lt;!-- Category:
        declaration --&gt;<br />
        &lt;xsl:preserve-space<br />
        &#160;&#160;<b>elements</b> =
        <var>tokens</var>&#160;/&gt;</code></p>

        <p>The set of whitespace-preserving element names is
        specified by <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> and
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        <a title="declaration" href=
        "#dt-declaration">declarations</a>. Whether an element name
        is included in the set of whitespace-preserving names is
        determined by the best match among all the <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> or
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        declarations: it is included if and only if there is no
        match or the best match is an <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        element. The <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> and
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        elements each have an <code>elements</code> attribute whose
        value is a whitespace-separated list of <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTests</a><sup>
        <small>XP</small></sup>; an element name matches an
        <a href="#element-strip-space"><code>xsl:strip-space</code></a>
        or <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        element if it matches one of the <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTests</a><sup>
        <small>XP</small></sup>. An element matches a <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</a><sup>
        <small>XP</small></sup> if and only if the <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</a><sup>
        <small>XP</small></sup> would be true for the element as an
        XPath node test. When more than one <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> and
        <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>
        element matches, the best matching element is determined by
        the best matching <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-NameTest">NameTest</a><sup>
        <small>XP</small></sup>. This is determined in the same way
        as with <a title="template rule" href=
        "#dt-template-rule">template rules</a>:</p>

        <ul>
          <li>
            <p>First, any match with lower <a title=
            "import precedence" href="#dt-import-precedence">import
            precedence</a> than another match is ignored.</p>
          </li>

          <li>
            <p>Next, any match that has a lower <a title=
            "default priority" href="#dt-default-priority">default
            priority</a> than the <a title="default priority" href=
            "#dt-default-priority">default priority</a> of another
            match is ignored.</p>
          </li>
        </ul>

        <p><a name="err-XTRE0270" id="err-XTRE0270"><span class=
        "error">[ERR XTRE0270]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> if
        this leaves more than one match<span>, unless all the
        matched declarations are equivalent (that is, they are all
        <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a> or
        they are all <a href=
        "#element-preserve-space"><code>xsl:preserve-space</code></a>)</span>.
        <span>The <a title="optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is to select, from the matches that are left, the one that
        occurs last in <a title="declaration order" href=
        "#dt-declaration-order">declaration order</a>.</span></p>

        <p>If an element in a source document has a <a title=
        "type annotation" href="#dt-annotation">type annotation</a>
        that is a simple type or a complex type with simple
        content, then any whitespace text nodes among its children
        are preserved, regardless of any <a href=
        "#element-strip-space"><code>xsl:strip-space</code></a>
        declarations. The reason for this is that stripping a
        whitespace text node from an element with simple content
        could make the element invalid: for example, it could cause
        the <code>minLength</code> facet to be violated.</p>

        <p>Stripping of <a title="type annotation" href=
        "#dt-annotation">type annotations</a> happens before
        stripping of whitespace text nodes, so this
        <span>situation</span> will not occur if
        <code>input-type-annotations="strip"</code> is
        specified.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>In <a href="#xpath-datamodel">[Data Model]</a>,
          processes are described for constructing an <span>XDM
          tree</span> from an Infoset or from a PSVI. Those
          processes deal with whitespace according to their own
          rules, and the provisions in this section apply to the
          resulting tree. In practice this means that elements that
          are defined in a DTD or a Schema to contain element-only
          content will have <a title="whitespace text node" href=
          "#dt-whitespace-text-node">whitespace text nodes</a>
          stripped, regardless of the <a href=
          "#element-strip-space"><code>xsl:strip-space</code></a>
          and <a href=
          "#element-preserve-space"><code>xsl:preserve-space</code></a>
          declarations in the stylesheet.</p>

          <p>However, source trees are not necessarily constructed
          using those processes; indeed, they are not necessarily
          constructed by parsing XML documents. Nothing in the XSLT
          specification constrains how the source tree is
          constructed, or what happens to <a title=
          "whitespace text node" href=
          "#dt-whitespace-text-node">whitespace text nodes</a>
          during its construction. The provisions in this section
          relate only to whitespace text nodes that are present in
          the tree supplied as input to the XSLT processor. The
          XSLT processor cannot preserve whitespace text nodes
          unless they were actually present in the supplied
          tree.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="id-in-data-model" id=
        "id-in-data-model"></a>4.5 Attribute Types and DTD
        Validation</h3>

        <p>The mapping from the Infoset to the <span>XDM</span>
        data model, described in <a href="#xpath-datamodel">[Data
        Model]</a>, does not retain attribute types. This means,
        for example, that an attribute described in the DTD as
        having attribute type <code>NMTOKENS</code> will be
        annotated in <span>the XDM tree</span> as
        <span><code>xs:untypedAtomic</code></span> rather than
        <code>xs:NMTOKENS</code>, and its typed value will consist
        of a single <span><code>xs:untypedAtomic</code></span>
        value rather than a sequence of <code>xs:NMTOKEN</code>
        values.</p>

        <p>Attributes with a DTD-derived type of ID, IDREF, or
        IDREFS will be marked in the <span>XDM tree</span> as
        having the <code>is-id</code> or <code>is-idrefs</code>
        properties. It is these properties, rather than any
        <a title="type annotation" href="#dt-annotation">type
        annotation</a>, that are examined by the functions <a href=
        "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
        <small>FO</small></sup> and <a href=
        "http://www.w3.org/TR/xpath-functions/#func-idref"><code>idref</code></a><sup>
        <small>FO</small></sup> described in <a href=
        "#xpath-functions">[Functions and Operators]</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="limits" id="limits"></a>4.6 Limits</h3>

        <p>The XDM data model (see <a href="#xpath-datamodel">[Data
        Model]</a>) leaves it to the host language to define
        limits. This section describes the limits that apply to
        XSLT.</p>

        <p>Limits on some primitive data types are defined in
        <a href="#xmlschema-2">[XML Schema Part 2]</a>. Other
        limits, listed below, are <a title="implementation-defined"
        href=
        "#dt-implementation-defined">implementation-defined</a>.
        Note that this does not necessarily mean that each limit
        must be a simple constant: it may vary depending on
        environmental factors such as available resources.</p>

        <p>The following limits are <a title=
        "implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>:</p>

        <ol class="enumar">
          <li>
            <p>For the <code>xs:decimal</code> type, the maximum
            number of decimal digits (the <code>totalDigits</code>
            facet). This must be at least 18 digits. (Note,
            however, that support for the full value range of
            <code>xs:unsignedLong</code> requires 20 digits.)</p>
          </li>

          <li>
            <p>For the types <code>xs:date</code>,
            <code>xs:time</code>, <code>xs:dateTime</code>,
            <code>xs:gYear</code>, and <code>xs:gYearMonth</code>:
            the range of values of the year component, which must
            be at least +0001 to +9999; and the maximum number of
            fractional second digits, which must be at least 3.</p>
          </li>

          <li>
            <p>For the <code>xs:duration</code> type: the maximum
            absolute values of the years, months, days, hours,
            minutes, and seconds components.</p>
          </li>

          <li>
            <p>For the
            <span><code>xs:yearMonthDuration</code></span> type:
            the maximum absolute value, expressed as an integer
            number of months.</p>
          </li>

          <li>
            <p>For the <span><code>xs:dayTimeDuration</code></span>
            type: the maximum absolute value, expressed as a
            decimal number of seconds.</p>
          </li>

          <li>
            <p>For the types <code>xs:string</code>,
            <code>xs:hexBinary</code>,
            <code>xs:base64Binary</code>, <code>xs:QName</code>,
            <code>xs:anyURI</code>, <code>xs:NOTATION</code>, and
            types derived from them: the maximum length of the
            value.</p>
          </li>

          <li>
            <p>For sequences, the maximum number of items in a
            sequence.</p>
          </li>
        </ol>
      </div>

      <div class="div2">
        <h3><a name="d-o-e-in-data-model" id=
        "d-o-e-in-data-model"></a>4.7 Disable Output Escaping</h3>

        <p>For backwards compatibility reasons, XSLT 2.0 continues
        to support the <code>disable-output-escaping</code> feature
        introduced in XSLT 1.0. This is an optional feature and
        implementations are not <span class="verb">required</span>
        to support it. A new facility, that of named <a title=
        "character map" href="#dt-character-map">character maps</a>
        (see <a href="#character-maps"><i>20.1 Character
        Maps</i></a>) is introduced in XSLT 2.0. It provides
        similar capabilities to
        <code>disable-output-escaping</code>, but without
        distorting the data model.</p>

        <p>If an <a title="implementation" href=
        "#dt-implementation">implementation</a> supports the
        <code>disable-output-escaping</code> attribute of <a href=
        "#element-text"><code>xsl:text</code></a> and <a href=
        "#element-value-of"><code>xsl:value-of</code></a>, (see
        <a href="#disable-output-escaping"><i>20.2 Disabling Output
        Escaping</i></a>), then the data model for trees
        constructed by the <a title="processor" href=
        "#dt-processor">processor</a> is augmented with a boolean
        value representing the value of this property. <span>This
        boolean value, however, can be set only within a <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a> that is being passed to the
        serializer.</span></p>

        <p>Conceptually, each character in a text node on
        <span>such</span> a result tree has a boolean property
        indicating whether the serializer <span>is to</span>
        disable the normal rules for escaping of special characters
        (for example, outputting of <code>&amp;</code> as
        <code>&amp;amp;</code>) in respect of this character or
        attribute node.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>In practice, the nodes in a <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> will often be streamed directly from the
          XSLT processor to the serializer. In such an
          implementation, <code>disable-output-escaping</code> can
          be viewed not so much a property stored with nodes in the
          tree, but rather as additional information passed across
          the interface between the XSLT processor and the
          serializer.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="constructs" id="constructs"></a>5 Features of
      the XSLT Language</h2>

      <div class="div2">
        <h3><a name="qname" id="qname"></a>5.1 Qualified Names</h3>

        <p>The name of a stylesheet-defined object, specifically a
        <a title="named template" href="#dt-named-template">named
        template</a>, a <a title="mode" href="#dt-mode">mode</a>,
        an <a title="attribute set" href=
        "#dt-attribute-set">attribute set</a>, a <a title="key"
        href="#dt-key">key</a>, a <a title="decimal format" href=
        "#dt-decimal-format">decimal-format</a>, a <a title=
        "variable" href="#dt-variable">variable</a> or <a title=
        "parameter" href="#dt-parameter">parameter</a>, a <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a>, a named
        <a title="output definition" href=
        "#dt-output-definition">output definition</a>, <span>or a
        <a title="character map" href="#dt-character-map">character
        map</a></span> is specified as a <a title="QName" href=
        "#dt-qname">QName</a> <span>using the syntax for <a href=
        "http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a><sup>
        <small>Names</small></sup> as defined in <a href=
        "#REC-xml-names">[Namespaces in XML 1.0]</a></span>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-qname"
        id="dt-qname" title="QName"></a>A <b>QName</b> is always
        written in the form <code>(NCName ":")? NCName</code>, that
        is, a local name optionally preceded by a namespace prefix.
        When two QNames are compared, however, they are considered
        equal if the corresponding <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QNames</a> are the same, as
        described below.<span class="definition">]</span></p>

        <p>Because an atomic value of type <code>xs:QName</code> is
        sometimes referred to loosely as a QName, this
        specification also uses the term <a title="lexical QName"
        href="#dt-lexical-qname">lexical QName</a> to emphasize
        that it is referring to a <a href=
        "http://www.w3.org/TR/REC-xml-names/#NT-QName">QName</a><sup>
        <small>Names</small></sup> in its lexical form rather than
        its expanded form. This term is used especially when
        strings containing lexical QNames are manipulated as
        run-time values.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-lexical-qname" id="dt-lexical-qname" title=
        "lexical QName"></a>A <b>lexical QName</b> is a string
        representing a <a title="QName" href="#dt-qname">QName</a>
        in the form <code>(NCName ":")? NCName</code>, that is, a
        local name optionally preceded by a namespace
        prefix.<span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-defining-element" id="dt-defining-element" title=
        "defining element"></a><span>A string in the form of a
        lexical QName</span> may occur as the value of an attribute
        node in a stylesheet module, or within an XPath <a title=
        "expression" href="#dt-expression">expression</a> contained
        in such an attribute node, or as the result of evaluating
        an XPath expression contained in such an attribute node.
        The element containing this attribute node is referred to
        as the <b>defining element</b> of the QName.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-expanded-qname" id="dt-expanded-qname" title=
        "expanded-QName"></a>An <b>expanded-QName</b>
        <span>contains a pair of values, namely a local name and an
        optional namespace URI. It may also contain a namespace
        prefix.</span> Two expanded-QNames are equal if the
        namespace URIs are the same (or both absent) and the local
        names are the same. <span>The prefix plays no part in the
        comparison, but is used only if the expanded-QName needs to
        be converted back to a string.</span><span class=
        "definition">]</span></p>

        <p>If the QName has a prefix, then the prefix is expanded
        into a URI reference using the namespace declarations in
        effect on its <a title="defining element" href=
        "#dt-defining-element">defining element</a>. The <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> consisting of the
        local part of the name and the possibly null URI reference
        is used as the name of the object. The default namespace of
        the defining element (<span>see <a href=
        "http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section
        6.2 Element Nodes</a><sup><small>DM</small></sup></span>)
        is <em>not</em> used for unprefixed names.</p>

        <p>There are <span>three</span> cases where the default
        namespace <span>of the <a title="defining element" href=
        "#dt-defining-element">defining element</a></span>
        <em>is</em> used when expanding an unprefixed QName:</p>

        <ol class="enumar">
          <li>
            <p>Where a QName is used to define the name of an
            element being constructed. This applies both to cases
            where the name is known statically (that is, the name
            of a literal result element) and to cases where it is
            computed dynamically (the value of the
            <code>name</code> attribute of the <a href=
            "#element-element"><code>xsl:element</code></a>
            instruction).</p>
          </li>

          <li>
            <p>The default namespace is used when expanding the
            first argument of the function <a href=
            "#function-element-available"><code>element-available</code></a>.</p>
          </li>

          <li>
            <p>The default namespace applies to any unqualified
            element names appearing in the
            <code>cdata-section-elements</code> attribute of
            <a href="#element-output"><code>xsl:output</code></a>
            or <a href=
            "#element-result-document"><code>xsl:result-document</code></a></p>
          </li>
        </ol>

        <p>In the case of an unprefixed QName used as a
        <code>NameTest</code> within an XPath <a title="expression"
        href="#dt-expression">expression</a> (see <a href=
        "#expressions"><i>5.3 Expressions</i></a>) <span>, and in
        certain other contexts</span>, the namespace to be used in
        expanding the QName may be specified by means of the
        <code>[xsl:]xpath-default-namespace</code> attribute, as
        specified in <a href="#unprefixed-qnames"><i>5.2 Unprefixed
        QNames in Expressions and Patterns</i></a>.</p>

        <p><a name="err-XTSE0280" id="err-XTSE0280"><span class=
        "error">[ERR XTSE0280]</span></a> In the case of a
        <span>prefixed</span> <a title="QName" href=
        "#dt-qname">QName</a> used as the value of an attribute in
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, or appearing within an
        XPath <a title="expression" href=
        "#dt-expression">expression</a> in the stylesheet, it is a
        <a title="static error" href="#dt-static-error">static
        error</a> if the <a title="defining element" href=
        "#dt-defining-element">defining element</a> has no
        namespace node whose name matches the prefix of the
        <a title="QName" href="#dt-qname">QName</a>.</p>

        <p><a name="err-XTDE0290" id="err-XTDE0290"><span class=
        "error">[ERR XTDE0290]</span></a> Where the result of
        evaluating an XPath expression (or an attribute value
        template) is required to be a <a title="lexical QName"
        href="#dt-lexical-qname">lexical QName</a>, <span>then
        unless otherwise specified</span> it is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="defining element" href=
        "#dt-defining-element">defining element</a> has no
        namespace node whose name matches the prefix of the
        <a title="lexical QName" href="#dt-lexical-qname">lexical
        QName</a>. <span>This error <span class="verb">may</span>
        be signaled as a <a title="static error" href=
        "#dt-static-error">static error</a> if the value of the
        expression can be determined statically.</span></p>
      </div>

      <div class="div2">
        <h3><a name="unprefixed-qnames" id=
        "unprefixed-qnames"></a>5.2 Unprefixed QNames in
        Expressions and Patterns</h3>

        <p>The attribute <code>[xsl:]xpath-default-namespace</code>
        (see <a href="#standard-attributes"><i>3.5 Standard
        Attributes</i></a>) may be used on an element in the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        to define the namespace that will be used for an unprefixed
        element name <span>or type name</span> within an XPath
        expression, and in certain other contexts listed below.</p>

        <p>The value of the attribute is the namespace URI to be
        used.</p>

        <p>For any element in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, this attribute has an
        effective value, which is the value of the
        <code>[xsl:]xpath-default-namespace</code> on that element
        or on the innermost containing element that specifies such
        an attribute, or the zero-length string if no containing
        element specifies such an attribute.</p>

        <p>For any element in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, the effective value of
        this attribute determines the value of the <em>default
        namespace for element and type names</em> in the static
        context of any XPath expression contained in an attribute
        of that element <span>(including XPath expressions in
        <a title="attribute value template" href=
        "#dt-attribute-value-template">attribute value
        templates</a>)</span>. The effect of this is specified in
        <a href="#xpath20">[XPath 2.0]</a>; in summary, it
        determines the namespace used for any unprefixed type name
        in the SequenceType production, and for any element name
        appearing in a path expression or in the SequenceType
        production.</p>

        <p>The effective value of this attribute similarly applies
        to <span>any of the following constructs appearing within
        its scope</span>:</p>

        <ul>
          <li>
            <p>any unprefixed element name or type name used in a
            <a title="pattern" href="#dt-pattern">pattern</a></p>
          </li>

          <li>
            <p>any unprefixed element name used in the
            <code>elements</code> attribute of the <a href=
            "#element-strip-space"><code>xsl:strip-space</code></a>
            or <a href=
            "#element-preserve-space"><code>xsl:preserve-space</code></a>
            instructions</p>
          </li>

          <li>
            <p>any unprefixed element name or type name used in the
            <code>as</code> attribute of an <a title="XSLT element"
            href="#dt-xslt-element">XSLT element</a></p>
          </li>

          <li>
            <p>any unprefixed type name used in the
            <code>type</code> attribute of an <a title=
            "XSLT element" href="#dt-xslt-element">XSLT
            element</a></p>
          </li>

          <li>
            <p>any unprefixed type name used in the
            <code>xsl:type</code> attribute of a <a title=
            "literal result element" href=
            "#dt-literal-result-element">literal result
            element</a>.</p>
          </li>
        </ul>

        <p>The <code>[xsl:]xpath-default-namespace</code> attribute
        <span class="verb">must</span> be in the <a title=
        "XSLT namespace" href="#dt-xslt-namespace">XSLT
        namespace</a> if and only if its parent element is
        <em>not</em> in the XSLT namespace.</p>

        <p>If the effective value of the attribute is a zero-length
        string, which will be the case if it is explicitly set to a
        zero-length string or if it is not specified at all, then
        an unprefixed element name or type name refers to a name
        that is in no namespace. The default namespace <span>of the
        parent element (see <a href=
        "http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section
        6.2 Element Nodes</a><sup><small>DM</small></sup>)</span>
        is <em>not</em> used.</p>

        <p>The attribute does not affect other names, for example
        function names, variable names, or template names, or
        strings that are interpreted as <a title="lexical QName"
        href="#dt-lexical-qname">lexical QNames</a> during
        stylesheet evaluation, such as the <a title=
        "effective value" href="#dt-effective-value">effective
        value</a> of the <code>name</code> attribute of <a href=
        "#element-element"><code>xsl:element</code></a> or the
        string supplied as the first argument to the <a href=
        "#function-key"><code>key</code></a> function.</p>
      </div>

      <div class="div2">
        <h3><a name="expressions" id="expressions"></a>5.3
        Expressions</h3>

        <p>XSLT uses the expression language defined by XPath 2.0
        <a href="#xpath20">[XPath 2.0]</a>. Expressions are used in
        XSLT for a variety of purposes including:</p>

        <ul>
          <li>
            <p>selecting nodes for processing;</p>
          </li>

          <li>
            <p>specifying conditions for different ways of
            processing a node;</p>
          </li>

          <li>
            <p>generating text to be inserted in a <a title=
            "result tree" href="#dt-result-tree">result
            tree</a>.</p>
          </li>
        </ul>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-expression" id="dt-expression" title=
        "expression"></a>Within this specification, the term
        <b>XPath expression</b>, or simply <b>expression</b>, means
        a string that matches the production <span><a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</a><sup>
        <small>XP</small></sup></span> defined in <a href=
        "#xpath20">[XPath 2.0]</a>.<span class=
        "definition">]</span></p>

        <p>An XPath expression may occur as the value of certain
        attributes on XSLT-defined elements, and also within curly
        brackets in <a title="attribute value template" href=
        "#dt-attribute-value-template">attribute value
        templates</a>.</p>

        <p>Except where <a title="forwards-compatible behavior"
        href="#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a> is enabled (see <a href="#forwards"><i>3.9
        Forwards-Compatible Processing</i></a>), it is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the value of such an attribute, or the text between curly
        brackets in an attribute value template, does not match the
        XPath production <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</a><sup>
        <small>XP</small></sup>, or if it fails to satisfy other
        static constraints defined in the XPath specification, for
        example that all variable references <span class=
        "verb">must</span> refer to <a title="variable" href=
        "#dt-variable">variables</a> that are in scope. <span>Error
        codes are defined in <a href="#xpath20">[XPath
        2.0]</a>.</span></p>

        <p>The transformation fails with a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if any XPath <a title="expression" href=
        "#dt-expression">expression</a> is evaluated and raises a
        dynamic error. <span>Error codes are defined in <a href=
        "#xpath20">[XPath 2.0]</a>.</span></p>

        <p>The transformation fails with a <a title="type errors"
        href="#dt-type-error">type error</a> if an XPath <a title=
        "expression" href="#dt-expression">expression</a> raises a
        type error, or if the result of evaluating the XPath
        <a title="expression" href="#dt-expression">expression</a>
        is evaluated and raises a type error, or if the XPath
        processor signals a type error during static analysis of an
        <a title="expression" href="#dt-expression">expression</a>.
        <span>Error codes are defined in <a href="#xpath20">[XPath
        2.0]</a>.</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-required-type" id="dt-required-type" title=
        "required type"></a>The context within a <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> where an
        XPath <a title="expression" href=
        "#dt-expression">expression</a> <span>appears may
        specify</span> the <b>required type</b> of the expression.
        The required type indicates the type of the value that the
        expression is expected to return.<span class=
        "definition">]</span> If no required type is specified, the
        expression may return any value: in effect, the required
        type is then <code>item()*</code>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-function-conversion-rules" id=
        "dt-function-conversion-rules" title=
        "function conversion rules"></a>Except where otherwise
        indicated, the actual value of an <a title="expression"
        href="#dt-expression">expression</a> is converted to the
        <a title="required type" href="#dt-required-type">required
        type</a> using the <b>function conversion rules</b>. These
        are the rules defined in <a href="#xpath20">[XPath 2.0]</a>
        for converting the supplied argument of a function call to
        the required type of that argument, as defined in the
        function signature. The relevant rules are those that apply
        when <a title="XPath 1.0 compatibility mode" href=
        "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
        is set to <code>false</code>.<span class=
        "definition">]</span></p>

        <p>This specification also invokes the XPath 2.0 <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a> to convert the result of evaluating an XSLT
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> to a
        required type (for example, the sequence constructor
        enclosed in an <a href=
        "#element-variable"><code>xsl:variable</code></a>, <a href=
        "#element-template"><code>xsl:template</code></a>, or
        <a href="#element-function"><code>xsl:function</code></a>
        element).</p>

        <p>Any <a title="dynamic error" href=
        "#dt-dynamic-error">dynamic error</a> or <a title=
        "type errors" href="#dt-type-error">type error</a> that
        occurs when applying the <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a> to convert a value to a required type results in
        the transformation failing, in the same way as if the error
        had occurred while evaluating an expression.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Note the distinction between the two kinds of error
          that may occur. Attempting to convert an integer to a
          date is a type error, because such a conversion is never
          possible. Type errors can be reported statically if they
          can be detected statically, whether or not the construct
          in question is ever evaluated. Attempting to convert the
          string <code>2003-02-29</code> to a date is a dynamic
          error rather than a type error, because the problem is
          with this particular value, not with its type. Dynamic
          errors are reported only if the instructions or
          expressions that cause them are actually evaluated.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="static-and-dynamic-context" id=
        "static-and-dynamic-context"></a>5.4 The Static and Dynamic
        Context</h3>

        <p>XPath defines the concept of an <a href=
        "http://www.w3.org/TR/xpath20/#dt-expression-context">expression
        context</a><sup><small>XP</small></sup> which contains all
        the information that can affect the result of evaluating an
        <a title="expression" href="#dt-expression">expression</a>.
        The expression context has two parts, the <a href=
        "http://www.w3.org/TR/xpath20/#dt-static-context">static
        context</a><sup><small>XP</small></sup>, and the <a href=
        "http://www.w3.org/TR/xpath20/#dt-dynamic-context">dynamic
        context</a><sup><small>XP</small></sup>. The components
        that make up the expression context are defined in the
        XPath specification (see <a href=
        "http://www.w3.org/TR/xpath20/#context">Section 2.1
        Expression Context</a><sup><small>XP</small></sup>). This
        section describes the way in which these components are
        initialized when an XPath expression is contained within an
        XSLT stylesheet.</p>

        <p>As well as providing values for the static and dynamic
        context components defined in the XPath specification, XSLT
        defines additional context components of its own. These
        context components are used by XSLT instructions (for
        example, <a href=
        "#element-next-match"><code>xsl:next-match</code></a> and
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>),
        and also by the functions in the extended function library
        described in this specification.</p>

        <p>The following four sections describe:</p>

        <blockquote>
          <p><a href="#static-context"><i>5.4.1 Initializing the
          Static Context</i></a><br />
          <a href="#additional-static-context"><i>5.4.2 Additional
          Static Context Components used by XSLT</i></a><br />
          <a href="#xpath-dynamic-context"><i>5.4.3 Initializing
          the Dynamic Context</i></a><br />
          <a href="#additional-dynamic-context"><i>5.4.4 Additional
          Dynamic Context Components used by XSLT</i></a></p>
        </blockquote>

        <div class="div3">
          <h4><a name="static-context" id=
          "static-context"></a>5.4.1 Initializing the Static
          Context</h4>

          <p>The <a href=
          "http://www.w3.org/TR/xpath20/#dt-static-context">static
          context</a><sup><small>XP</small></sup> of an XPath
          expression appearing in an XSLT stylesheet is initialized
          as follows. In these rules, the term <b>containing
          element</b> means the element within the stylesheet that
          is the parent of the attribute whose value contains the
          XPath expression in question, and the term <b>enclosing
          element</b> means the containing element or any of its
          ancestors.</p>

          <ul>
            <li>
              <p><a title="XPath 1.0 compatibility mode" href=
              "#dt-compatibility-mode">XPath 1.0 compatibility
              mode</a> is set to true if and only if the containing
              element occurs in part of the <a title="stylesheet"
              href="#dt-stylesheet">stylesheet</a> where <a title=
              "backwards compatible behavior" href=
              "#dt-backwards-compatible-behavior">backwards
              compatible behavior</a> is enabled (see <a href=
              "#backwards"><i>3.8 Backwards-Compatible
              Processing</i></a>).</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-static-namespaces">statically
              known namespaces</a><sup><small>XP</small></sup> are
              the namespace declarations that are in scope for the
              containing element.</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-def-elemtype-ns">default
              element/type
              namespace</a><sup><small>XP</small></sup> is the
              namespace defined by the
              <code>[xsl:]xpath-default-namespace</code> attribute
              on the innermost enclosing element that has such an
              attribute, as described in <a href=
              "#unprefixed-qnames"><i>5.2 Unprefixed QNames in
              Expressions and Patterns</i></a>. The value of this
              attribute is a namespace URI. <span>If there is no
              <code>[xsl:]xpath-default-namespace</code> attribute
              on an enclosing element, the default namespace for
              element names and type names is the null
              namespace.</span></p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-def-fn-ns">default
              function namespace</a><sup><small>XP</small></sup> is
              the <a title="standard function namespace" href=
              "#dt-standard-function-namespace">standard function
              namespace</a>, defined in <a href=
              "#xpath-functions">[Functions and Operators]</a>.
              This means that it is not necessary to declare this
              namespace in the <a title="stylesheet" href=
              "#dt-stylesheet">stylesheet</a>, nor is it necessary
              to use the prefix <code>fn</code> (or any other
              prefix) in calls to the <a title="core function"
              href="#dt-core-function">core functions</a>.</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-issd">in-scope
              schema definitions</a><sup><small>XP</small></sup>
              for the XPath expression are the same as the
              <a title="in-scope schema component" href=
              "#dt-in-scope-schema-component">in-scope schema
              components</a> for the <a title="stylesheet" href=
              "#dt-stylesheet">stylesheet</a>, and are as specified
              in <a href="#built-in-types"><i>3.13 Built-in
              Types</i></a>.</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-in-scope-variables">
              in-scope variables</a><sup><small>XP</small></sup>
              are <span>defined by</span> the <a title=
              "variable-binding element" href=
              "#dt-variable-binding-element">variable binding
              elements</a> that are in scope for the containing
              element (see <a href="#variables-and-parameters"><i>9
              Variables and Parameters</i></a>).</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-function-signature">
              function signatures</a><sup><small>XP</small></sup>
              are the <a title="core function" href=
              "#dt-core-function">core functions</a> defined in
              <a href="#xpath-functions">[Functions and
              Operators]</a>, the constructor functions for all the
              atomic types in the <a href=
              "http://www.w3.org/TR/xpath20/#dt-issd">in-scope
              schema definitions</a><sup><small>XP</small></sup>,
              the additional functions defined in this
              specification, the <a title="stylesheet function"
              href="#dt-stylesheet-function">stylesheet
              functions</a> defined in the stylesheet, plus any
              <a title="extension function" href=
              "#dt-extension-function">extension functions</a>
              bound using <a title="implementation-defined" href=
              "#dt-implementation-defined">implementation-defined</a>
              mechanisms (see <a href="#extension"><i>18
              Extensibility and Fallback</i></a>).</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>It follows from the above that a conformant XSLT
                processor must implement the entire library of
                <a title="core function" href=
                "#dt-core-function">core functions</a> defined in
                <a href="#xpath-functions">[Functions and
                Operators]</a>.</p>
              </div>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-static-collations">statically
              known collations</a><sup><small>XP</small></sup> are
              <a title="implementation-defined" href=
              "#dt-implementation-defined">implementation-defined</a>.
              <span>However, the set of in-scope collations
              <span class="verb">must</span> always include the
              Unicode codepoint collation, defined in <a href=
              "http://www.w3.org/TR/xpath-functions/#string-compare">
              Section 7.3 Equality and Comparison of
              Strings</a><sup><small>FO</small></sup>.</span></p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-def-collation">default
              collation</a><sup><small>XP</small></sup> is defined
              by the value of the
              <code>[xsl:]default-collation</code> attribute on the
              innermost enclosing element that has such an
              attribute. For details, see <a href=
              "#default-collation-attribute"><i>3.6.1 The
              default-collation attribute</i></a>.</p>

              <p><span class=
              "definition">[Definition:&#160;</span><a name=
              "dt-default-collation" id="dt-default-collation"
              title="default collation"></a>In this specification
              the term <b>default collation</b> means the collation
              that is used by XPath operators such as
              <code>eq</code> and <code>lt</code> appearing in
              XPath expressions within the stylesheet.<span class=
              "definition">]</span></p>

              <p>This collation is also used by default when
              comparing strings in the evaluation of the <a href=
              "#element-key"><code>xsl:key</code></a> and <a href=
              "#element-for-each-group"><code>xsl:for-each-group</code></a>
              elements. This <span class="verb">may</span> also
              (but need not necessarily) be the same as the default
              collation used for <a href=
              "#element-sort"><code>xsl:sort</code></a> elements
              within the stylesheet. Collations used by <a href=
              "#element-sort"><code>xsl:sort</code></a> are
              described in <a href="#collating-sequences"><i>13.1.3
              Sorting Using Collations</i></a>.</p>
            </li>

            <li>
              <p>The <a href=
              "http://www.w3.org/TR/xpath20/#dt-base-uri">base
              URI</a><sup><small>XP</small></sup> is the base URI
              of the containing element. The concept of the base
              URI of a node is defined in <a href=
              "http://www.w3.org/TR/xpath-datamodel/#dm-base-uri">Section
              5.2 base-uri
              Accessor</a><sup><small>DM</small></sup></p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="additional-static-context" id=
          "additional-static-context"></a>5.4.2 Additional Static
          Context Components used by XSLT</h4>

          <p>Some of the components of the XPath static context are
          used also by <a title="XSLT element" href=
          "#dt-xslt-element">XSLT elements</a>. For example, the
          <a href="#element-sort"><code>xsl:sort</code></a> element
          makes use of the collations defined in the static
          context, and attributes such as <code>type</code> and
          <code>as</code> may reference types defined in the
          <a title="in-scope schema component" href=
          "#dt-in-scope-schema-component">in-scope schema
          components</a>.</p>

          <p>Many top-level declarations in a stylesheet, and
          attributes on the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element, affect the behavior of instructions within the
          stylesheet. Each of these constructs is described in its
          appropriate place in this specification.</p>

          <p>A number of these constructs are of particular
          significance because they are used by functions defined
          in XSLT, which are added to the library of functions
          available for use in XPath expressions within the
          stylesheet. These are:</p>

          <ul>
            <li>
              <p>The set of named keys, used by the <a href=
              "#function-key"><code>key</code></a> function</p>
            </li>

            <li>
              <p>The set of named decimal formats, used by the
              <a href=
              "#function-format-number"><code>format-number</code></a>
              function</p>
            </li>

            <li>
              <p>The values of system properties, used by the
              <a href=
              "#function-system-property"><code>system-property</code></a>
              function</p>
            </li>

            <li>
              <p>The set of available instructions, used by the
              <a href=
              "#function-element-available"><code>element-available</code></a>
              function</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="xpath-dynamic-context" id=
          "xpath-dynamic-context"></a>5.4.3 Initializing the
          Dynamic Context</h4>

          <p>For convenience, the dynamic context is described in
          two parts: the <a title="focus" href=
          "#dt-focus">focus</a>, which represents the place in the
          source document that is currently being processed, and a
          collection of additional context variables.</p>

          <p>A number of functions specified in <a href=
          "#xpath-functions">[Functions and Operators]</a> are
          defined to be <a href=
          "http://www.w3.org/TR/xpath-functions/#stable">stable</a><sup>
          <small>FO</small></sup>, meaning that if they are called
          twice during the same <a href=
          "http://www.w3.org/TR/xpath-functions/#execution-scope">execution
          scope</a><sup><small>FO</small></sup>, with the same
          arguments, then they return the same results (see
          <a href="http://www.w3.org/TR/xpath-functions/#terminology">
          Section 1.7 Terminology</a><sup><small>FO</small></sup>).
          In XSLT, the execution of a stylesheet defines the
          execution scope. This means, for example, that if the
          function <a href=
          "http://www.w3.org/TR/xpath-functions/#func-current-dateTime">
          <code>current-dateTime</code></a><sup><small>FO</small></sup>
          is called repeatedly during a transformation, it produces
          the same result each time. By implication, the components
          of the dynamic context on which these functions depend
          are also stable for the duration of the transformation.
          Specifically, the following components defined in
          <a href="http://www.w3.org/TR/xpath20/#eval_context">Section
          2.1.2 Dynamic Context</a><sup><small>XP</small></sup>
          must be stable: <em>function implementations</em>,
          <em>current dateTime</em>, <em>implicit timezone</em>,
          <em>available documents</em>, <em>available
          collections</em>, and <em>default collection</em>. The
          values of global variables and stylesheet parameters are
          also stable for the duration of a transformation. The
          focus is <em>not</em> stable; the additional dynamic
          context components defined in <a href=
          "#additional-dynamic-context"><i>5.4.4 Additional Dynamic
          Context Components used by XSLT</i></a> are also
          <em>not</em> stable.</p>

          <p>As specified in <a href="#xpath-functions">[Functions
          and Operators]</a>, implementations may provide user
          options that relax the requirement for the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
          <small>FO</small></sup> and <a href=
          "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
          collection</code></a><sup><small>FO</small></sup>
          functions (and therefore, by implication, the <a href=
          "#function-document"><code>document</code></a> function)
          to return stable results. By default, however, the
          functions must be stable. The manner in which such user
          options are provided, if at all, is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.</p>

          <p>XPath expressions contained in
          <code>[xsl:]use-when</code> attributes are not considered
          to be evaluated "during the transformation" as defined
          above. For details see <a href=
          "#conditional-inclusion"><i>3.12 Conditional Element
          Inclusion</i></a>.</p>

          <div class="div4">
            <h5><a name="focus" id="focus"></a>5.4.3.1 Maintaining
            Position: the Focus</h5>

            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-focus" id="dt-focus" title="focus"></a>When a
            <a title="sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a> is
            evaluated, the <a title="processor" href=
            "#dt-processor">processor</a> keeps track of which
            items are being processed by means of a set of implicit
            variables referred to collectively as the
            <b>focus</b>.<span class="definition">]</span> More
            specifically, the focus consists of the following three
            values:</p>

            <ul>
              <li>
                <p><span class=
                "definition">[Definition:&#160;</span><a name=
                "dt-context-item" id="dt-context-item" title=
                "context item"></a>The <b>context item</b> is the
                item currently being processed. An item (see
                <a href="#xpath-datamodel">[Data Model]</a>) is
                either an atomic value (such as an integer, date,
                or string), or a node. The context item is
                initially set to the <a title=
                "initial context node" href=
                "#dt-initial-context-node">initial context node</a>
                supplied when the transformation is invoked (see
                <a href="#initiating"><i>2.3 Initiating a
                Transformation</i></a>). It changes whenever
                instructions such as <a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a>
                and <a href=
                "#element-for-each"><code>xsl:for-each</code></a>
                are used to process a sequence of items; each item
                in such a sequence becomes the context item while
                that item is being processed.<span class=
                "definition">]</span> The context item is returned
                by the XPath <a title="expression" href=
                "#dt-expression">expression</a> <code>.</code>
                (dot).</p>
              </li>

              <li>
                <p><span class=
                "definition">[Definition:&#160;</span><a name=
                "dt-context-position" id="dt-context-position"
                title="context position"></a>The <b>context
                position</b> is the position of the context item
                within the sequence of items currently being
                processed. It changes whenever the context item
                changes. When an instruction such as <a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a>
                or <a href=
                "#element-for-each"><code>xsl:for-each</code></a>
                is used to process a sequence of items, the first
                item in the sequence is processed with a context
                position of 1, the second item with a context
                position of 2, and so on.<span class=
                "definition">]</span> The context position is
                returned by the XPath <a title="expression" href=
                "#dt-expression">expression</a>
                <code>position()</code>.</p>
              </li>

              <li>
                <p><span class=
                "definition">[Definition:&#160;</span><a name=
                "dt-context-size" id="dt-context-size" title=
                "context size"></a>The <b>context size</b> is the
                number of items in the sequence of items currently
                being processed. It changes whenever instructions
                such as <a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a>
                and <a href=
                "#element-for-each"><code>xsl:for-each</code></a>
                are used to process a sequence of items; during the
                processing of each one of those items, the context
                size is set to the count of the number of items in
                the sequence (or equivalently, the position of the
                last item in the sequence).<span class=
                "definition">]</span> The context size is returned
                by the XPath <a title="expression" href=
                "#dt-expression">expression</a>
                <code>last()</code>.</p>
              </li>
            </ul>

            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-context-node" id="dt-context-node" title=
            "context node"></a>If the <a title="context item" href=
            "#dt-context-item">context item</a> is a node (as
            distinct from an atomic value such as an integer), then
            it is also referred to as the <b>context node</b>. The
            context node is not an independent variable, it changes
            whenever the context item changes. When the context
            item is an atomic value, there is no context
            node.<span class="definition">]</span> The context node
            is returned by the XPath <a title="expression" href=
            "#dt-expression">expression</a>
            <code>self::node()</code>, and it is used as the
            starting node for all relative path expressions.</p>

            <p>Where the containing element of an XPath expression
            is an <a title="instruction" href=
            "#dt-instruction">instruction</a> or a <a title=
            "literal result element" href=
            "#dt-literal-result-element">literal result
            element</a>, the initial context item, context
            position, and context size for the XPath <a title=
            "expression" href="#dt-expression">expression</a> are
            the same as the <a title="context item" href=
            "#dt-context-item">context item</a>, <a title=
            "context position" href="#dt-context-position">context
            position</a>, and <a title="context size" href=
            "#dt-context-size">context size</a> for the evaluation
            of the containing instruction or literal result
            element.</p>

            <p>In other cases (for example, where the containing
            element is <a href=
            "#element-sort"><code>xsl:sort</code></a>, <a href=
            "#element-with-param"><code>xsl:with-param</code></a>,
            or <a href="#element-key"><code>xsl:key</code></a>),
            the rules are given in the specification of the
            containing element.</p>

            <p>The <a href=
            "#function-current"><code>current</code></a> function
            can be used within any XPath <a title="expression"
            href="#dt-expression">expression</a> to select the item
            that was supplied as the context item to the XPath
            expression by the XSLT processor. Unlike <code>.</code>
            (dot) this is unaffected by changes to the context item
            that occur within the XPath expression. The <a href=
            "#function-current"><code>current</code></a> function
            is described in <a href="#current-function"><i>16.6.1
            current</i></a>.</p>

            <p>On completion of an instruction that changes the
            <a title="focus" href="#dt-focus">focus</a> (such as
            <a href=
            "#element-apply-templates"><code>xsl:apply-templates</code></a>
            or <a href=
            "#element-for-each"><code>xsl:for-each</code></a>), the
            focus reverts to its previous value.</p>

            <p>When a <a title="stylesheet function" href=
            "#dt-stylesheet-function">stylesheet function</a> is
            called, the focus within the body of the function is
            initially undefined. <span>The focus is also undefined
            on initial entry to the <a title="stylesheet" href=
            "#dt-stylesheet">stylesheet</a> if no <a title=
            "initial context node" href=
            "#dt-initial-context-node">initial context node</a> is
            supplied.</span></p>

            <p>When the focus is undefined, evaluation of any
            <a title="expression" href=
            "#dt-expression">expression</a> that references the
            context item, context position, or context size results
            in a <a title="non-recoverable dynamic error" href=
            "#dt-nonrec-dynamic-error">non-recoverable dynamic
            error</a> [XPDY0002]</p>

            <p>The description above gives an outline of the way
            the <a title="focus" href="#dt-focus">focus</a> works.
            Detailed rules for the effect of each instruction are
            given separately with the description of that
            instruction. In the absence of specific rules, an
            instruction uses the same focus as its parent
            instruction.</p>

            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-singleton-focus" id="dt-singleton-focus" title=
            "singleton focus"></a>A <b>singleton focus</b> based on
            a node <var>N</var> has the <a title="context item"
            href="#dt-context-item">context item</a> (and therefore
            the <a title="context node" href=
            "#dt-context-node">context node</a>) set to
            <var>N</var>, and the <a title="context position" href=
            "#dt-context-position">context position</a> and
            <a title="context size" href="#dt-context-size">context
            size</a> both set to 1 (one).<span class=
            "definition">]</span></p>
          </div>

          <div class="div4">
            <h5><a name="evaluation-context" id=
            "evaluation-context"></a>5.4.3.2 Other components of
            the XPath Dynamic Context</h5>

            <p>The previous section explained how the <a title=
            "focus" href="#dt-focus">focus</a> for an XPath
            expression appearing in an XSLT stylesheet is
            initialized. This section explains how the other
            components of the <a href=
            "http://www.w3.org/TR/xpath20/#dt-dynamic-context">dynamic
            context</a><sup><small>XP</small></sup> of an XPath
            expression are initialized.</p>

            <ul>
              <li>
                <p>The <a href=
                "http://www.w3.org/TR/xpath20/#dt-variable-values">dynamic
                variables</a><sup><small>XP</small></sup> are the
                current values of the in-scope <a title=
                "variable-binding element" href=
                "#dt-variable-binding-element">variable binding
                elements</a>.</p>
              </li>

              <li>
                <p>The <em>current date and time</em> represents an
                <a title="implementation-dependent" href=
                "#dt-implementation-dependent">implementation-dependent</a>
                point in time during processing of the
                transformation; it does not change during the
                course of the transformation.</p>
              </li>

              <li>
                <p>The <a href=
                "http://www.w3.org/TR/xpath20/#dt-timezone">implicit
                timezone</a><sup><small>XP</small></sup> is
                <a title="implementation-defined" href=
                "#dt-implementation-defined">implementation-defined</a>.</p>
              </li>

              <li>
                <p>The <a href=
                "http://www.w3.org/TR/xpath20/#dt-known-docs">available
                documents</a><sup><small>XP</small></sup>, and the
                <a href=
                "http://www.w3.org/TR/xpath20/#dt-known-collections">
                available
                collections</a><sup><small>XP</small></sup> are
                determined as part of the process for initiating a
                transformation (see <a href="#initiating"><i>2.3
                Initiating a Transformation</i></a>).</p>

                <p>The <a href=
                "http://www.w3.org/TR/xpath20/#dt-known-docs">available
                documents</a><sup><small>XP</small></sup> are
                defined as part of the XPath 2.0 dynamic context to
                support the <a href=
                "http://www.w3.org/TR/xpath-functions/#func-doc"><code>
                doc</code></a><sup><small>FO</small></sup>
                function, but this component is also referenced by
                the similar XSLT <a href=
                "#function-document"><code>document</code></a>
                function: see <a href="#document"><i>16.1 Multiple
                Source Documents</i></a>. This variable defines a
                mapping between URIs passed to the <a href=
                "http://www.w3.org/TR/xpath-functions/#func-doc"><code>
                doc</code></a><sup><small>FO</small></sup> or
                <a href=
                "#function-document"><code>document</code></a>
                function and the document nodes that are
                returned.</p>

                <div class="note">
                  <p class="prefix"><b>Note:</b></p>

                  <p>Defining this as part of the evaluation
                  context is a formal way of specifying that the
                  way in which URIs get turned into document nodes
                  is outside the control of the language
                  specification, and depends entirely on the
                  run-time environment in which the transformation
                  takes place.</p>
                </div>

                <p>The XSLT-defined <a href=
                "#function-document"><code>document</code></a>
                function allows the use of URI references
                containing fragment identifiers. The interpretation
                of a fragment identifier depends on the media type
                of the resource representation. Therefore, the
                information supplied in <a href=
                "http://www.w3.org/TR/xpath20/#dt-known-docs">available
                documents</a><sup><small>XP</small></sup> for XSLT
                processing must provide not only a mapping from
                URIs to document nodes as required by XPath, but
                also a mapping from URIs to media types.</p>
              </li>

              <li>
                <p>The <a href=
                "http://www.w3.org/TR/xpath20/#dt-default-collection">
                default collection</a><sup><small>XP</small></sup>
                is <a title="implementation-defined" href=
                "#dt-implementation-defined">implementation-defined</a>.
                This allows options such as setting the default
                collection to be an empty sequence, or to be
                undefined.</p>
              </li>
            </ul>
          </div>
        </div>

        <div class="div3">
          <h4><a name="additional-dynamic-context" id=
          "additional-dynamic-context"></a>5.4.4 Additional Dynamic
          Context Components used by XSLT</h4>

          <p>In addition to the values that make up the <a title=
          "focus" href="#dt-focus">focus</a>, an XSLT processor
          maintains a number of other dynamic context components
          that reflect aspects of the evaluation context. These
          components are fully described in the sections of the
          specification that maintain and use them. They are:</p>

          <ul>
            <li>
              <p>The <a title="current template rule" href=
              "#dt-current-template-rule">current template
              rule</a>, which is the <a title="template rule" href=
              "#dt-template-rule">template rule</a> most recently
              invoked by an <a href=
              "#element-apply-templates"><code>xsl:apply-templates</code></a>,
              <a href=
              "#element-apply-imports"><code>xsl:apply-imports</code></a>,
              or <a href=
              "#element-next-match"><code>xsl:next-match</code></a>
              instruction: see <a href="#apply-imports"><i>6.7
              Overriding Template Rules</i></a>;</p>
            </li>

            <li>
              <p>The <a title="current mode" href=
              "#dt-current-mode">current mode</a>, which is the
              <a title="mode" href="#dt-mode">mode</a> set by the
              most recent call of <a href=
              "#element-apply-templates"><code>xsl:apply-templates</code></a>
              (for a full definition see <a href="#modes"><i>6.5
              Modes</i></a>);</p>
            </li>

            <li>
              <p>The <a title="current group" href=
              "#dt-current-group">current group</a> and <a title=
              "current grouping key" href=
              "#dt-current-grouping-key">current grouping key</a>,
              which provide information about the collection of
              items currently being processed by an <a href=
              "#element-for-each-group"><code>xsl:for-each-group</code></a>
              instruction: see <a href="#current-group"><i>14.1 The
              Current Group</i></a> and <a href=
              "#current-grouping-key"><i>14.2 The Current Grouping
              Key</i></a>;</p>
            </li>

            <li>
              <p>The <a title="current captured substrings" href=
              "#dt-current-captured-substrings">current captured
              substrings</a>: this is a sequence of strings, which
              is maintained when a string is matched against a
              regular expression using the <a href=
              "#element-analyze-string"><code>xsl:analyze-string</code></a>
              instruction, and which is accessible using the
              <a href=
              "#function-regex-group"><code>regex-group</code></a>
              function: see <a href="#regex-group"><i>15.2 Captured
              Substrings</i></a>.</p>
            </li>

            <li>
              <p>The <a title="output state" href=
              "#dt-output-state">output state</a>: this is a flag
              whose two possible values are <a title=
              "final output state" href=
              "#dt-final-output-state">final output state</a> and
              <a title="temporary output state" href=
              "#dt-temporary-output-state">temporary output
              state</a>. This flag indicates whether instructions
              are currently writing to a <a title=
              "final result tree" href=
              "#dt-final-result-tree">final result tree</a> or to
              an internal data structure. The initial setting is
              <a title="final output state" href=
              "#dt-final-output-state">final output state</a>, and
              it is switched to <a title="temporary output state"
              href="#dt-temporary-output-state">temporary output
              state</a> by instructions such as <a href=
              "#element-variable"><code>xsl:variable</code></a>.
              For more details, see <a href=
              "#creating-result-trees"><i>19.1 Creating Final
              Result Trees</i></a>.</p>
            </li>
          </ul>

          <p>The following non-normative table summarizes the
          initial state of each of the components in the evaluation
          context, and the instructions which cause the state of
          the component to change.</p>

          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th align="left">Component</th>

                <th align="left">Initial Setting</th>

                <th align="left">Set by</th>

                <th align="left">Cleared by</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td valign="top"><a title="focus" href=
                "#dt-focus">focus</a></td>

                <td valign="top">singleton focus based on the
                <a title="initial context node" href=
                "#dt-initial-context-node">initial context node</a>
                if supplied</td>

                <td valign="top"><a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a>,
                <a href=
                "#element-for-each"><code>xsl:for-each</code></a>,
                <a href=
                "#element-for-each-group"><code>xsl:for-each-group</code></a>,
                <a href=
                "#element-analyze-string"><code>xsl:analyze-string</code></a></td>

                <td valign="top">calls on <a title=
                "stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>
              </tr>

              <tr>
                <td valign="top"><a title="current template rule"
                href="#dt-current-template-rule">current template
                rule</a></td>

                <td valign="top"><span>If a <a title=
                "named template" href="#dt-named-template">named
                template</a> is supplied as the entry point to the
                transformation, then null; otherwise the <a title=
                "initial template" href=
                "#dt-initial-template">initial
                template</a></span></td>

                <td valign="top"><a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a>,
                <a href=
                "#element-apply-imports"><code>xsl:apply-imports</code></a>,
                <a href=
                "#element-next-match"><code>xsl:next-match</code></a></td>

                <td valign="top"><a href=
                "#element-for-each"><code>xsl:for-each</code></a>,
                <a href=
                "#element-for-each-group"><code>xsl:for-each-group</code></a>,
                and <span><a href=
                "#element-analyze-string"><code>xsl:analyze-string</code></a></span>,
                and calls on <a title="stylesheet function" href=
                "#dt-stylesheet-function">stylesheet functions</a>.
                Also cleared while evaluating global variables or
                default values of stylesheet parameters, and the
                sequence constructors contained in <a href=
                "#element-key"><code>xsl:key</code></a> and
                <a href="#element-sort"><code>xsl:sort</code></a>.</td>
              </tr>

              <tr>
                <td valign="top"><a title="current mode" href=
                "#dt-current-mode">current mode</a></td>

                <td valign="top">the initial <a title="mode" href=
                "#dt-mode">mode</a></td>

                <td valign="top"><a href=
                "#element-apply-templates"><code>xsl:apply-templates</code></a></td>

                <td valign="top">calls on <a title=
                "stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>
              </tr>

              <tr>
                <td valign="top"><a title="current group" href=
                "#dt-current-group">current group</a></td>

                <td valign="top">empty sequence</td>

                <td valign="top"><a href=
                "#element-for-each-group"><code>xsl:for-each-group</code></a></td>

                <td valign="top">calls on <a title=
                "stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>
              </tr>

              <tr>
                <td valign="top"><a title="current grouping key"
                href="#dt-current-grouping-key">current grouping
                key</a></td>

                <td valign="top">empty sequence</td>

                <td valign="top"><a href=
                "#element-for-each-group"><code>xsl:for-each-group</code></a></td>

                <td valign="top">calls on <a title=
                "stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>
              </tr>

              <tr>
                <td valign="top"><a title=
                "current captured substrings" href=
                "#dt-current-captured-substrings">current captured
                substrings</a></td>

                <td valign="top">empty sequence</td>

                <td valign="top"><a href=
                "#element-matching-substring"><code>xsl:matching-substring</code></a></td>

                <td valign="top"><a href=
                "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>;
                calls on <a title="stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>
              </tr>

              <tr>
                <td valign="top"><a title="output state" href=
                "#dt-output-state">output state</a></td>

                <td valign="top"><a title="final output state"
                href="#dt-final-output-state">final output
                state</a></td>

                <td valign="top">Set to <a title=
                "temporary output state" href=
                "#dt-temporary-output-state">temporary output
                state</a> by instructions such as <a href=
                "#element-variable"><code>xsl:variable</code></a>,
                <a href=
                "#element-attribute"><code>xsl:attribute</code></a>,
                etc., and by calls on <a title=
                "stylesheet function" href=
                "#dt-stylesheet-function">stylesheet
                functions</a></td>

                <td valign="top">None</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="div2">
        <h3><a name="patterns" id="patterns"></a>5.5 Patterns</h3>

        <p>A <a title="template rule" href=
        "#dt-template-rule">template rule</a> identifies the nodes
        to which it applies by means of a pattern. As well as being
        used in template rules, patterns are used for numbering
        (see <a href="#number"><i>12 Numbering</i></a>), for
        grouping (see <a href="#grouping"><i>14 Grouping</i></a>),
        and for declaring <a title="" href="#key">keys</a> (see
        <a href="#key"><i>16.3 Keys</i></a>).</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-pattern"
        id="dt-pattern" title="pattern"></a>A <b>pattern</b>
        specifies a set of conditions on a node. A node that
        satisfies the conditions matches the pattern; a node that
        does not satisfy the conditions does not match the pattern.
        The syntax for patterns is a subset of the syntax for
        <a title="expression" href=
        "#dt-expression">expressions</a>.<span class=
        "definition">]</span> As explained in detail below, a node
        matches a pattern if the node can be selected by
        <span>deriving an equivalent expression, and</span>
        evaluating this expression with respect to some possible
        context.</p>

        <div class="div3">
          <h4><a name="pattern-examples" id=
          "pattern-examples"></a>5.5.1 Examples of Patterns</h4>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e8032" id="d5e8032"></a>Example: Patterns
            </div>

            <p>Here are some examples of patterns:</p>

            <ul>
              <li>
                <p><code>para</code> matches any <code>para</code>
                element.</p>
              </li>

              <li>
                <p><code>*</code> matches any element.</p>
              </li>

              <li>
                <p><code>chapter|appendix</code> matches any
                <code>chapter</code> element and any
                <code>appendix</code> element.</p>
              </li>

              <li>
                <p><code>olist/entry</code> matches any
                <code>entry</code> element with an
                <code>olist</code> parent.</p>
              </li>

              <li>
                <p><code>appendix//para</code> matches any
                <code>para</code> element with an
                <code>appendix</code> ancestor element.</p>
              </li>

              <li>
                <p><code>schema-element(us:address)</code> matches
                any element that is annotated as an instance of the
                type defined by the schema element declaration
                <code>us:address</code>, and whose name is either
                <code>us:address</code> or the name of another
                element in its substitution group.</p>
              </li>

              <li>
                <p><code>attribute(*, xs:date)</code> matches any
                attribute annotated as being of type
                <code>xs:date</code>.</p>
              </li>

              <li>
                <p><code>/</code> matches a document node.</p>
              </li>

              <li>
                <p><code>document-node()</code> matches a document
                node.</p>
              </li>

              <li>
                <p>
                <code>document-node(schema-element(my:invoice))</code>
                matches the document node of a document whose
                document element <span>is named
                <code>my:invoice</code> and matches the type
                defined by the global element declaration</span>
                <code>my:invoice</code>.</p>
              </li>

              <li>
                <p><code>text()</code> matches any text node.</p>
              </li>

              <li>
                <p><code>node()</code> matches any node other than
                an attribute node, namespace node, or document
                node.</p>
              </li>

              <li>
                <p><code>id("W33")</code> matches the element with
                unique ID <code>W33</code>.</p>
              </li>

              <li>
                <p><code>para[1]</code> matches any
                <code>para</code> element that is the first
                <code>para</code> child element of its parent.
                <span>It also matches a parentless
                <code>para</code> element.</span></p>
              </li>

              <li>
                <p><code>//para</code> matches any
                <code>para</code> element that has a parent
                node.</p>
              </li>

              <li>
                <p><code>bullet[position() mod 2 = 0]</code>
                matches any <code>bullet</code> element that is an
                even-numbered <code>bullet</code> child of its
                parent.</p>
              </li>

              <li>
                <p><code>div[@class="appendix"]//p</code> matches
                any <code>p</code> element with a <code>div</code>
                ancestor element that has a <code>class</code>
                attribute with value <code>appendix</code>.</p>
              </li>

              <li>
                <p><code>@class</code> matches any
                <code>class</code> attribute (<em>not</em> any
                element that has a <code>class</code>
                attribute).</p>
              </li>

              <li>
                <p><code>@*</code> matches any attribute node.</p>
              </li>
            </ul>
          </div>
        </div>

        <div class="div3">
          <h4><a name="pattern-syntax" id=
          "pattern-syntax"></a>5.5.2 Syntax of Patterns</h4>

          <p><a name="err-XTSE0340" id="err-XTSE0340"><span class=
          "error">[ERR XTSE0340]</span></a> Where an attribute is
          defined to contain a <a title="pattern" href=
          "#dt-pattern">pattern</a>, it is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the pattern does not match the production <a href=
          "#NT-Pattern">Pattern</a>. Every pattern is a legal XPath
          <a title="expression" href=
          "#dt-expression">expression</a>, but the converse is not
          true: <code>2+2</code> is an example of a legal XPath
          expression that is not a pattern. The XPath expressions
          that can be used as patterns are those that match the
          grammar for <a href="#NT-Pattern">Pattern</a>, given
          below.</p>

          <p>Informally, a <a href="#NT-Pattern">Pattern</a> is a
          set of path expressions separated by <code>|</code>,
          where each step in the path expression is constrained to
          be an <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-AxisStep">AxisStep</a><sup>
          <small>XP</small></sup> that uses only the
          <code>child</code> or <code>attribute</code> axes.
          Patterns may also use the <code>//</code> operator. A
          <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-Predicate">Predicate</a><sup>
          <small>XP</small></sup> within the <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">PredicateList</a><sup>
          <small>XP</small></sup> in a pattern can contain
          arbitrary XPath expressions (enclosed between square
          brackets) in the same way as a <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-Predicate">predicate</a><sup>
          <small>XP</small></sup> in a path expression.</p>

          <p>Patterns may start with an <a href=
          "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
          <small>FO</small></sup> or <a href=
          "#function-key"><code>key</code></a> function call,
          provided that the value to be matched is supplied as
          either a literal or a reference to a <a title="variable"
          href="#dt-variable">variable</a> or <a title="parameter"
          href="#dt-parameter">parameter</a>, and the key name (in
          the case of the <a href=
          "#function-key"><code>key</code></a> function) is
          supplied as a string literal. <span>These patterns will
          never match a node in a tree whose root is not a document
          node.</span></p>

          <p>If a pattern occurs in part of the <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> where
          <a title="backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled (see <a href="#backwards"><i>3.8
          Backwards-Compatible Processing</i></a>), then <span>the
          semantics of the pattern are defined on the basis that
          the equivalent XPath expression is evaluated with
          <a title="XPath 1.0 compatibility mode" href=
          "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
          set to true.</span></p>

          <h5><a name="d5e8328" id="d5e8328"></a>Patterns</h5>

          <table class="scrap" summary="Scrap">
            <tbody>
              <tr valign="baseline">
                <td><a name="NT-Pattern" id=
                "NT-Pattern"></a>[1]&#160;&#160;&#160;</td>

                <td><code>Pattern</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#NT-PathPattern">PathPattern</a></code></td>
              </tr>

              <tr valign="baseline">
                <td></td>

                <td></td>

                <td></td>

                <td><code>| <a href="#NT-Pattern">Pattern</a> '|'
                <a href=
                "#NT-PathPattern">PathPattern</a></code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-PathPattern" id=
                "NT-PathPattern"></a>[2]&#160;&#160;&#160;</td>

                <td><code>PathPattern</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#NT-RelativePathPattern">RelativePathPattern</a></code></td>
              </tr>

              <tr valign="baseline">
                <td></td>

                <td></td>

                <td></td>

                <td><code>| '/' <a href=
                "#NT-RelativePathPattern">RelativePathPattern</a>?</code></td>
              </tr>

              <tr valign="baseline">
                <td></td>

                <td></td>

                <td></td>

                <td><code>| '//' <a href=
                "#NT-RelativePathPattern">RelativePathPattern</a></code></td>
              </tr>

              <tr valign="baseline">
                <td></td>

                <td></td>

                <td></td>

                <td><code>| <a href=
                "#NT-IdKeyPattern">IdKeyPattern</a> (('/' | '//')
                <a href=
                "#NT-RelativePathPattern">RelativePathPattern</a>)?</code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-RelativePathPattern" id=
                "NT-RelativePathPattern"></a>[3]&#160;&#160;&#160;</td>

                <td><code>RelativePathPattern</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href="#NT-PatternStep">PatternStep</a>
                (('/' | '//') <a href=
                "#NT-RelativePathPattern">RelativePathPattern</a>)?</code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-PatternStep" id=
                "NT-PatternStep"></a>[4]&#160;&#160;&#160;</td>

                <td><code>PatternStep</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "#NT-PatternAxis">PatternAxis</a>? <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</a><sup>
                <small>XP</small></sup> <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">
                PredicateList</a><sup><small>XP</small></sup></code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-PatternAxis" id=
                "NT-PatternAxis"></a>[5]&#160;&#160;&#160;</td>

                <td><code>PatternAxis</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>('child' '::' | 'attribute' '::' |
                '@')</code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-IdKeyPattern" id=
                "NT-IdKeyPattern"></a>[6]&#160;&#160;&#160;</td>

                <td><code>IdKeyPattern</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code>'id' '(' <a href=
                "#NT-IdValue">IdValue</a> ')'</code></td>
              </tr>

              <tr valign="baseline">
                <td></td>

                <td></td>

                <td></td>

                <td><code>| 'key' '(' <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">
                StringLiteral</a><sup><small>XP</small></sup> ','
                <a href="#NT-KeyValue">KeyValue</a> ')'</code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-IdValue" id=
                "NT-IdValue"></a>[7]&#160;&#160;&#160;</td>

                <td><code>IdValue</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">
                StringLiteral</a><sup><small>XP</small></sup> |
                <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</a><sup>
                <small>XP</small></sup></code></td>
              </tr>

              <tr valign="baseline">
                <td><a name="NT-KeyValue" id=
                "NT-KeyValue"></a>[8]&#160;&#160;&#160;</td>

                <td><code>KeyValue</code></td>

                <td>&#160;&#160;&#160;::=&#160;&#160;&#160;</td>

                <td><code><a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-Literal">Literal</a><sup>
                <small>XP</small></sup> | <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</a><sup>
                <small>XP</small></sup></code></td>
              </tr>
            </tbody>
          </table>

          <p>The constructs <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</a><sup>
          <small>XP</small></sup>, <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-PredicateList">PredicateList</a><sup>
          <small>XP</small></sup>, <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-VarRef">VarRef</a><sup>
          <small>XP</small></sup>, <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-Literal">Literal</a><sup>
          <small>XP</small></sup>, and <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</a><sup>
          <small>XP</small></sup> are part of the XPath expression
          language, and are defined in <a href="#xpath20">[XPath
          2.0]</a>.</p>
        </div>

        <div class="div3">
          <h4><a name="pattern-semantics" id=
          "pattern-semantics"></a>5.5.3 The Meaning of a
          Pattern</h4>

          <p>The meaning of a pattern is defined formally as
          follows.</p>

          <p>First we define the concept of an <em>equivalent
          expression</em>. In general, the equivalent expression is
          the XPath expression that takes the same lexical form as
          the pattern as written. However, if the pattern contains
          a <code>PathPattern</code> that is a
          <code>RelativePathPattern</code>, then the first
          <code>PatternStep</code> <var>PS</var> of this
          <code>RelativePathPattern</code> is adjusted to allow it
          to match a parentless element or attribute node, as
          follows:</p>

          <ul>
            <li>
              <p>If the <code>NodeTest</code> in <var>PS</var> is
              <code>document-node()</code> (optionally with
              arguments), and if no explicit axis is specified,
              then the axis in step <var>PS</var> is taken as
              <code>self</code> rather than <code>child</code>.</p>
            </li>

            <li>
              <p>If <var>PS</var> uses the child axis (explicitly
              or implicitly), and if the <code>NodeTest</code> in
              <var>PS</var> is not <code>document-node()</code>
              (optionally with arguments), then the axis in step
              <var>PS</var> is replaced by
              <code>child-or-top</code>, which is defined as
              follows. If the context node is a parentless element,
              comment, processing-instruction, or text node then
              the <code>child-or-top</code> axis selects the
              context node; otherwise it selects the children of
              the context node. It is a forwards axis whose
              principal node kind is element.</p>
            </li>

            <li>
              <p>If <var>PS</var> uses the attribute axis, then the
              axis in step <var>PS</var> is replaced by
              <code>attribute-or-top</code>, which is defined as
              follows. If the context node is an attribute node
              with no parent, then the
              <code>attribute-or-top</code> axis selects the
              context node; otherwise it selects the attributes of
              the context node. It is a forwards axis whose
              principal node kind is attribute.</p>
            </li>
          </ul>

          <p>The axes <code>child-or-top</code> and
          <code>attribute-or-top</code> are introduced only for
          definitional purposes. They cannot be used explicitly in
          a user-written pattern or expression.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The purpose of these adjustments is to ensure that a
            pattern such as <code>person</code> matches any element
            named <code>person</code>, even if it has no parent;
            and similarly, that the pattern <code>@width</code>
            matches any attribute named <code>width</code>, even a
            parentless attribute. The rule also ensures that a
            pattern using a <code>NodeTest</code> of the form
            <code>document-node(...)</code> matches a document
            node. The pattern <code>node()</code> will match any
            element, text node, comment, or processing instruction,
            whether or not it has a parent. For backwards
            compatibility reasons, the pattern <code>node()</code>,
            when used without an explicit axis, does not match
            document nodes, attribute nodes, or namespace nodes.
            The rules are also phrased to ensure that positional
            patterns of the form <code>para[1]</code> continue to
            count nodes relative to their parent, if they have
            one.</p>
          </div>

          <p>Let the equivalent expression, calculated according to
          these rules, be <var>EE</var>.</p>

          <p>To determine whether a node <var>N</var> matches the
          pattern, evaluate the <a title="expression" href=
          "#dt-expression">expression</a>
          <code>root(.)//(<var>EE</var>)</code> with a <a title=
          "singleton focus" href="#dt-singleton-focus">singleton
          focus</a> based on <var>N</var>. If the result is a
          sequence of nodes that includes <var>N</var>, then node
          <var>N</var> matches the pattern; otherwise node
          <var>N</var> does not match the pattern.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e8624" id="d5e8624"></a>Example: The
              Semantics of Patterns
            </div>

            <p>The pattern <code>p</code> matches any
            <code>p</code> element, because a <code>p</code>
            element will always be present in the result of
            evaluating the <a title="expression" href=
            "#dt-expression">expression</a>
            <code>root(.)//(child-or-top::p)</code>. Similarly,
            <code>/</code> matches <span>a document node, and only
            a document node,</span> because the result of the
            <a title="expression" href=
            "#dt-expression">expression</a>
            <code>root(.)//(/)</code> returns the root node of the
            tree containing the context node <span>if and only if
            it is a document node.</span></p>

            <p>The pattern <code>node()</code> matches all nodes
            selected by the expression
            <code>root(.)//(child-or-top::node())</code>, that is,
            all element, text, comment, and processing instruction
            nodes, whether or not they have a parent. It does not
            match attribute or namespace nodes because the
            expression does not select nodes using the attribute or
            namespace axes. <span>It does not match document nodes
            because for backwards compatibility reasons the
            <code>child-or-top</code> axis does not match a
            document node.</span></p>
          </div>

          <p>Although the semantics of patterns are specified
          formally in terms of expression evaluation, it is
          possible to understand pattern matching using a different
          model. In a pattern, <code>|</code> indicates
          alternatives; a pattern with one or more <code>|</code>
          separated alternatives matches if any one of the
          alternatives matches. A pattern such as
          <code>book/chapter/section</code> can be examined from
          right to left. A node will only match this pattern if it
          is a <code>section</code> element; and then, only if its
          parent is a <code>chapter</code>; and then, only if the
          parent of that <code>chapter</code> is a
          <code>book</code>. When the pattern uses the
          <code>//</code> operator, one can still read it from
          right to left, but this time testing the ancestors of a
          node rather than its parent. For example
          <code>appendix//section</code> matches every
          <code>section</code> element that has an ancestor
          <code>appendix</code> element.</p>

          <p>The formal definition, however, is useful for
          understanding the meaning of a pattern such as
          <code>para[1]</code>. This matches any node selected by
          the expression
          <code>root(.)//(child-or-top::para[1])</code>: that is,
          any <code>para</code> element that is the first
          <code>para</code> child of its parent, <span>or a
          <code>para</code> element that has no parent.</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>An implementation, of course, may use any algorithm
            it wishes for evaluating patterns, so long as the
            result corresponds with the formal definition above. An
            implementation that followed the formal definition by
            evaluating the equivalent expression and then testing
            the membership of a specific node in the result would
            probably be very inefficient.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="pattern-errors" id=
          "pattern-errors"></a>5.5.4 Errors in Patterns</h4>

          <p>Any <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> or <a title=
          "type errors" href="#dt-type-error">type error</a> that
          occurs during the evaluation of a <a title="pattern"
          href="#dt-pattern">pattern</a> against a particular node
          is treated as a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable error</a> even if the
          error would not be recoverable under other circumstances.
          The <a title="optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to treat the pattern as not matching that
          node.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The reason for this provision is that it is
            difficult for the stylesheet author to predict which
            predicates in a pattern will actually be evaluated. In
            the case of match patterns in template rules, it is not
            even possible to predict which patterns will be
            evaluated against a particular node. Making errors in
            patterns recoverable enables an implementation, if it
            chooses to do so, to report such errors while
            stylesheets are under development, while masking them
            if they occur during production running.</p>
          </div>

          <p>One particular optimization is <span class=
          "verb">required</span> by this specification: for a
          <a href="#NT-PathPattern">PathPattern</a> that starts
          with <code>/</code> or <code>//</code> or with an
          <a href="#NT-IdKeyPattern">IdKeyPattern</a>, the result
          of testing this pattern against a node in a tree whose
          root is not a document node must be a non-match, rather
          than a dynamic error. This rule applies to each <a href=
          "#NT-PathPattern">PathPattern</a> within a <a href=
          "#NT-Pattern">Pattern</a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Without the above rule, any attempt to apply
            templates to a parentless element node would create the
            risk of a dynamic error if the stylesheet has a
            template rule specifying <code>match="/"</code>.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="attribute-value-templates" id=
        "attribute-value-templates"></a>5.6 Attribute Value
        Templates</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-attribute-value-template" id=
        "dt-attribute-value-template" title=
        "attribute value template"></a>In an attribute that is
        designated as an <b>attribute value template</b>, such as
        an attribute of a <a title="literal result element" href=
        "#dt-literal-result-element">literal result element</a>, an
        <a title="expression" href="#dt-expression">expression</a>
        can be used by surrounding the expression with curly
        brackets (<code>{}</code>)<span class=
        "definition">]</span>.</p>

        <p>An attribute value template consists of an alternating
        sequence of fixed parts and variable parts. A variable part
        consists of an XPath <a title="expression" href=
        "#dt-expression">expression</a> enclosed in curly brackets
        (<code>{}</code>). A fixed part may contain any characters,
        except that a left curly bracket <span class=
        "verb">must</span> be written as <code>{{</code> and a
        right curly bracket <span class="verb">must</span> be
        written as <code>}}</code>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>An expression within a variable part may contain an
          unescaped curly bracket within a <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">StringLiteral</a><sup>
          <small>XP</small></sup> <span>or within a
          comment</span>.</p>
        </div>

        <p><a name="err-XTSE0350" id="err-XTSE0350"><span class=
        "error">[ERR XTSE0350]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an unescaped left curly bracket appears in a fixed part of
        an attribute value template without a matching right curly
        bracket.</p>

        <p>It is a <a title="static error" href=
        "#dt-static-error">static error</a> if the string contained
        between matching curly brackets in an attribute value
        template does not match the XPath production <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</a><sup>
        <small>XP</small></sup>, or if it contains other XPath
        static errors. The error is signaled using the appropriate
        XPath error code.</p>

        <p><a name="err-XTSE0370" id="err-XTSE0370"><span class=
        "error">[ERR XTSE0370]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an unescaped right curly bracket occurs in a fixed part of
        an attribute value template.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-effective-value" id="dt-effective-value" title=
        "effective value"></a>The result of evaluating an attribute
        value template is referred to as the <b>effective value</b>
        of the attribute.<span class="definition">]</span> The
        effective value is the string obtained by concatenating the
        expansions of the fixed and variable parts:</p>

        <ul>
          <li>
            <p>The expansion of a fixed part is obtained by
            replacing any double curly brackets (<code>{{</code> or
            <code>}}</code>) by the corresponding single curly
            bracket.</p>
          </li>

          <li>
            <p>The expansion of a variable part is obtained by
            evaluating the enclosed XPath <a title="expression"
            href="#dt-expression">expression</a> and converting the
            resulting value to a string. <span>This conversion is
            done using the rules given in <a href=
            "#constructing-simple-content"><i>5.7.2 Constructing
            Simple Content</i></a>.</span></p>
          </li>
        </ul>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This process can generate dynamic errors, for example
          if the sequence contains an element with a complex
          content type (which cannot be atomized).</p>
        </div>

        <p>If <a title="backwards compatible behavior" href=
        "#dt-backwards-compatible-behavior">backwards compatible
        behavior</a> is enabled for the attribute, the rules for
        converting the value of the expression to a string are
        modified as follows. After <a title="atomize" href=
        "#dt-atomization">atomizing</a> the result of the
        expression, all items other than the first item in the
        resulting sequence are discarded, and the effective value
        is obtained by converting the first item in the sequence to
        a string. If the atomized sequence is empty, the result is
        a zero-length string.</p>

        <p>Curly brackets are not treated specially in an attribute
        value in an XSLT <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> unless the attribute is
        specifically designated as one that permits an attribute
        value template; in an element syntax summary, the value of
        such attributes is surrounded by curly brackets.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Not all attributes are designated as attribute value
          templates. Attributes whose value is an <a title=
          "expression" href="#dt-expression">expression</a> or
          <a title="pattern" href="#dt-pattern">pattern</a>,
          attributes of <a title="declaration" href=
          "#dt-declaration">declaration</a> elements and attributes
          that refer to named XSLT objects are
          <span>generally</span> not designated as attribute value
          templates <span>(an exception is the <code>format</code>
          attribute of <a href=
          "#element-result-document"><code>xsl:result-document</code></a>)</span>.
          Namespace declarations are not <span>XDM attribute
          nodes</span> and are therefore never treated as attribute
          value templates.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e8932" id="d5e8932"></a>Example: Attribute
            Value Templates
          </div>

          <p>The following example creates an <code>img</code>
          result element from a <code>photograph</code> element in
          the source; the value of the <code>src</code> and
          <code>width</code> attributes are computed using XPath
          expressions enclosed in attribute value templates:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{$image-dir}/{href}" width="{size/@width}"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>With this source</p>

          <div class="exampleInner">
            <pre>
&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;
</pre>
          </div>

          <p>the result would be</p>

          <div class="exampleInner">
            <pre>
&lt;img src="/images/headquarters.jpg" width="300"/&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e8959" id="d5e8959"></a>Example: Producing a
            Space-Separated List
          </div>

          <p>The following example shows how the values in a
          sequence are output as a space-separated list. The
          following literal result element:</p>

          <div class="exampleInner">
            <pre>
&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;
</pre>
          </div>

          <p>produces the output node:</p>

          <div class="exampleInner">
            <pre>
&lt;temperature readings="10.32 5.5 8.31"/&gt;
</pre>
          </div>
        </div>

        <p>Curly brackets are <em>not</em> recognized recursively
        inside expressions.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e8975" id="d5e8975"></a>Example: Curly
            Brackets can not be Nested
          </div>

          <p>For example:</p>

          <div class="exampleInner">
            <pre>
&lt;a href="#{id({@ref})/title}"&gt;
</pre>
          </div>

          <p>is <em>not</em> allowed. Instead, use simply:</p>

          <div class="exampleInner">
            <pre>
&lt;a href="#{id(@ref)/title}"&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="sequence-constructors" id=
        "sequence-constructors"></a>5.7 Sequence Constructors</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-sequence-constructor" id="dt-sequence-constructor"
        title="sequence constructor"></a>A <b>sequence
        constructor</b> is a sequence of zero or more sibling nodes
        in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> that can be evaluated to
        return a sequence of nodes and atomic values. The way that
        the resulting sequence is used depends on the containing
        instruction.<span class="definition">]</span></p>

        <p>Many <a title="XSLT element" href=
        "#dt-xslt-element">XSLT elements</a>, <span>and also</span>
        <a title="literal result element" href=
        "#dt-literal-result-element">literal result elements</a>,
        are defined to take a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> as
        their content.</p>

        <p>Four kinds of nodes may be encountered in a sequence
        constructor:</p>

        <ul>
          <li>
            <p><em>Text nodes</em> appearing in the <a title=
            "stylesheet" href="#dt-stylesheet">stylesheet</a> (if
            they have not been removed in the process of whitespace
            stripping: see <a href="#stylesheet-stripping"><i>4.2
            Stripping Whitespace from the Stylesheet</i></a>) are
            copied to create a new parentless text node in the
            result sequence.</p>
          </li>

          <li>
            <p><a title="literal result element" href=
            "#dt-literal-result-element">Literal result
            elements</a> are evaluated to create a new parentless
            element node, having the same <a title="expanded-QName"
            href="#dt-expanded-qname">expanded-QName</a> as the
            literal result element, which is added to the result
            sequence: see <a href="#literal-result-element"><i>11.1
            Literal Result Elements</i></a></p>
          </li>

          <li>
            <p>XSLT <a title="instruction" href=
            "#dt-instruction">instructions</a> produce a sequence
            of zero, one, or more items as their result. These
            items are added to the result sequence. For most XSLT
            instructions, these items are nodes, but some
            instructions (<a href=
            "#element-sequence"><code>xsl:sequence</code></a> and
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>) can
            also produce atomic values. Several instructions, such
            as <a href=
            "#element-element"><code>xsl:element</code></a>, return
            a newly constructed parentless node (which may have its
            own attributes, namespaces, children, and other
            descendants). Other instructions, such as <a href=
            "#element-if"><code>xsl:if</code></a>, pass on the
            items produced by their own nested sequence
            constructors. The <a href=
            "#element-sequence"><code>xsl:sequence</code></a>
            instruction may return atomic values, or existing
            nodes.</p>
          </li>

          <li>
            <p><a title="extension instruction" href=
            "#dt-extension-instruction">Extension instructions</a>
            (see <a href="#extension-instruction"><i>18.2 Extension
            Instructions</i></a>) also produce a sequence of items
            as their result. The items in this sequence are added
            to the result sequence.</p>
          </li>
        </ul>

        <p>There are several ways the result of a sequence
        constructor may be used.</p>

        <ul>
          <li>
            <p>The sequence may be bound to a variable or returned
            from a stylesheet function, in which case it becomes
            available as a value to be manipulated in arbitrary
            ways by XPath expressions. The sequence is bound to a
            variable when the sequence constructor appears within
            one of the elements <a href=
            "#element-variable"><code>xsl:variable</code></a>,
            <a href="#element-param"><code>xsl:param</code></a>, or
            <a href=
            "#element-with-param"><code>xsl:with-param</code></a>,
            when this instruction has an <code>as</code> attribute.
            The sequence is returned from a stylesheet function
            when the sequence constructor appears within the
            <a href=
            "#element-function"><code>xsl:function</code></a>
            element.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>This will typically expose to the stylesheet
              elements, attributes, and other nodes that have not
              yet been attached to a parent node in a <a title=
              "result tree" href="#dt-result-tree">result tree</a>.
              The semantics of XPath expressions when applied to
              parentless nodes are well-defined; however, such
              expressions should be used with care. For example,
              the expression <code>/</code> <span>causes a type
              error if the root of the tree containing the context
              node is not a document node.</span>.</p>

              <p>Parentless attribute nodes require particular care
              because they have no namespace nodes associated with
              them. <span>A parentless attribute node is not
              permitted to contain namespace-sensitive content (for
              example, a QName or an XPath expression) because
              there is no information enabling the prefix to be
              resolved to a namespace URI.</span> Parentless
              attributes can be useful in an application (for
              example, they provide an alternative to the use of
              attribute sets: see <a href="#attribute-sets"><i>10.2
              Named Attribute Sets</i></a>) but they need to be
              handled with care.</p>
            </div>
          </li>

          <li>
            <p>The sequence may be returned as the result of the
            containing element. This happens when the instruction
            containing the sequence constructor is <a href=
            "#element-analyze-string"><code>xsl:analyze-string</code></a>,
            <a href=
            "#element-apply-imports"><code>xsl:apply-imports</code></a>,
            <a href=
            "#element-apply-templates"><code>xsl:apply-templates</code></a>,
            <a href=
            "#element-call-template"><code>xsl:call-template</code></a>,
            <a href="#element-choose"><code>xsl:choose</code></a>,
            <a href=
            "#element-fallback"><code>xsl:fallback</code></a>,
            <a href=
            "#element-for-each"><code>xsl:for-each</code></a>,
            <a href=
            "#element-for-each-group"><code>xsl:for-each-group</code></a>,
            <a href="#element-if"><code>xsl:if</code></a>, <a href=
            "#element-matching-substring"><code>xsl:matching-substring</code></a>,
            <a href=
            "#element-next-match"><code>xsl:next-match</code></a>,
            <a href=
            "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>,
            <a href=
            "#element-otherwise"><code>xsl:otherwise</code></a>,
            <a href=
            "#element-perform-sort"><code>xsl:perform-sort</code></a>,
            <a href=
            "#element-sequence"><code>xsl:sequence</code></a>, or
            <a href="#element-when"><code>xsl:when</code></a></p>
          </li>

          <li>
            <p>The sequence may be used to construct the content of
            a new element or document node. This happens when the
            sequence constructor appears as the content of a
            <a title="literal result element" href=
            "#dt-literal-result-element">literal result
            element</a>, or of one of the instructions <a href=
            "#element-copy"><code>xsl:copy</code></a>, <a href=
            "#element-element"><code>xsl:element</code></a>,
            <span><a href=
            "#element-document"><code>xsl:document</code></a>,
            <a href=
            "#element-result-document"><code>xsl:result-document</code></a>,</span>
            or <a href=
            "#element-message"><code>xsl:message</code></a>. It
            also happens when the sequence constructor is contained
            in one of the elements <a href=
            "#element-variable"><code>xsl:variable</code></a>,
            <a href="#element-param"><code>xsl:param</code></a>, or
            <a href=
            "#element-with-param"><code>xsl:with-param</code></a>,
            when this instruction has no <code>as</code> attribute.
            For details, see <a href=
            "#constructing-complex-content"><i>5.7.1 Constructing
            Complex Content</i></a>.</p>
          </li>

          <li>
            <p>The sequence may be used to construct the <a title=
            "string value" href="#dt-string-value">string value</a>
            of an attribute node, <span>text node</span>, namespace
            node, comment node, or processing instruction node.
            This happens when the sequence constructor is contained
            in one of the elements <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <span><a href=
            "#element-value-of"><code>xsl:value-of</code></a></span>,
            <a href=
            "#element-namespace"><code>xsl:namespace</code></a>,
            <a href=
            "#element-comment"><code>xsl:comment</code></a>, or
            <a href=
            "#element-processing-instruction"><code>xsl:processing-instruction</code></a>.
            For details, see <a href=
            "#constructing-simple-content"><i>5.7.2 Constructing
            Simple Content</i></a>.</p>
          </li>
        </ul>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The term <em><span>sequence</span> constructor</em>
          replaces <em>template</em> as used in XSLT 1.0. The
          change is made partly for clarity (to avoid confusion
          with <a title="template rule" href=
          "#dt-template-rule">template rules</a> and <a title=
          "named template" href="#dt-named-template">named
          templates</a>), but also to reflect a more formal
          definition of the semantics. Whereas XSLT 1.0 described a
          template as a sequence of instructions that write to the
          result tree, XSLT 2.0 describes a <span>sequence</span>
          constructor as something that can be evaluated to return
          a sequence of <span>items</span>; what happens to these
          items depends on the containing instruction.</p>
        </div>

        <div class="div3">
          <h4><a name="constructing-complex-content" id=
          "constructing-complex-content"></a>5.7.1 Constructing
          Complex Content</h4>

          <p>This section describes how the sequence obtained by
          evaluating a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> may
          be used to construct the children of a newly constructed
          document node, or the children, attributes and namespaces
          of a newly constructed element node. The sequence of
          items may be obtained by evaluating the <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>
          contained in an instruction such as <a href=
          "#element-copy"><code>xsl:copy</code></a>, <a href=
          "#element-element"><code>xsl:element</code></a>,
          <span><a href=
          "#element-document"><code>xsl:document</code></a></span>,
          <a href=
          "#element-result-document"><code>xsl:result-document</code></a>,
          or a <a title="literal result element" href=
          "#dt-literal-result-element">literal result
          element</a>.</p>

          <p>When constructing the content of an element, the
          <code>inherit-namespaces</code> attribute of the <a href=
          "#element-element"><code>xsl:element</code></a> or
          <a href="#element-copy"><code>xsl:copy</code></a>
          instruction, or the <code>xsl:inherit-namespaces</code>
          property of the literal result element, determines
          whether namespace nodes are to be inherited. The effect
          of this attribute is described in the rules that
          follow.</p>

          <p>The sequence is processed as follows <span>(applying
          the rules in the order they are listed)</span>:</p>

          <ol class="enumar">
            <li>
              <p>The containing instruction may generate attribute
              nodes and/or namespace nodes, as specified in the
              rules for the individual instruction. For example,
              these nodes may be produced by expanding an
              <code>[xsl:]use-attribute-sets</code> attribute, or
              by expanding the attributes of a <a title=
              "literal result element" href=
              "#dt-literal-result-element">literal result
              element</a>. Any such nodes are prepended to the
              sequence produced by evaluating the <a title=
              "sequence constructor" href=
              "#dt-sequence-constructor">sequence
              constructor</a>.</p>
            </li>

            <li>
              <p>Any atomic value in the sequence is cast to a
              string.</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>Casting from <code>xs:QName</code> or
                <code>xs:NOTATION</code> to <code>xs:string</code>
                always succeeds, because these values retain a
                prefix for this purpose. However, there is no
                guarantee that the prefix used will always be
                meaningful in the context where the resulting
                string is used.</p>
              </div>
            </li>

            <li>
              <p>Any consecutive sequence of strings within the
              result sequence is converted to a single text node,
              whose <a title="string value" href=
              "#dt-string-value">string value</a> contains the
              content of each of the strings in turn, with a single
              space (#x20) used as a separator between successive
              strings.</p>
            </li>

            <li>
              <p>Any document node within the result sequence is
              replaced by a sequence containing each of its
              children, in document order.</p>
            </li>

            <li>
              <p>Zero-length text nodes within the result sequence
              are removed.</p>
            </li>

            <li>
              <p>Adjacent text nodes within the result sequence are
              merged into a single text node.</p>
            </li>

            <li>
              <p>Invalid namespace and attribute nodes are detected
              as follows.</p>

              <p><a name="err-XTDE0410" id=
              "err-XTDE0410"><span class="error">[ERR
              XTDE0410]</span></a> It is a <a title=
              "non-recoverable dynamic error" href=
              "#dt-nonrec-dynamic-error">non-recoverable dynamic
              error</a> if the result sequence used to construct
              the content of an element node contains a namespace
              node or attribute node that is preceded in the
              sequence by a node that is neither a namespace node
              nor an attribute node.</p>

              <p><a name="err-XTDE0420" id=
              "err-XTDE0420"><span class="error">[ERR
              XTDE0420]</span></a> It is a <a title=
              "non-recoverable dynamic error" href=
              "#dt-nonrec-dynamic-error">non-recoverable dynamic
              error</a> if the result sequence used to construct
              the content of a document node contains a namespace
              node or attribute node.</p>

              <p><a name="err-XTDE0430" id=
              "err-XTDE0430"><span class="error">[ERR
              XTDE0430]</span></a> It is a <a title=
              "non-recoverable dynamic error" href=
              "#dt-nonrec-dynamic-error">non-recoverable dynamic
              error</a> if the result sequence contains two or more
              namespace nodes having the same name but different
              <a title="string value" href=
              "#dt-string-value">string values</a> (that is,
              namespace nodes that map the same prefix to different
              namespace URIs).</p>

              <p><a name="err-XTDE0440" id=
              "err-XTDE0440"><span class="error">[ERR
              XTDE0440]</span></a> It is a <a title=
              "non-recoverable dynamic error" href=
              "#dt-nonrec-dynamic-error">non-recoverable dynamic
              error</a> if the result sequence contains a namespace
              node with no name and the element node being
              constructed has a null namespace URI (that is, it is
              an error to define a default namespace when the
              element is in no namespace).</p>
            </li>

            <li>
              <p>If the result sequence contains two or more
              namespace nodes with the same name (or no name) and
              the same <a title="string value" href=
              "#dt-string-value">string value</a> (that is, two
              namespace nodes mapping the same prefix to the same
              namespace URI), then all but one of the duplicate
              nodes are discarded.</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>Since the order of namespace nodes is undefined,
                it is not significant which of the duplicates is
                retained.</p>
              </div>
            </li>

            <li>
              <p>If an attribute <var>A</var> in the result
              sequence has the same name as another attribute
              <var>B</var> that appears later in the result
              sequence, then attribute <var>A</var> is discarded
              from the result sequence.</p>
            </li>

            <li>
              <p>Each node in the resulting sequence is attached as
              a namespace, attribute, or child of the newly
              constructed element or document node. Conceptually
              this involves making a deep copy of the node; in
              practice, however, copying the node will only be
              necessary if the existing node can be referenced
              independently of the parent to which it is being
              attached. When copying an element or processing
              instruction node, its base URI property is changed to
              be the same as that of its new parent, unless it has
              an <code>xml:base</code> attribute (see <a href=
              "#xmlbase">[XML Base]</a>) that overrides this. If
              the <span>copied</span> element has an
              <code>xml:base</code> attribute, its base URI is the
              value of that attribute, resolved (if it is relative)
              against the base URI of the new parent node.</p>
            </li>

            <li>
              <p>If the newly constructed node is an element node,
              then namespace fixup is applied to this node, as
              described in <a href="#namespace-fixup"><i>5.7.3
              Namespace Fixup</i></a>.</p>
            </li>

            <li>
              <p>If the newly constructed node is an element node,
              and if namespaces are inherited, then each namespace
              node of the newly constructed element (including any
              produced as a result of the namespace fixup process)
              is copied to each descendant element of the newly
              constructed element, unless that element or an
              intermediate element already has a namespace node
              with the same name (or absence of a name) <span>or
              that descendant element or an intermediate element is
              in no namespace and the namespace node has no
              name</span>.</p>
            </li>
          </ol>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e9419" id="d5e9419"></a>Example: A
              Sequence Constructor for Complex Content
            </div>

            <p>Consider the following stylesheet fragment:</p>

            <div class="exampleInner">
              <pre>
&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;
</pre>
            </div>

            <p>This fragment consists of a literal result element
            <code>td</code>, containing a sequence constructor that
            consists of two instructions: <a href=
            "#element-attribute"><code>xsl:attribute</code></a> and
            <a href=
            "#element-value-of"><code>xsl:value-of</code></a>. The
            sequence constructor is evaluated to produce a sequence
            of two nodes: a parentless attribute node, and a
            parentless text node. The <code>td</code> instruction
            causes a <code>td</code> element to be created; the new
            attribute therefore becomes an attribute of the new
            <code>td</code> element, while the text node created by
            the <a href=
            "#element-value-of"><code>xsl:value-of</code></a>
            instruction becomes a child of the <code>td</code>
            element (unless it is zero-length, in which case it is
            discarded).</p>
          </div>

          <p>&#160;</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e9453" id="d5e9453"></a>Example: Space
              Separators in Element Content
            </div>

            <p>Consider the following stylesheet fragment:</p>

            <div class="exampleInner">
              <pre>
&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;
</pre>
            </div>

            <p>This produces the output (when indented):</p>

            <div class="exampleInner">
              <pre>
&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;
</pre>
            </div>

            <p>The difference between the two cases is that for the
            <code>e</code> element, the sequence constructor
            generates a sequence of five atomic values, which are
            therefore separated by spaces. For the <code>f</code>
            element, the content is a sequence of five text nodes,
            which are concatenated without space separation.</p>

            <p>It is important to be aware of the distinction
            between <a href=
            "#element-sequence"><code>xsl:sequence</code></a>,
            which returns the value of its <code>select</code>
            expression unchanged, and <a href=
            "#element-value-of"><code>xsl:value-of</code></a>,
            which constructs a text node.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="constructing-simple-content" id=
          "constructing-simple-content"></a>5.7.2 Constructing
          Simple Content</h4>

          <p>The <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-comment"><code>xsl:comment</code></a>,
          <a href=
          "#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
          <a href=
          "#element-namespace"><code>xsl:namespace</code></a><span>,
          and <a href=
          "#element-value-of"><code>xsl:value-of</code></a></span>
          elements create nodes that cannot have children.
          <span>Specifically, the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction creates an attribute node, <a href=
          "#element-comment"><code>xsl:comment</code></a> creates a
          comment node, <a href=
          "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
          creates a processing instruction node, <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          creates a namespace node, and <a href=
          "#element-value-of"><code>xsl:value-of</code></a> creates
          a text node. The string value of the new node is
          constructed using either the <code>select</code>
          attribute of the instruction, or the <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> that
          forms the content of the instruction. The
          <code>select</code> attribute allows the content to be
          specified by means of an XPath expression, while the
          sequence constructor allows it to be specified by means
          of a sequence of XSLT instructions. The
          <code>select</code> attribute or sequence constructor is
          evaluated to produce a result sequence,</span> and the
          <a title="string value" href="#dt-string-value">string
          value</a> of the new node is derived from this result
          sequence according to the rules below.</p>

          <p>These rules are also used to compute the <a title=
          "effective value" href="#dt-effective-value">effective
          value</a> of an <a title="attribute value template" href=
          "#dt-attribute-value-template">attribute value
          template</a>. In this case the sequence being processed
          is the result of evaluating an XPath expression enclosed
          between curly brackets, and the separator is a single
          space character.</p>

          <ol class="enumar">
            <li>
              <p>Zero-length text nodes in the sequence are
              discarded.</p>
            </li>

            <li>
              <p>Adjacent text nodes in the sequence are merged
              into a single text node.</p>
            </li>

            <li>
              <p>The sequence is <a title="atomize" href=
              "#dt-atomization">atomized</a>.</p>
            </li>

            <li>
              <p>Every value in the atomized sequence is cast to a
              string.</p>
            </li>

            <li>
              <p>The strings within the resulting sequence are
              concatenated, with a (possibly zero-length) separator
              inserted between successive strings. <span>The
              default separator is a single space.</span> In the
              case of <a href=
              "#element-attribute"><code>xsl:attribute</code></a>
              and <a href=
              "#element-value-of"><code>xsl:value-of</code></a>, a
              different separator can be specified using the
              <code>separator</code> attribute of the instruction;
              it is permissible for this to be a zero-length
              string, in which case the strings are concatenated
              with no separator. In the case of <a href=
              "#element-comment"><code>xsl:comment</code></a>,
              <a href=
              "#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
              and <a href=
              "#element-namespace"><code>xsl:namespace</code></a><span>
              , and when expanding an <a title=
              "attribute value template" href=
              "#dt-attribute-value-template">attribute value
              template</a></span>, the default separator cannot be
              changed.</p>
            </li>

            <li>
              <p>In the case of <a href=
              "#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
              any leading spaces in the resulting string are
              removed.</p>
            </li>

            <li>
              <p>The <span>resulting string</span> forms the
              <a title="string value" href=
              "#dt-string-value">string value</a> of the new
              attribute, namespace, comment,
              processing-instruction, or text node.</p>
            </li>
          </ol>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e9607" id="d5e9607"></a>Example: Space
              Separators in Attribute Content
            </div>

            <p>Consider the following stylesheet fragment:</p>

            <div class="exampleInner">
              <pre>
&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
&lt;/doc&gt;
</pre>
            </div>

            <p>This produces the output:</p>

            <div class="exampleInner">
              <pre>
&lt;doc e="1 2 3 4 5" f="12345"/&gt;
</pre>
            </div>

            <p>The difference between the two cases is that for the
            <code>e</code> attribute, the sequence constructor
            generates a sequence of five atomic values, which are
            therefore separated by spaces. For the <code>f</code>
            attribute, the content is supplied as a sequence of
            five text nodes, which are concatenated without space
            separation.</p>

            <p>Specifying <code>separator=""</code> on the first
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>
            instruction would cause the attribute value to be
            <code>e="12345"</code>. A <code>separator</code>
            attribute on the second <a href=
            "#element-attribute"><code>xsl:attribute</code></a>
            instruction would have no effect, since the separator
            only affects the way adjacent atomic values are
            handled: separators are never inserted between adjacent
            text nodes.</p>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>If an attribute value template contains a sequence
            of fixed and variable parts, no additional whitespace
            is inserted between the expansions of the fixed and
            variable parts. For example, the <a title=
            "effective value" href="#dt-effective-value">effective
            value</a> of the attribute <code>a="chapters{4 to
            6}"</code> is <code>a="chapters4 5 6"</code>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="namespace-fixup" id=
          "namespace-fixup"></a>5.7.3 Namespace Fixup</h4>

          <p>In a tree supplied to or constructed by an XSLT
          processor, the constraints relating to namespace nodes
          that are specified in <a href="#xpath-datamodel">[Data
          Model]</a> <span class="verb">must</span> be satisfied.
          For example</p>

          <ul>
            <li>
              <p>If an element node has an <a title=
              "expanded-QName" href=
              "#dt-expanded-qname">expanded-QName</a> with a
              non-null namespace URI, then that element node
              <span><span class="verb">must</span></span> have at
              least one namespace node whose <a title=
              "string value" href="#dt-string-value">string
              value</a> is the same as that namespace URI.</p>
            </li>

            <li>
              <p>If an element node has an attribute node whose
              <a title="expanded-QName" href=
              "#dt-expanded-qname">expanded-QName</a> has a
              non-null namespace URI, then the element <span class=
              "verb">must</span> have at least one namespace node
              whose <a title="string value" href=
              "#dt-string-value">string value</a> is the same as
              that namespace URI and whose name is non-empty.</p>
            </li>

            <li>
              <p>Every element <span class="verb">must</span> have
              a namespace node whose <a title="expanded-QName"
              href="#dt-expanded-qname">expanded-QName</a> has
              local-part <code>xml</code> and whose <a title=
              "string value" href="#dt-string-value">string
              value</a> is
              <code>http://www.w3.org/XML/1998/namespace</code>.
              The namespace prefix <code>xml</code> must not be
              associated with any other namespace URI, and the
              namespace URI
              <code>http://www.w3.org/XML/1998/namespace</code>
              must not be associated with any other prefix.</p>
            </li>

            <li>
              <p>A namespace node <span class="verb">must
              not</span> have the name <code>xmlns</code>.</p>
            </li>
          </ul>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-namespace-fixup" id="dt-namespace-fixup" title=
          "namespace fixup"></a>The rules for the individual XSLT
          instructions that construct a <a title="result tree"
          href="#dt-result-tree">result tree</a> (see <a href=
          "#creating-new-nodes"><i>11 Creating Nodes and
          Sequences</i></a>) prescribe some of the situations in
          which namespace nodes are written to the tree. These
          rules, however, are not sufficient to ensure that the
          prescribed constraints are always satisfied. The XSLT
          processor <span class="verb">must</span> therefore add
          additional namespace nodes to satisfy these constraints.
          This process is referred to as <b>namespace
          fixup</b>.<span class="definition">]</span></p>

          <p>The actual namespace nodes that are added to the tree
          by the namespace fixup process are <a title=
          "implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>,
          provided firstly, that at the end of the process the
          above constraints <span class="verb">must</span> all be
          satisfied, and secondly, that a namespace node
          <span class="verb">must not</span> be added to the tree
          unless the namespace node is necessary either to satisfy
          these constraints, or to enable the tree to be serialized
          using the original namespace prefixes from the source
          document or <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>.</p>

          <p>Namespace fixup <span class="verb">must not</span>
          result in an element having multiple namespace nodes with
          the same name.</p>

          <p>Namespace fixup <span class="verb">may</span>, if
          necessary to resolve conflicts, change the namespace
          prefix contained in the QName value that holds the name
          of an element or attribute node. <span>This includes the
          option to add or remove a prefix.</span> However,
          namespace fixup <span class="verb">must not</span> change
          the prefix component contained in a value of type
          <code>xs:QName</code> or <code>xs:NOTATION</code> that
          forms the typed value of an element or attribute
          node.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Namespace fixup is not used to create namespace
            declarations for <code>xs:QName</code> or
            <code>xs:NOTATION</code> values appearing in the
            content of an element or attribute.</p>

            <p>Where values acquire such types as the result of
            validation, namespace fixup does not come into play,
            because namespace fixup happens before validation: in
            this situation, it is the user's responsibility to
            ensure that the element being validated has the
            required namespace nodes to enable validation to
            succeed.</p>

            <p>Where existing elements are copied along with their
            existing type annotations
            (<code>validation="preserve"</code>) the rules require
            that existing namespace nodes are also copied, so that
            any namespace-sensitive values remain valid.</p>

            <p>Where existing attributes are copied along with
            their existing type annotations, the rules of the XDM
            data model require that a parentless attribute node
            cannot contain a namespace-sensitive typed value; this
            means that it is an error to copy an attribute using
            <code>validation="preserve"</code> if it contains
            namespace-sensitive content.</p>
          </div>

          <p><a name="err-XTDE0485" id="err-XTDE0485"><span class=
          "error">[ERR XTDE0485]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if namespace fixup is performed on an element
          that contains among the typed values of the element and
          its attributes two values of type <code>xs:QName</code>
          or <code>xs:NOTATION</code> containing conflicting
          namespace prefixes, that is, two values that use the same
          prefix to refer to different namespace URIs.</p>

          <p>Namespace fixup is applied to every element that is
          constructed using a <a title="literal result element"
          href="#dt-literal-result-element">literal result
          element</a>, or one of the instructions <a href=
          "#element-element"><code>xsl:element</code></a>, <a href=
          "#element-copy"><code>xsl:copy</code></a>, or <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>. An
          implementation is not <span class="verb">required</span>
          to perform namespace fixup for elements in any source
          document, that is, for a document in the initial input
          sequence, documents loaded using the <a href=
          "#function-document"><code>document</code></a>, <a href=
          "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
          <small>FO</small></sup> or <a href=
          "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
          collection</code></a><sup><small>FO</small></sup>
          function, documents supplied as the value of a <a title=
          "stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameter</a>, or
          documents returned by an <a title="extension function"
          href="#dt-extension-function">extension function</a> or
          <a title="extension instruction" href=
          "#dt-extension-instruction">extension
          instruction</a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>A source document (an input document, a document
            returned by the <a href=
            "#function-document"><code>document</code></a>,
            <a href="http://www.w3.org/TR/xpath-functions/#func-doc">
            <code>doc</code></a><sup><small>FO</small></sup> or
            <a href=
            "http://www.w3.org/TR/xpath-functions/#func-collection">
            <code>collection</code></a><sup><small>FO</small></sup>
            functions, a document returned by an extension function
            or extension instruction, or a document supplied as a
            stylesheet parameter) is required to satisfy the
            constraints described in <a href=
            "#xpath-datamodel">[Data Model]</a>, including the
            constraints imposed by the namespace fixup process. The
            effect of supplying a pseudo-document that does not
            meet these constraints is undefined.</p>
          </div>

          <p>In an Infoset (see <a href="#xml-infoset">[XML
          Information Set]</a>) created from a document conforming
          to <a href="#REC-xml-names">[Namespaces in XML 1.0]</a>,
          it will always be true that if a parent element has an
          in-scope namespace with a non-empty namespace prefix,
          then its child elements will also have an in-scope
          namespace with the same namespace prefix, though possibly
          with a different namespace URI. This constraint is
          removed in <a href="#xml-names11">[Namespaces in XML
          1.1]</a>. XSLT 2.0 supports the creation of result trees
          that do not satisfy this constraint: the namespace fixup
          process does not add a namespace node to an element
          merely because its parent node in the <a title=
          "result tree" href="#dt-result-tree">result tree</a> has
          such a namespace node. <span>However, the process of
          constructing the children of a new element, which is
          described in <a href=
          "#constructing-complex-content"><i>5.7.1 Constructing
          Complex Content</i></a>, does cause the namespaces of a
          parent element to be inherited by its children unless
          this is prevented using
          <code>[xsl:]inherit-namespaces="no"</code> on the
          instruction that creates the parent element.</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>This has implications on serialization, defined in
            <a href="#xslt-xquery-serialization">[XSLT and XQuery
            Serialization]</a>. It means that it is possible to
            create <a title="final result tree" href=
            "#dt-final-result-tree">final result trees</a> that
            cannot be faithfully serialized as XML 1.0 documents.
            When such a result tree is serialized as XML 1.0,
            namespace declarations written for the parent element
            will be inherited by its child elements as if the
            corresponding namespace nodes were present on the child
            element<span>, except in the case of the default
            namespace, which can be undeclared using the construct
            <code>xmlns=""</code></span>. When the same result tree
            is serialized as XML 1.1, however, it is possible to
            undeclare any namespace on the child element <span>(for
            example, <code>xmlms:foo=""</code>)</span> to prevent
            this inheritance taking place.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="uri-references" id="uri-references"></a>5.8
        URI References</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-uri-reference" id="dt-uri-reference" title=
        "URI Reference"></a>Within this specification, the term
        <b>URI Reference</b>, unless otherwise stated, refers to a
        string in the lexical space of the <code>xs:anyURI</code>
        data type as defined in <a href="#xmlschema-2">[XML Schema
        Part 2]</a>.<span class="definition">]</span> Note that
        this is a wider definition than that in <a href=
        "#RFC3986">[RFC3986]</a>: <span>in particular, it is
        designed to accommodate Internationalized Resource
        Identifiers (IRIs) as described in <a href=
        "#RFC3987">[RFC3987]</a>, and thus allows the use of
        non-ASCII characters without escaping.</span></p>

        <p>URI References are used in XSLT with three main
        roles:</p>

        <blockquote>
          <p>As namespace URIs<br />
          As collation URIs<br />
          As identifiers for resources such as stylesheet modules;
          these resources are typically accessible using a protocol
          such as HTTP. Examples of such identifiers are the URIs
          used in the <code>href</code> attributes of <a href=
          "#element-import"><code>xsl:import</code></a>, <a href=
          "#element-include"><code>xsl:include</code></a>, and
          <a href=
          "#element-result-document"><code>xsl:result-document</code></a>.</p>
        </blockquote>

        <p>The rules for namespace URIs are given in <a href=
        "#REC-xml-names">[Namespaces in XML 1.0]</a> and <a href=
        "#xml-names11">[Namespaces in XML 1.1]</a>. Those
        specifications deprecate the use of relative URIs as
        namespace URIs.</p>

        <p>The rules for collation URIs are given in <a href=
        "#xpath-functions">[Functions and Operators]</a>.</p>

        <p>URI references used to identify external resources must
        conform to the same rules as the locator attribute
        (<code>href</code>) defined in section 5.4 of <a href=
        "#xlink">[XLink]</a>. If the URI reference is relative,
        then it is resolved (unless otherwise specified) against
        the base URI of the containing element node, according to
        the rules of <span><a href="#RFC3986">[RFC3986]</a></span>,
        after first escaping all characters that need to be escaped
        to make it a valid RFC3986 URI reference. (But a relative
        URI in the <code>href</code> attribute of <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        is resolved against the <a title="base output URI" href=
        "#dt-base-output-uri">Base Output URI</a>.)</p>

        <p>Other URI references appearing in an XSLT stylesheet
        document, for example the system identifiers of external
        entities or the value of the <code>xml:base</code>
        attribute, must follow the rules in their respective
        specifications.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="rules" id="rules"></a>6 Template Rules</h2>

      <p>Template rules define the processing that can be applied
      to nodes that match a particular <a title="pattern" href=
      "#dt-pattern">pattern</a>.</p>

      <div class="div2">
        <h3><a name="defining-templates" id=
        "defining-templates"></a>6.1 Defining Templates</h3>

        <p class="element-syntax"><a name="element-template" id=
        "element-template"></a><code>&lt;!-- Category: declaration
        --&gt;<br />
        &lt;xsl:template<br />
        &#160;&#160;match? = <var>pattern</var><br />
        &#160;&#160;name? = <var>qname</var><br />
        &#160;&#160;priority? = <var>number</var><br />
        &#160;&#160;mode? = <var>tokens</var><br />
        &#160;&#160;as? = <var>sequence-type</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-param">xsl:param</a>*,
        <var>sequence-constructor</var>) --&gt;<br />
        &lt;/xsl:template&gt;</code></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-template"
        id="dt-template" title="template"></a>An <a href=
        "#element-template"><code>xsl:template</code></a>
        declaration defines a <b>template</b>, which contains a
        <span><a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a></span>
        for creating nodes and/or atomic values. A template can
        serve either as a <a title="template rule" href=
        "#dt-template-rule">template rule</a>, invoked by matching
        nodes against a <a title="pattern" href=
        "#dt-pattern">pattern</a>, or as a <a title=
        "named template" href="#dt-named-template">named
        template</a>, invoked explicitly by name. It is also
        possible for the same template to serve in both
        capacities.<span class="definition">]</span></p>

        <p><a name="err-XTSE0500" id="err-XTSE0500"><span class=
        "error">[ERR XTSE0500]</span></a> An <a href=
        "#element-template"><code>xsl:template</code></a> element
        <span class="verb">must</span> have either a
        <code>match</code> attribute or a <code>name</code>
        attribute, or both. An <a href=
        "#element-template"><code>xsl:template</code></a> element
        that has no <code>match</code> attribute <span class=
        "verb">must</span> have no <code>mode</code> attribute and
        no <code>priority</code> attribute.</p>

        <p>If an <a href=
        "#element-template"><code>xsl:template</code></a> element
        has a <code>match</code> attribute, then it is a <a title=
        "template rule" href="#dt-template-rule">template rule</a>.
        If it has a <code>name</code> attribute, then it is a
        <a title="named template" href="#dt-named-template">named
        template</a>.</p>

        <p>A <a title="template" href="#dt-template">template</a>
        may be invoked in a number of ways, depending on whether it
        is a <a title="template rule" href=
        "#dt-template-rule">template rule</a>, a <a title=
        "named template" href="#dt-named-template">named
        template</a>, or both. The result of invoking the template
        is the result of evaluating the <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        contained in the <a href=
        "#element-template"><code>xsl:template</code></a> element
        (see <a href="#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>).</p>

        <p>If an <code>as</code> attribute is present, the
        <code>as</code> attribute defines the required type of the
        result. The result of evaluating the <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> is then
        converted to the required type using the <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>. If no <code>as</code> attribute is specified,
        the default value is <code>item()*</code>, which permits
        any value. No conversion then takes place.</p>

        <p><a name="err-XTTE0505" id="err-XTTE0505"><span class=
        "error">[ERR XTTE0505]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        result of evaluating the <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>
        cannot be converted to the required type.</p>
      </div>

      <div class="div2">
        <h3><a name="defining-template-rules" id=
        "defining-template-rules"></a>6.2 Defining Template
        Rules</h3>

        <p>This section describes <a title="template rule" href=
        "#dt-template-rule">template rules</a>. <a title=
        "named template" href="#dt-named-template">Named
        templates</a> are described in <a href=
        "#named-templates"><i>10.1 Named Templates</i></a>.</p>

        <p>A <a title="template rule" href=
        "#dt-template-rule">template rule</a> is specified using
        the <a href=
        "#element-template"><code>xsl:template</code></a> element
        <span>with a <code>match</code> attribute</span>. The
        <code>match</code> attribute is a <a href=
        "#NT-Pattern">Pattern</a> that identifies the node or nodes
        to which the rule applies. The result of applying the
        template rule is the result of evaluating the
        <span>sequence</span> constructor contained in the <a href=
        "#element-template"><code>xsl:template</code></a> element,
        with the matching node used as the <a title="context node"
        href="#dt-context-node">context node</a>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10170" id="d5e10170"></a>Example: A simple
            Template Rule
          </div>

          <p>For example, an XML document might contain:</p>

          <div class="exampleInner">
            <pre>
This is an &lt;emph&gt;important&lt;/emph&gt; point.
</pre>
          </div>

          <p>The following <a title="template rule" href=
          "#dt-template-rule">template rule</a> matches
          <code>emph</code> elements and produces a
          <code>fo:wrapper</code> element with a
          <code>font-weight</code> property of
          <code>bold</code>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>A <a title="template rule" href=
        "#dt-template-rule">template rule</a> is evaluated when an
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction selects a node that matches the pattern
        specified in the <code>match</code> attribute. The <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction is described in the next section. If several
        template rules match a selected node, only one of them is
        evaluated, as described in <a href="#conflict"><i>6.4
        Conflict Resolution for Template Rules</i></a>.</p>
      </div>

      <div class="div2">
        <h3><a name="applying-templates" id=
        "applying-templates"></a>6.3 Applying Template Rules</h3>

        <p class="element-syntax"><a name="element-apply-templates"
        id="element-apply-templates"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:apply-templates<br />
        &#160;&#160;select? = <var>expression</var><br />
        &#160;&#160;mode? = <var>token</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-sort">xsl:sort</a> | <a href=
        "#element-with-param">xsl:with-param</a>)* --&gt;<br />
        &lt;/xsl:apply-templates&gt;</code></p>

        <p>The <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction takes as input a sequence of nodes (typically
        nodes in a <a title="source tree" href=
        "#dt-source-tree">source tree</a>), and produces as output
        a sequence of items; these will often be nodes to be added
        to a <a title="result tree" href="#dt-result-tree">result
        tree</a>.</p>

        <p>If the instruction has one or more <a href=
        "#element-sort"><code>xsl:sort</code></a> children, then
        the input sequence is sorted as described in <a href=
        "#sorting"><i>13 Sorting</i></a>. The result of this sort
        is referred to below as the <b>sorted sequence</b>; if
        there are no <a href=
        "#element-sort"><code>xsl:sort</code></a> elements, then
        the sorted sequence is the same as the input sequence.</p>

        <p>Each node in the input sequence is processed by finding
        a <a title="template rule" href=
        "#dt-template-rule">template rule</a> whose <a title=
        "pattern" href="#dt-pattern">pattern</a> matches that node.
        If there is more than one, the best among them is chosen,
        using rules described in <a href="#conflict"><i>6.4
        Conflict Resolution for Template Rules</i></a>. If there is
        no template rule whose pattern matches the node, a built-in
        template rule is used (see <a href="#built-in-rule"><i>6.6
        Built-in Template Rules</i></a>). The chosen template rule
        is evaluated. The rule that matches the <var>N</var>th node
        in the sorted sequence is evaluated with that node as the
        <a title="context item" href="#dt-context-item">context
        item</a>, with <var>N</var> as the <a title=
        "context position" href="#dt-context-position">context
        position</a>, and with the length of the sorted sequence as
        the <a title="context size" href="#dt-context-size">context
        size</a>. Each template rule that is evaluated produces a
        sequence of items as its result. The resulting sequences
        (one for each node in the sorted sequence) are then
        concatenated, to form a single sequence. They are
        concatenated retaining the order of the nodes in the sorted
        sequence. The final concatenated sequence forms the result
        of the <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10281" id="d5e10281"></a>Example: Applying
            Template Rules
          </div>

          <p>Suppose the source document is as follows:</p>

          <div class="exampleInner">
            <pre>
&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;
</pre>
          </div>

          <p>This can be processed using the two template rules
          shown below.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>There is no template rule for the document node; the
          built-in template rule for this node will cause the
          <code>message</code> element to be processed. The
          template rule for the <code>message</code> element causes
          a <code>p</code> element to be written to the <a title=
          "result tree" href="#dt-result-tree">result tree</a>; the
          contents of this <code>p</code> element are constructed
          as the result of the <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction. This instruction selects the three child
          nodes of the <code>message</code> element (a text node
          containing the value "<code>Proceed</code> ", an
          <code>emph</code> element node, and a text node
          containing the value " <code>to the exit!</code>"). The
          two text nodes are processed using the built-in template
          rule for text nodes, which returns a copy of the text
          node. The <code>emph</code> element is processed using
          the explicit template rule that specifies
          <code>match="emph"</code>.</p>

          <p>When the <code>emph</code> element is processed, this
          template rule constructs a <code>b</code> element. The
          contents of the <code>b</code> element are constructed by
          means of another <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction, which in this case selects a single node
          (the text node containing the value "<code>at
          once</code>"). This is again processed using the built-in
          template rule for text nodes, which returns a copy of the
          text node.</p>

          <p>The final result of the <code>match="message"</code>
          template rule thus consists of a <code>p</code> element
          node with three children: a text node containing the
          value "<code>Proceed</code> ", a <code>b</code> element
          that is the parent of a text node containing the value
          "<code>at once</code>", and a text node containing the
          value " <code>to the exit!</code>". This <a title=
          "result tree" href="#dt-result-tree">result tree</a>
          might be serialized as:</p>

          <div class="exampleInner">
            <pre>
&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;
</pre>
          </div>
        </div>

        <p>The default value of the <code>select</code> attribute
        is <code>child::node()</code>, which causes all the
        children of context node to be processed.</p>

        <p><a name="err-XTTE0510" id="err-XTTE0510"><span class=
        "error">[ERR XTTE0510]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if an
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction with no <code>select</code> attribute is
        evaluated when the <a title="context item" href=
        "#dt-context-item">context item</a> is not a node.</p>

        <p>A <code>select</code> attribute can be used to process
        nodes selected by an expression instead of processing all
        children. The value of the <code>select</code> attribute is
        an <a title="expression" href=
        "#dt-expression">expression</a>. The expression
        <span class="verb">must</span> evaluate to a sequence of
        nodes (it can contain zero, one, or more nodes).</p>

        <p><a name="err-XTTE0520" id="err-XTTE0520"><span class=
        "error">[ERR XTTE0520]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        sequence returned by the <code>select</code> expression
        contains an item that is not a node.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>In XSLT 1.0, the <code>select</code> attribute
          selected a set of nodes, which by default were processed
          in document order. In XSLT 2.0, it selects a sequence of
          nodes. In cases that would have been valid in XSLT 1.0,
          the expression will return a sequence of nodes in
          document order, so the effect is the same.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10435" id="d5e10435"></a>Example: Applying
            Templates to Selected Nodes
          </div>

          <p>The following example processes all of the
          <code>given-name</code> children of the
          <code>author</code> elements that are children of
          <code>author-group</code>:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10451" id="d5e10451"></a>Example: Applying
            Templates to Nodes that are not Descendants
          </div>

          <p>It is also possible to process elements that are not
          descendants of the context node. This example assumes
          that a <code>department</code> element has
          <code>group</code> children and <code>employee</code>
          descendants. It finds an employee's department and then
          processes the <code>group</code> children of the
          <code>department</code>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10473" id="d5e10473"></a>Example: Matching
            by Schema-Defined Types
          </div>

          <p>It is possible to write template rules that are
          matched according to the schema-defined type of an
          element or attribute. The following example applies
          different formatting to the children of an element
          depending on their type:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The <a href=
          "#element-next-match"><code>xsl:next-match</code></a>
          instruction is described in <a href=
          "#apply-imports"><i>6.7 Overriding Template
          Rules</i></a>.</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10487" id="d5e10487"></a>Example:
            Re-ordering Elements in the Result Tree
          </div>

          <p>Multiple <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          elements can be used within a single template to do
          simple reordering. The following example creates two HTML
          tables. The first table is filled with domestic sales
          while the second table is filled with foreign sales.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e10497" id="d5e10497"></a>Example:
            Processing Recursive Structures
          </div>

          <p>It is possible for there to be two matching
          descendants where one is a descendant of the other. This
          case is not treated specially: both descendants will be
          processed as usual.</p>

          <p>For example, given a source document</p>

          <div class="exampleInner">
            <pre>
&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;
</pre>
          </div>

          <p>the rule</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>will process both the outer <code>div</code> and inner
          <code>div</code> elements.</p>

          <p>This means that if the template rule for the
          <code>div</code> element processes its own children, then
          these grandchildren will be processed more than once,
          which is probably not what is required. The solution is
          to process one level at a time in a recursive descent, by
          using <code>select="div"</code> in place of
          <code>select=".//div"</code></p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p><span>The <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction is most commonly used</span> to process nodes
          that are descendants of the context node. Such use of
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          cannot result in non-terminating processing loops.
          However, when <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          is used to process elements that are not descendants of
          the context node, the possibility arises of
          non-terminating loops. For example,</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>Implementations may be able to detect such loops in
          some cases, but the possibility exists that a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> may
          enter a non-terminating loop that an implementation is
          unable to detect. This may present a denial of service
          security risk.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="conflict" id="conflict"></a>6.4 Conflict
        Resolution for Template Rules</h3>

        <p>It is possible for a node in a source document to match
        more than one <a title="template rule" href=
        "#dt-template-rule">template rule</a>. <span>When this
        happens, only one template rule is evaluated for the
        node.</span> The template rule to be used is determined as
        follows:</p>

        <ol class="enumar">
          <li>
            <p>First, only the matching template rule or rules with
            the highest <a title="import precedence" href=
            "#dt-import-precedence">import precedence</a> are
            considered. Other matching template rules with lower
            precedence are eliminated from consideration.</p>
          </li>

          <li>
            <p>Next, of the remaining matching rules, only those
            with the highest priority are considered. Other
            matching template rules with lower priority are
            eliminated from consideration. The priority of a
            template rule is specified by the <code>priority</code>
            attribute on the <a href=
            "#element-template"><code>xsl:template</code></a>
            declaration.</p>

            <p><a name="err-XTSE0530" id=
            "err-XTSE0530"><span class="error">[ERR
            XTSE0530]</span></a> The value of this attribute
            <span class="verb">must</span> <span>conform to the
            rules for the <code>xs:decimal</code> type defined in
            <a href="#xmlschema-2">[XML Schema Part 2]</a>.
            Negative values are permitted.</span>.</p>

            <p><span class=
            "definition">[Definition:&#160;</span><a name=
            "dt-default-priority" id="dt-default-priority" title=
            "default priority"></a>If no <code>priority</code>
            attribute is specified on the <a href=
            "#element-template"><code>xsl:template</code></a>
            element, a <b>default priority</b> is computed, based
            on the syntax of the pattern supplied in the
            <code>match</code> attribute.<span class=
            "definition">]</span> The rules are as follows:</p>

            <ul>
              <li>
                <p>If the pattern contains multiple alternatives
                separated by <code>|</code> , then the template
                rule is treated equivalently to a set of template
                rules, one for each alternative. However, it is not
                an error if a node matches more than one of the
                alternatives.</p>
              </li>

              <li>
                <p>If the pattern has the form <code>/</code>, then
                the priority is −0.5.</p>
              </li>

              <li>
                <p>If the pattern has the form of a <a title=
                "QName" href="#dt-qname">QName</a> optionally
                preceded by a <a href=
                "#NT-PatternAxis">PatternAxis</a> or has the form
                <code>processing-instruction(</code><a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-StringLiteral">
                StringLiteral</a><sup><small>XP</small></sup><code>)</code>
                or <code>processing-instruction(</code><a href=
                "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
                <small>Names</small></sup><code>)</code> optionally
                preceded by a <a href=
                "#NT-PatternAxis">PatternAxis</a>, then the
                priority is 0.</p>
              </li>

              <li>
                <p>If the pattern has the form of an <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">
                ElementTest</a><sup><small>XP</small></sup> or
                <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-AttributeTest">
                AttributeTest</a><sup><small>XP</small></sup>,
                optionally preceded by a <a href=
                "#NT-PatternAxis">PatternAxis</a>, then the
                priority is as shown in the table below. In this
                table, the symbols <var>E</var>, <var>A</var>, and
                <var>T</var> represent an arbitrary element name,
                attribute name, and type name respectively, while
                the symbol <code>*</code> represents itself. The
                presence or absence of the <span>symbol
                <code>?</code> following a type name</span> does
                not affect the priority.</p>

                <table border="1" cellpadding="5">
                  <thead>
                    <tr>
                      <th align="left">Format</th>

                      <th align="left">Priority</th>

                      <th align="left">Notes</th>
                    </tr>
                  </thead>

                  <tbody>
                    <tr>
                      <td><code>element()</code></td>

                      <td>−0.5</td>

                      <td>(equivalent to <code>*</code>)</td>
                    </tr>

                    <tr>
                      <td><code>element(*)</code></td>

                      <td>−0.5</td>

                      <td>(equivalent to <code>*</code>)</td>
                    </tr>

                    <tr>
                      <td><code>attribute()</code></td>

                      <td>−0.5</td>

                      <td>(equivalent to <code>@*</code>)</td>
                    </tr>

                    <tr>
                      <td><code>attribute(*)</code></td>

                      <td>−0.5</td>

                      <td>(equivalent to <code>@*</code>)</td>
                    </tr>

                    <tr>
                      <td><code>element(<var>E</var>)</code></td>

                      <td>0</td>

                      <td>(equivalent to E)</td>
                    </tr>

                    <tr>
                      <td><code>element(*,<var>T</var>)</code></td>

                      <td>0</td>

                      <td>(matches by type only)</td>
                    </tr>

                    <tr>
                      <td><code>attribute(<var>A</var>)</code></td>

                      <td>0</td>

                      <td>(equivalent to <code>@A</code>)</td>
                    </tr>

                    <tr>
                      <td>
                      <code>attribute(*,<var>T</var>)</code></td>

                      <td>0</td>

                      <td>(matches by type only)</td>
                    </tr>

                    <tr>
                      <td>
                      <code>element(<var>E</var>,<var>T</var>)</code></td>

                      <td>0.25</td>

                      <td>(matches by name and type)</td>
                    </tr>

                    <tr>
                      <td>
                      <code>schema-element(<var>E</var>)</code></td>

                      <td>0.25</td>

                      <td>(matches by substitution group and
                      type)</td>
                    </tr>

                    <tr>
                      <td>
                      <code>attribute(<var>A</var>,<var>T</var>)</code></td>

                      <td>0.25</td>

                      <td>(matches by name and type)</td>
                    </tr>

                    <tr>
                      <td>
                      <code>schema-attribute(<var>A</var>)</code></td>

                      <td>0.25</td>

                      <td>(matches by name and type)</td>
                    </tr>
                  </tbody>
                </table>
              </li>

              <li>
                <p>If the pattern has the form of a <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-DocumentTest">
                DocumentTest</a><sup><small>XP</small></sup>, then
                if it includes no <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">
                ElementTest</a><sup><small>XP</small></sup>
                <span>or <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">
                SchemaElementTest</a><sup><small>XP</small></sup></span>
                the priority is −0.5. If it does include an
                <a href="http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">
                ElementTest</a><sup><small>XP</small></sup>
                <span>or <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">
                SchemaElementTest</a><sup><small>XP</small></sup></span>,
                then the priority is the same as the priority of
                that <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-ElementTest">
                ElementTest</a><sup><small>XP</small></sup>
                <span>or <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-SchemaElementTest">
                SchemaElementTest</a><sup><small>XP</small></sup></span>,
                computed according to the table above.</p>
              </li>

              <li>
                <p>If the pattern has the form <a href=
                "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
                <small>Names</small></sup><code>:*</code> or
                <code>*:</code><a href=
                "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
                <small>Names</small></sup>, optionally preceded by
                a <a href="#NT-PatternAxis">PatternAxis</a>, then
                the priority is −0.25.</p>
              </li>

              <li>
                <p>If the pattern is any other <a href=
                "http://www.w3.org/TR/xpath20/#doc-xpath-NodeTest">NodeTest</a><sup>
                <small>XP</small></sup>, optionally preceded by a
                <a href="#NT-PatternAxis">PatternAxis</a>, then the
                priority is −0.5.</p>
              </li>

              <li>
                <p>Otherwise, the priority is 0.5.</p>
              </li>
            </ul>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>In many cases this means that highly selective
              patterns have higher priority than less selective
              patterns. The most common kind of pattern (a pattern
              that tests for a node of a <span>particular kind,
              with a particular <a title="expanded-QName" href=
              "#dt-expanded-qname">expanded-QName</a> or a
              particular type)</span> has priority 0. The next less
              specific kind of pattern (a pattern that tests for a
              node of a particular kind and an <a title=
              "expanded-QName" href=
              "#dt-expanded-qname">expanded-QName</a> with a
              particular namespace URI) has priority −0.25.
              Patterns less specific than this (patterns that just
              test for nodes <span>of a given kind</span>) have
              priority −0.5. <span>Patterns that specify both the
              name and the required type have a priority of +0.25,
              putting them above patterns that only specify the
              name <em>or</em> the type.</span> Patterns more
              specific than <span>this, for example patterns that
              include predicates or that specify the ancestry of
              the required node,</span> have priority 0.5.</p>

              <p>However, it is not invariably true that a more
              selective pattern has higher priority than a less
              selective pattern. For example, the priority of the
              pattern <code>node()[self::*]</code> is higher than
              that of the pattern <code>salary</code>.
              <span>Similarly, the patterns <code>attribute(*,
              xs:decimal)</code> and <code>attribute(*,
              xs:short)</code> have the same priority, despite the
              fact that the latter pattern matches a subset of the
              nodes matched by the former.</span> Therefore, to
              achieve clarity in a <a title="stylesheet" href=
              "#dt-stylesheet">stylesheet</a> it is good practice
              to allocate explicit priorities.</p>
            </div>
          </li>
        </ol>

        <p><a name="err-XTRE0540" id="err-XTRE0540"><span class=
        "error">[ERR XTRE0540]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> if
        the conflict resolution algorithm for template rules leaves
        more than one matching template rule. The <a title=
        "optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is to select, from the matching template rules that are
        left, the one that occurs last in <a title=
        "declaration order" href=
        "#dt-declaration-order">declaration order</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="modes" id="modes"></a>6.5 Modes</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-mode" id=
        "dt-mode" title="mode"></a><b>Modes</b> allow a node in a
        <a title="source tree" href="#dt-source-tree">source
        tree</a> to be processed multiple times, each time
        producing a different result. They also allow different
        sets of <a title="template rule" href=
        "#dt-template-rule">template rules</a> to be active when
        processing different trees, for example when processing
        documents loaded using the <a href=
        "#function-document"><code>document</code></a> function
        (see <a href="#document"><i>16.1 Multiple Source
        Documents</i></a>) or when processing <a title=
        "temporary tree" href="#dt-temporary-tree">temporary
        trees</a>.<span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-default-mode" id="dt-default-mode" title=
        "default mode"></a>There is always a <b>default mode</b>
        available. The default mode is an unnamed <a title="mode"
        href="#dt-mode">mode</a>, and it is used when no
        <code>mode</code> attribute is specified on an <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction.<span class="definition">]</span></p>

        <p>Every <a title="mode" href="#dt-mode">mode</a> other
        than the <a title="default mode" href=
        "#dt-default-mode">default mode</a> is identified by a
        <a title="QName" href="#dt-qname">QName</a>.</p>

        <p>A <a title="template rule" href=
        "#dt-template-rule">template rule</a> is applicable to one
        or more modes. The modes to which it is applicable are
        defined by the <code>mode</code> attribute of the <a href=
        "#element-template"><code>xsl:template</code></a> element.
        If the attribute is omitted, then the template rule is
        applicable to the <a title="default mode" href=
        "#dt-default-mode">default mode</a>. If the attribute is
        present, then its value <span class="verb">must</span> be a
        non-empty whitespace-separated list of tokens, each of
        which defines a mode to which the template rule is
        applicable. Each token <span class="verb">must</span> be
        one of the following:</p>

        <ul>
          <li>
            <p>a <a title="QName" href="#dt-qname">QName</a>, which
            is expanded as described in <a href="#qname"><i>5.1
            Qualified Names</i></a> to define the name of the
            mode</p>
          </li>

          <li>
            <p>the token <code>#default</code>, to indicate that
            the template rule is applicable to the <a title=
            "default mode" href="#dt-default-mode">default
            mode</a></p>
          </li>

          <li>
            <p>the token <code>#all</code>, to indicate that the
            template rule is applicable to all modes <span>(that
            is, to the default mode and to every mode that is named
            in an <a href=
            "#element-apply-templates"><code>xsl:apply-templates</code></a>
            instruction or <a href=
            "#element-template"><code>xsl:template</code></a>
            declaration anywhere in the stylesheet)</span>.</p>
          </li>
        </ul>

        <p><a name="err-XTSE0550" id="err-XTSE0550"><span class=
        "error">[ERR XTSE0550]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the list is empty, if the same token is included more than
        once in the list, if the list contains an invalid token, or
        if the token <code>#all</code> appears together with any
        other value.</p>

        <p>The <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        element also has an optional <code>mode</code> attribute.
        The value of this attribute <span class="verb">must</span>
        either be a <a title="QName" href="#dt-qname">QName</a>,
        which is expanded as described in <a href="#qname"><i>5.1
        Qualified Names</i></a> to define the name of a mode, or
        the token <code>#default</code>, to indicate that the
        <a title="default mode" href="#dt-default-mode">default
        mode</a> is to be used, or the token <code>#current</code>,
        to indicate that the <a title="current mode" href=
        "#dt-current-mode">current mode</a> is to be used. If the
        attribute is omitted, the <a title="default mode" href=
        "#dt-default-mode">default mode</a> is used.</p>

        <p>When searching for a template rule to process each node
        selected by the <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction, only those template rules that are applicable
        to the selected mode are considered.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-current-mode" id="dt-current-mode" title=
        "current mode"></a>At any point in the processing of a
        stylesheet, there is a <b>current mode</b>. When the
        transformation is initiated, the current mode is the
        <a title="default mode" href="#dt-default-mode">default
        mode</a>, <span>unless a different initial mode has been
        supplied, as described in <a href="#initiating"><i>2.3
        Initiating a Transformation</i></a>.</span> Whenever an
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction is evaluated, the current mode becomes the mode
        selected by this instruction.<span class=
        "definition">]</span> When a stylesheet function is called,
        the current mode becomes the <a title="default mode" href=
        "#dt-default-mode">default mode</a>. No other instruction
        changes the current mode. On completion of the <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction, <span>or on return from a stylesheet function
        call,</span> the current mode reverts to its previous
        value. The current mode is used when an <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction uses the syntax <code>mode="#current"</code>;
        it is also used by the <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        <span>and <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>
        instructions (see <a href="#apply-imports"><i>6.7
        Overriding Template Rules</i></a>).</p>
      </div>

      <div class="div2">
        <h3><a name="built-in-rule" id="built-in-rule"></a>6.6
        Built-in Template Rules</h3>

        <p>When a node is selected by <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        and there is no template rule in the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> that can be used to
        process that node, a built-in template rule is evaluated
        instead.</p>

        <p>The built-in template rules apply to all modes.</p>

        <p>The built-in rule for document nodes and element nodes
        is equivalent to calling <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        with no <code>select</code> attribute, and with the
        <code>mode</code> attribute set to <code>#current</code>.
        If the built-in rule was invoked with parameters, those
        parameters are passed on in the implicit <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e11192" id="d5e11192"></a>Example: Using a
            Built-In Template Rule
          </div>

          <p>For example, suppose the stylesheet contains the
          following instruction:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:apply-templates select="title" mode="mm"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;
</pre>
          </div>

          <p>If there is no explicit template rule that matches the
          <code>title</code> element, then the following implicit
          rule is used:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="title" mode="#all"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>The built-in <a title="template rule" href=
        "#dt-template-rule">template rule</a> for text and
        attribute nodes returns a text node containing the
        <a title="string value" href="#dt-string-value">string
        value</a> of the context node. It is effectively:</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:template match="text()|@*" mode="#all"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;
</pre>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This text node may have a string value that is
          zero-length.</p>
        </div>

        <p>The built-in <a title="template rule" href=
        "#dt-template-rule">template rule</a> for processing
        instructions and comments does nothing (it returns the
        empty sequence).</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:template match="processing-instruction()|comment()" mode="#all"/&gt;
</pre>
        </div>

        <p>The built-in <a title="template rule" href=
        "#dt-template-rule">template rule</a> for namespace nodes
        is also to do nothing. There is no pattern that can match a
        namespace node, <span>so the built-in template rule is
        always used when <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        selects a namespace node.</span></p>

        <p>The built-in <a title="template rule" href=
        "#dt-template-rule">template rules</a> have lower <a title=
        "import precedence" href="#dt-import-precedence">import
        precedence</a> than all other template rules. Thus, the
        stylesheet author can override a built-in template rule by
        including an explicit template rule.</p>
      </div>

      <div class="div2">
        <h3><a name="apply-imports" id="apply-imports"></a>6.7
        Overriding Template Rules</h3>

        <p class="element-syntax"><a name="element-apply-imports"
        id="element-apply-imports"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:apply-imports&gt;<br />
        &#160;&#160;&lt;!-- Content: <a href=
        "#element-with-param">xsl:with-param</a>* --&gt;<br />
        &lt;/xsl:apply-imports&gt;</code></p>

        <p class="element-syntax"><a name="element-next-match" id=
        "element-next-match"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:next-match&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-with-param">xsl:with-param</a> | <a href=
        "#element-fallback">xsl:fallback</a>)* --&gt;<br />
        &lt;/xsl:next-match&gt;</code></p>

        <p>A <a title="template rule" href=
        "#dt-template-rule">template rule</a> that is being used to
        override another template rule (see <a href=
        "#conflict"><i>6.4 Conflict Resolution for Template
        Rules</i></a>) can use the <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        or <a href=
        "#element-next-match"><code>xsl:next-match</code></a>
        instruction to invoke the overridden template rule. The
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        instruction only considers template rules in imported
        stylesheet modules; the <a href=
        "#element-next-match"><code>xsl:next-match</code></a>
        instruction considers all other template rules of lower
        <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a> and/or
        priority. <span>Both instructions will invoke the built-in
        template rule for the node (see <a href=
        "#built-in-rule"><i>6.6 Built-in Template Rules</i></a>) if
        no other template rule is found.</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-current-template-rule" id="dt-current-template-rule"
        title="current template rule"></a>At any point in the
        processing of a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>, there may be a <b>current
        template rule</b>. Whenever a <a title="template rule"
        href="#dt-template-rule">template rule</a> is chosen
        <span>as a result of evaluating <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>,
        or <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>,
        the template rule becomes the current template rule for the
        evaluation of the rule's sequence constructor. When an
        <a href="#element-for-each"><code>xsl:for-each</code></a>,
        <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>,
        <span>or <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction is evaluated, or when evaluating a sequence
        constructor contained in an <a href=
        "#element-sort"><code>xsl:sort</code></a> or <a href=
        "#element-key"><code>xsl:key</code></a> element, or
        when</span> a <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> is called
        (see <a href="#stylesheet-functions"><i>10.3 Stylesheet
        Functions</i></a>), the current template rule becomes null
        for the evaluation of that instruction or
        function.<span class="definition">]</span></p>

        <p>The current template rule is not affected by invoking
        named templates (see <a href="#named-templates"><i>10.1
        Named Templates</i></a>) or named attribute sets (see
        <a href="#attribute-sets"><i>10.2 Named Attribute
        Sets</i></a>). While evaluating a <a title=
        "global variable" href="#dt-global-variable">global
        variable</a> <span>or the default value of a <a title=
        "stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameter</a></span>
        (see <a href="#global-variables"><i>9.5 Global Variables
        and Parameters</i></a>) the current template rule is
        null.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>These rules ensure that when <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>
          or <a href=
          "#element-next-match"><code>xsl:next-match</code></a> is
          called, the <a title="context item" href=
          "#dt-context-item">context item</a> is the same as when
          the current template rule was invoked, and is always a
          node.</p>
        </div>

        <p><span>Both <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        and <a href=
        "#element-next-match"><code>xsl:next-match</code></a>
        search</span> for a <a title="template rule" href=
        "#dt-template-rule">template rule</a> that matches the
        <a title="context node" href="#dt-context-node">context
        node</a>, and that is applicable to the <a title=
        "current mode" href="#dt-current-mode">current mode</a>
        (see <a href="#modes"><i>6.5 Modes</i></a>). In choosing a
        template rule, <span>they use</span> the usual criteria
        such as the priority and <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a> of the
        template rules, but <span>they consider as candidates only
        a subset of the template rules in the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a>. This subset differs
        between the two instructions:</span></p>

        <ul>
          <li>
            <p>The <a href=
            "#element-apply-imports"><code>xsl:apply-imports</code></a>
            instruction considers as candidates only those template
            rules contained in <a title="stylesheet level" href=
            "#dt-stylesheet-level">stylesheet levels</a> that are
            descendants in the <a title="import tree" href=
            "#dt-import-tree">import tree</a> of the <a title=
            "stylesheet level" href=
            "#dt-stylesheet-level">stylesheet level</a> that
            contains the <a title="current template rule" href=
            "#dt-current-template-rule">current template
            rule</a>.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>This is <em>not</em> the same as saying that the
              search considers all template rules whose import
              precedence is lower than that of the current template
              rule.</p>
            </div>
          </li>

          <li>
            <p>The <a href=
            "#element-next-match"><code>xsl:next-match</code></a>
            instruction considers as candidates all those template
            rules that come after the <a title=
            "current template rule" href=
            "#dt-current-template-rule">current template rule</a>
            in the ordering of template rules implied by the
            conflict resolution rules given in <a href=
            "#conflict"><i>6.4 Conflict Resolution for Template
            Rules</i></a>. That is, it considers all template rules
            with lower <a title="import precedence" href=
            "#dt-import-precedence">import precedence</a> than the
            <a title="current template rule" href=
            "#dt-current-template-rule">current template rule</a>,
            plus the template rules that are at the same import
            precedence that have lower priority than the current
            template rule. If the processor has recovered from the
            error that occurs when two matching template rules have
            the same import precedence and priority, then it also
            considers all matching template rules with the same
            import precedence and priority that occur before the
            current template rule in <a title="declaration order"
            href="#dt-declaration-order">declaration order</a>.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>As explained in <a href="#conflict"><i>6.4
              Conflict Resolution for Template Rules</i></a>, a
              template rule whose match pattern contains multiple
              alternatives separated by <code>|</code> is treated
              equivalently to a set of template rules, one for each
              alternative. This means that where the same node
              matches more than one alternative, and the
              alternatives have different priority, it is possible
              for an <a href=
              "#element-next-match"><code>xsl:next-match</code></a>
              instruction to cause the current template rule to be
              invoked recursively. This situation does not occur
              when the alternatives have the same priority.</p>
            </div>
          </li>
        </ul>

        <p>If no matching template rule is found that satisfies
        these criteria, the built-in template rule for the node
        <span>kind</span> is used (see <a href=
        "#built-in-rule"><i>6.6 Built-in Template
        Rules</i></a>).</p>

        <p>An <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        <span>or <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>
        instruction may use <a href=
        "#element-with-param"><code>xsl:with-param</code></a> child
        elements to pass parameters to the chosen <a title=
        "template rule" href="#dt-template-rule">template rule</a>
        (see <a href="#with-param"><i>10.1.1 Passing Parameters to
        Templates</i></a>). It also passes on any <a title=
        "tunnel parameter" href="#dt-tunnel-parameter">tunnel
        parameters</a> as described in <a href=
        "#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a>.</p>

        <p><a name="err-XTDE0560" id="err-XTDE0560"><span class=
        "error">[ERR XTDE0560]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        <span>or <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>
        is evaluated when the <a title="current template rule"
        href="#dt-current-template-rule">current template rule</a>
        is null.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e11507" id="d5e11507"></a>Example: Using
            <code>xsl:apply-imports</code>
          </div>

          <p>For example, suppose the stylesheet
          <code>doc.xsl</code> contains a <a title="template rule"
          href="#dt-template-rule">template rule</a> for
          <code>example</code> elements:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>Another stylesheet could import <code>doc.xsl</code>
          and modify the treatment of <code>example</code> elements
          as follows:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The combined effect would be to transform an
          <code>example</code> into an element of the form:</p>

          <div class="exampleInner">
            <pre>
&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;
</pre>
          </div>
        </div>

        <p>An <a href=
        "#element-fallback"><code>xsl:fallback</code></a>
        instruction appearing as a child of an <a href=
        "#element-next-match"><code>xsl:next-match</code></a>
        instruction is ignored by an XSLT 2.0 processor, but can be
        used to define fallback behavior when the stylesheet is
        processed by an XSLT 1.0 processor in forwards-compatible
        mode.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="for-each" id="for-each"></a>7 Repetition</h2>

      <p class="element-syntax"><a name="element-for-each" id=
      "element-for-each"></a><code>&lt;!-- Category: instruction
      --&gt;<br />
      &lt;xsl:for-each<br />
      &#160;&#160;<b>select</b> = <var>expression</var>&gt;<br />
      &#160;&#160;&lt;!-- Content: (<a href=
      "#element-sort">xsl:sort</a>*,
      <var>sequence-constructor</var>) --&gt;<br />
      &lt;/xsl:for-each&gt;</code></p>

      <p>The <a href=
      "#element-for-each"><code>xsl:for-each</code></a> instruction
      processes each item in a sequence of items, evaluating the
      <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> within
      the <a href="#element-for-each"><code>xsl:for-each</code></a>
      instruction once for each item in that sequence.</p>

      <p>The <code>select</code> attribute is <span class=
      "verb">required</span>, and the <a title="expression" href=
      "#dt-expression">expression</a> <span class=
      "verb">must</span> evaluate to a sequence, called the input
      sequence. If there is an <a href=
      "#element-sort"><code>xsl:sort</code></a> element present
      (see <a href="#sorting"><i>13 Sorting</i></a>) the input
      sequence is sorted to produce a sorted sequence. Otherwise,
      the sorted sequence is the same as the input sequence.</p>

      <p>The <a href=
      "#element-for-each"><code>xsl:for-each</code></a> instruction
      contains a <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a>. The
      <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> is
      evaluated once for each item in the sorted sequence, with the
      <a title="focus" href="#dt-focus">focus</a> set as
      follows:</p>

      <ul>
        <li>
          <p>The <a title="context item" href=
          "#dt-context-item">context item</a> is the item being
          processed. If this is a node, it will also be the
          <a title="context node" href="#dt-context-node">context
          node</a>. If it is not a node, there will be no context
          node: that is, <span>any attempt to reference the context
          node will result in a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a>.</span></p>
        </li>

        <li>
          <p>The <a title="context position" href=
          "#dt-context-position">context position</a> is the
          position of this item in the sorted sequence.</p>
        </li>

        <li>
          <p>The <a title="context size" href=
          "#dt-context-size">context size</a> is the size of the
          sorted sequence (which is the same as the size of the
          input sequence).</p>
        </li>
      </ul>

      <p>For each item in the input sequence, evaluating the
      <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> produces
      a sequence of items (see <a href=
      "#sequence-constructors"><i>5.7 Sequence
      Constructors</i></a>). These output sequences are
      concatenated; <span>if item <var>Q</var> follows item
      <var>P</var> in the sorted sequence, then the result of
      evaluating the sequence constructor with <var>Q</var> as the
      context item is concatenated after the result of evaluating
      the sequence constructor with <var>P</var> as the context
      item.</span> The result of the <a href=
      "#element-for-each"><code>xsl:for-each</code></a> instruction
      is the concatenated sequence of items.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>With XSLT 1.0, the selected nodes were processed in
        document order. With XSLT 2.0, XPath expressions that would
        have been valid under XPath 1.0 (such as path expressions
        and union expressions) will return a sequence of nodes that
        is already in document order, so backwards compatibility is
        maintained.</p>
      </div>

      <div class="example">
        <div class="exampleHeader">
          <a name="d5e11663" id="d5e11663"></a>Example: Using
          <code>xsl:for-each</code>
        </div>

        <p>For example, given an XML document with this
        structure</p>

        <div class="exampleInner">
          <pre>
&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;
</pre>
        </div>

        <p>the following would create an HTML document containing a
        table with a row for each <code>customer</code> element</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
        &lt;tbody&gt;
          &lt;xsl:for-each select="customers/customer"&gt;
            &lt;tr&gt;
              &lt;th&gt;
                &lt;xsl:apply-templates select="name"/&gt;
              &lt;/th&gt;
              &lt;xsl:for-each select="order"&gt;
                &lt;td&gt;
                  &lt;xsl:apply-templates/&gt;
                &lt;/td&gt;
              &lt;/xsl:for-each&gt;
            &lt;/tr&gt;
          &lt;/xsl:for-each&gt;
        &lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;
</pre>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="conditionals" id="conditionals"></a>8
      Conditional Processing</h2>

      <p>There are two instructions in XSLT that support
      conditional processing: <a href=
      "#element-if"><code>xsl:if</code></a> and <a href=
      "#element-choose"><code>xsl:choose</code></a>. The <a href=
      "#element-if"><code>xsl:if</code></a> instruction provides
      simple if-then conditionality; the <a href=
      "#element-choose"><code>xsl:choose</code></a> instruction
      supports selection of one choice when there are several
      possibilities.</p>

      <div class="div2">
        <h3><a name="xsl-if" id="xsl-if"></a>8.1 Conditional
        Processing with <a href=
        "#element-if"><code>xsl:if</code></a></h3>

        <p class="element-syntax"><a name="element-if" id=
        "element-if"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:if<br />
        &#160;&#160;<b>test</b> = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:if&gt;</code></p>

        <p>The <a href="#element-if"><code>xsl:if</code></a>
        element has a mandatory <code>test</code> attribute, which
        specifies an <a title="expression" href=
        "#dt-expression">expression</a>. The content is a <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>.</p>

        <p>The result of the <a href=
        "#element-if"><code>xsl:if</code></a> instruction depends
        on the <a href=
        "http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean
        value</a><sup><small>XP</small></sup> of the expression in
        the <code>test</code> attribute. The rules for determining
        the effective boolean value of an expression are given in
        <a href="#xpath20">[XPath 2.0]</a>: they are the same as
        the rules used for XPath conditional expressions.</p>

        <p>If the effective boolean value of the <a title=
        "expression" href="#dt-expression">expression</a> is true,
        then the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> is
        evaluated (see <a href="#sequence-constructors"><i>5.7
        Sequence Constructors</i></a>), and the resulting node
        sequence is returned as the result of the <a href=
        "#element-if"><code>xsl:if</code></a> instruction;
        otherwise, <span>the sequence constructor is not evaluated,
        and</span> the empty sequence is returned.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e11752" id="d5e11752"></a>Example: Using
            <code>xsl:if</code>
          </div>

          <p>In the following example, the names in a group of
          names are formatted as a comma separated list:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The following colors every other table row yellow:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="item"&gt;
  &lt;tr&gt;
    &lt;xsl:if test="position() mod 2 = 0"&gt;
       &lt;xsl:attribute name="bgcolor"&gt;yellow&lt;/xsl:attribute&gt;
    &lt;/xsl:if&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="xsl-choose" id="xsl-choose"></a>8.2
        Conditional Processing with <a href=
        "#element-choose"><code>xsl:choose</code></a></h3>

        <p class="element-syntax"><a name="element-choose" id=
        "element-choose"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:choose&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-when">xsl:when</a>+, <a href=
        "#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
        &lt;/xsl:choose&gt;</code></p>

        <p class="element-syntax"><a name="element-when" id=
        "element-when"></a><code>&lt;xsl:when<br />
        &#160;&#160;<b>test</b> = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:when&gt;</code></p>

        <p class="element-syntax"><a name="element-otherwise" id=
        "element-otherwise"></a><code>&lt;xsl:otherwise&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:otherwise&gt;</code></p>

        <p>The <a href=
        "#element-choose"><code>xsl:choose</code></a> element
        selects one among a number of possible alternatives. It
        consists of a sequence of one or more <a href=
        "#element-when"><code>xsl:when</code></a> elements followed
        by an optional <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a>
        element. Each <a href=
        "#element-when"><code>xsl:when</code></a> element has a
        single attribute, <code>test</code>, which specifies an
        <a title="expression" href="#dt-expression">expression</a>.
        The content of the <a href=
        "#element-when"><code>xsl:when</code></a> and <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a>
        elements is a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>.</p>

        <p>When an <a href=
        "#element-choose"><code>xsl:choose</code></a> element is
        processed, each of the <a href=
        "#element-when"><code>xsl:when</code></a> elements is
        tested in turn (that is, in <span>the order that</span> the
        elements appear in the stylesheet), until one of the
        <a href="#element-when"><code>xsl:when</code></a> elements
        is satisfied. <span>If none of the <a href=
        "#element-when"><code>xsl:when</code></a> elements is
        satisfied, then the <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a> element
        is considered, as described below.</span></p>

        <p>An <a href="#element-when"><code>xsl:when</code></a>
        element is satisfied if the <a href=
        "http://www.w3.org/TR/xpath20/#dt-ebv">effective boolean
        value</a><sup><small>XP</small></sup> of the <a title=
        "expression" href="#dt-expression">expression</a> in its
        <code>test</code> attribute is <code>true</code>. The rules
        for determining the effective boolean value of an
        expression are given in <a href="#xpath20">[XPath 2.0]</a>:
        they are the same as the rules used for XPath conditional
        expressions.</p>

        <p>The content of the first, and only the first, <a href=
        "#element-when"><code>xsl:when</code></a> element that is
        satisfied is evaluated, and the resulting sequence is
        returned as the result of the <a href=
        "#element-choose"><code>xsl:choose</code></a> instruction.
        If no <a href="#element-when"><code>xsl:when</code></a>
        element is satisfied, the content of the <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a> element
        is evaluated, and the resulting sequence is returned as the
        result of the <a href=
        "#element-choose"><code>xsl:choose</code></a> instruction.
        If no <a href="#element-when"><code>xsl:when</code></a>
        element is satisfied, and no <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a> element
        is present, the result of the <a href=
        "#element-choose"><code>xsl:choose</code></a> instruction
        is an empty sequence.</p>

        <p>Only the <span>sequence</span> constructor of the
        selected <a href="#element-when"><code>xsl:when</code></a>
        or <a href=
        "#element-otherwise"><code>xsl:otherwise</code></a>
        instruction is evaluated. The <code>test</code> expressions
        for <a href="#element-when"><code>xsl:when</code></a>
        instructions after the selected one are not evaluated.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e11904" id="d5e11904"></a>Example: Using
            <code>xsl:choose</code>
          </div>

          <p>The following example enumerates items in an ordered
          list using arabic numerals, letters, or roman numerals
          depending on the depth to which the ordered lists are
          nested.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="variables-and-parameters" id=
      "variables-and-parameters"></a>9 Variables and
      Parameters</h2>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-variable-binding-element" id=
      "dt-variable-binding-element" title=
      "variable-binding element"></a>The two elements <a href=
      "#element-variable"><code>xsl:variable</code></a> and
      <a href="#element-param"><code>xsl:param</code></a> are
      referred to as <b>variable-binding elements</b> <span class=
      "definition">]</span>.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-variable" id="dt-variable" title="variable"></a>The
      <a href="#element-variable"><code>xsl:variable</code></a>
      element declares a <b>variable</b>, which may be a <a title=
      "global variable" href="#dt-global-variable">global
      variable</a> or a <a title="local variable" href=
      "#dt-local-variable">local variable</a>.<span class=
      "definition">]</span></p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-parameter" id="dt-parameter" title="parameter"></a>The
      <a href="#element-param"><code>xsl:param</code></a> element
      declares a <b>parameter</b>, which may be a <a title=
      "stylesheet parameter" href=
      "#dt-stylesheet-parameter">stylesheet parameter</a>, a
      <a title="template parameter" href=
      "#dt-template-parameter">template parameter</a>, or a
      <a title="function parameter" href=
      "#dt-function-parameter">function parameter</a>. A parameter
      is a <a title="variable" href="#dt-variable">variable</a>
      with the additional property that its value can be set by the
      caller when the stylesheet, the template, or the function is
      invoked.<span class="definition">]</span></p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-value" id="dt-value" title="value"></a>A variable is a
      binding between a name and a value. The <b>value</b> of a
      variable is any sequence (of nodes and/or atomic values), as
      defined in <a href="#xpath-datamodel">[Data
      Model]</a>.<span class="definition">]</span></p>

      <div class="div2">
        <h3><a name="variables" id="variables"></a>9.1
        Variables</h3>

        <p class="element-syntax"><a name="element-variable" id=
        "element-variable"></a><code>&lt;!-- Category: declaration
        --&gt;<br />
        &lt;!-- Category: instruction --&gt;<br />
        &lt;xsl:variable<br />
        &#160;&#160;<b>name</b> = <var>qname</var><br />
        &#160;&#160;select? = <var>expression</var><br />
        &#160;&#160;as? = <var>sequence-type</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:variable&gt;</code></p>

        <p>The <a href=
        "#element-variable"><code>xsl:variable</code></a> element
        has a <span class="verb">required</span> <code>name</code>
        attribute, which specifies the name of the variable. The
        value of the <code>name</code> attribute is a <a title=
        "QName" href="#dt-qname">QName</a>, which is expanded as
        described in <a href="#qname"><i>5.1 Qualified
        Names</i></a>.</p>

        <p>The <a href=
        "#element-variable"><code>xsl:variable</code></a> element
        has an optional <code>as</code> attribute, which specifies
        the <a title="required type" href=
        "#dt-required-type">required type</a> of the variable. The
        value of the <code>as</code> attribute is a <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</a><sup>
        <small>XP</small></sup>, as defined in <a href=
        "#xpath20">[XPath 2.0]</a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-supplied-value" id="dt-supplied-value" title=
        "supplied value"></a>The value of the variable is computed
        using the <a title="expression" href=
        "#dt-expression">expression</a> given in the
        <code>select</code> attribute or the contained <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, as
        described in <a href="#variable-values"><i>9.3 Values of
        Variables and Parameters</i></a>. This value is referred to
        as the <b>supplied value</b> of the variable.<span class=
        "definition">]</span> <span>If the <a href=
        "#element-variable"><code>xsl:variable</code></a> element
        has a <code>select</code> attribute, then the sequence
        constructor <span class="verb">must</span> be
        empty.</span></p>

        <p>If the <code>as</code> attribute is specified, then the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the variable is
        converted to the required type, using the <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>.</p>

        <p><a name="err-XTTE0570" id="err-XTTE0570"><span class=
        "error">[ERR XTTE0570]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of a variable
        cannot be converted to the required type.</p>

        <p>If the <code>as</code> attribute is omitted, the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the variable is
        used directly, and no conversion takes place.</p>
      </div>

      <div class="div2">
        <h3><a name="parameters" id="parameters"></a>9.2
        Parameters</h3>

        <p class="element-syntax"><a name="element-param" id=
        "element-param"></a><code>&lt;!-- Category: declaration
        --&gt;<br />
        &lt;xsl:param<br />
        &#160;&#160;<b>name</b> = <var>qname</var><br />
        &#160;&#160;select? = <var>expression</var><br />
        &#160;&#160;as? = <var>sequence-type</var><br />
        &#160;&#160;required? = "yes" | "no"<br />
        &#160;&#160;tunnel? = "yes" | "no"&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:param&gt;</code></p>

        <p>The <a href="#element-param"><code>xsl:param</code></a>
        element may be used as a child of <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>, to
        define a parameter to the transformation; or as a child of
        <a href="#element-template"><code>xsl:template</code></a>
        to define a parameter to a template, which may be supplied
        when the template is invoked using <a href=
        "#element-call-template"><code>xsl:call-template</code></a>,
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        <span>or <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>;
        or as a child of <a href=
        "#element-function"><code>xsl:function</code></a> to define
        a parameter to a stylesheet function, which may be supplied
        when the function is called from an XPath <a title=
        "expression" href="#dt-expression">expression</a>.</p>

        <p>The <a href="#element-param"><code>xsl:param</code></a>
        element has a <span class="verb">required</span>
        <code>name</code> attribute, which specifies the name of
        the parameter. The value of the <code>name</code> attribute
        is a <a title="QName" href="#dt-qname">QName</a>, which is
        expanded as described in <a href="#qname"><i>5.1 Qualified
        Names</i></a>.</p>

        <p><a name="err-XTSE0580" id="err-XTSE0580"><span class=
        "error">[ERR XTSE0580]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        two parameters of a template or of a stylesheet function
        have the same name.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>For rules concerning stylesheet parameters, see
          <a href="#global-variables"><i>9.5 Global Variables and
          Parameters</i></a>. Local variables may <a title=
          "shadows" href="#dt-shadows">shadow</a> template
          parameters and function parameters: see <a href=
          "#scope-of-variables"><i>9.7 Scope of
          Variables</i></a>.</p>
        </div>

        <p>The <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the parameter is
        the value supplied by the caller. If no value was supplied
        by the caller, and if the parameter is not mandatory, then
        the supplied value is computed using the <a title=
        "expression" href="#dt-expression">expression</a> given in
        the <code>select</code> attribute or the contained
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, as
        described in <a href="#variable-values"><i>9.3 Values of
        Variables and Parameters</i></a>. <span>If the <a href=
        "#element-param"><code>xsl:param</code></a> element has a
        <code>select</code> attribute, then the sequence
        constructor <span class="verb">must</span> be
        empty.</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This specification does not dictate whether and when
          the default value of a parameter is evaluated. For
          example, if the default is specified as
          <code>&lt;xsl:param
          name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then
          it is not specified whether a distinct <code>foo</code>
          element node will be created on each invocation of the
          template, or whether the same <code>foo</code> element
          node will be used for each invocation. However, it is
          permissible for the default value to depend on the values
          of other parameters, or on the evaluation context, in
          which case the default must effectively be evaluated on
          each invocation.</p>
        </div>

        <p>The <a href="#element-param"><code>xsl:param</code></a>
        element has an optional <code>as</code> attribute, which
        specifies the <a title="required type" href=
        "#dt-required-type">required type</a> of the parameter. The
        value of the <code>as</code> attribute is a <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</a><sup>
        <small>XP</small></sup>, as defined in <a href=
        "#xpath20">[XPath 2.0]</a>.</p>

        <p>If the <code>as</code> attribute is specified, then the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the parameter is
        converted to the required type, using the <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>.</p>

        <p><a name="err-XTTE0590" id="err-XTTE0590"><span class=
        "error">[ERR XTTE0590]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        conversion of the <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of a parameter to
        its required type fails.</p>

        <p>If the <code>as</code> attribute is omitted, the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the parameter is
        used directly, and no conversion takes place.</p>

        <p>The optional <code>required</code> attribute may be used
        to indicate that a parameter is mandatory. This attribute
        may be specified for <a title="stylesheet parameter" href=
        "#dt-stylesheet-parameter">stylesheet parameters</a> and
        for <a title="template parameter" href=
        "#dt-template-parameter">template parameters</a>; it
        <span class="verb">must not</span> be specified for
        <a title="function parameter" href=
        "#dt-function-parameter">function parameters</a>, which are
        always mandatory. <span>A parameter is mandatory if it is a
        <a title="function parameter" href=
        "#dt-function-parameter">function parameter</a> or if the
        <code>required</code> attribute is present and has the
        value <code>yes</code>. Otherwise, the parameter is
        optional. If the parameter is mandatory, then</span> the
        <a href="#element-param"><code>xsl:param</code></a> element
        <span class="verb">must</span> be empty and <span class=
        "verb">must not</span> have a <code>select</code>
        attribute.</p>

        <p><a name="err-XTTE0600" id="err-XTTE0600"><span class=
        "error">[ERR XTTE0600]</span></a> If a default value is
        given explicitly, that is, if there is either a
        <code>select</code> attribute or a non-empty <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, then
        it is a <a title="type errors" href="#dt-type-error">type
        error</a> if the default value cannot be converted to the
        required type, using the <a title=
        "function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>.</p>

        <p>If an optional parameter has no <code>select</code>
        attribute and has an empty <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>,
        and if there is no <code>as</code> attribute, then the
        default value of the parameter is a zero length string.</p>

        <p><a name="err-XTDE0610" id="err-XTDE0610"><span class=
        "error">[ERR XTDE0610]</span></a> If an optional parameter
        has no <code>select</code> attribute and has an empty
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, and if
        there is an <code>as</code> attribute, then the default
        value of the parameter is an empty sequence. If the empty
        sequence is not a valid instance of the required type
        defined in the <code>as</code> attribute, then the
        parameter is treated as a required parameter, which means
        that it is a <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the caller supplies no value for the
        parameter.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The effect of these rules is that specifying
          <code>&lt;xsl:param name="p" as="xs:date"
          select="2"/&gt;</code> is an error, but if the default
          value of the parameter is never used, then the processor
          has discretion whether or not to report the error. By
          contrast, <code>&lt;xsl:param name="p"
          as="xs:date"/&gt;</code> is treated as if
          <code>required="yes"</code> had been specified: the empty
          sequence is not a valid instance of <code>xs:date</code>,
          so in effect there is no default value and the parameter
          is therefore treated as being mandatory.</p>
        </div>

        <p>The optional <code>tunnel</code> attribute may be used
        to indicate that a parameter is a <a title=
        "tunnel parameter" href="#dt-tunnel-parameter">tunnel
        parameter</a>. The default is <code>no</code>; the value
        <code>yes</code> may be specified only for <a title=
        "template parameter" href="#dt-template-parameter">template
        parameters</a>. Tunnel parameters are described in <a href=
        "#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a></p>
      </div>

      <div class="div2">
        <h3><a name="variable-values" id="variable-values"></a>9.3
        Values of Variables and Parameters</h3>

        <p>A <a title="variable-binding element" href=
        "#dt-variable-binding-element">variable-binding element</a>
        may specify the <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a> of the <a title=
        "variable" href="#dt-variable">variable</a> or <a title=
        "parameter" href="#dt-parameter">parameter</a> in
        <span>four</span> different ways.</p>

        <ul>
          <li>
            <p>If the <a title="variable-binding element" href=
            "#dt-variable-binding-element">variable-binding
            element</a> has a <code>select</code> attribute, then
            the value of the attribute <span class=
            "verb">must</span> be an <a title="expression" href=
            "#dt-expression">expression</a> and the <a title=
            "supplied value" href="#dt-supplied-value">supplied
            value</a> of the variable is the value that results
            from evaluating the expression. In this case, the
            content of the variable-binding element <span class=
            "verb">must</span> be empty.</p>
          </li>

          <li>
            <p>If the <a title="variable-binding element" href=
            "#dt-variable-binding-element">variable-binding
            element</a> has empty content and <span>has neither a
            <code>select</code> attribute nor an <code>as</code>
            attribute</span>, then the <a title="supplied value"
            href="#dt-supplied-value">supplied value</a> of the
            variable is a zero-length string. Thus</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:variable name="x"/&gt;
</pre>
            </div>

            <p>is equivalent to</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:variable name="x" select="''"/&gt;
</pre>
            </div>
          </li>

          <li>
            <p>If a <a title="variable-binding element" href=
            "#dt-variable-binding-element">variable-binding
            element</a> has no <code>select</code> attribute and
            has non-empty content (that is, the variable-binding
            element has one or more child nodes), and has no
            <code>as</code> attribute, then the content of the
            variable-binding element specifies the <a title=
            "supplied value" href="#dt-supplied-value">supplied
            value</a>. The content of the variable-binding element
            is a <a title="sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a>; a
            new document is constructed with a document node having
            as its children the sequence of nodes that results from
            evaluating the sequence constructor and then applying
            the rules given in <a href=
            "#constructing-complex-content"><i>5.7.1 Constructing
            Complex Content</i></a>. The value of the variable is
            then a singleton sequence containing this document
            node. For further information, see <a href=
            "#temporary-trees"><i>9.4 Creating implicit document
            nodes</i></a>.</p>
          </li>

          <li>
            <p>If a <a title="variable-binding element" href=
            "#dt-variable-binding-element">variable-binding
            element</a> has an <code>as</code> attribute but no
            <code>select</code> attribute, then the <a title=
            "supplied value" href="#dt-supplied-value">supplied
            value</a> is the sequence that results from evaluating
            the (possibly empty) <a title="sequence constructor"
            href="#dt-sequence-constructor">sequence
            constructor</a> contained within the variable-binding
            element (see <a href="#sequence-constructors"><i>5.7
            Sequence Constructors</i></a>).</p>
          </li>
        </ul>

        <p>These combinations are summarized in the table
        below.</p>

        <table border="1" cellpadding="5">
          <col width="12%" span="1" />
          <col width="12%" span="1" />
          <col width="12%" span="1" />
          <col span="1" />

          <thead>
            <tr>
              <th align="left">select attribute</th>

              <th align="left">as attribute</th>

              <th align="left">content</th>

              <th align="left">Effect</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td valign="top">present</td>

              <td valign="top">absent</td>

              <td valign="top">empty</td>

              <td valign="top">Value is obtained by evaluating the
              <code>select</code> attribute</td>
            </tr>

            <tr>
              <td valign="top">present</td>

              <td valign="top">present</td>

              <td valign="top">empty</td>

              <td valign="top">Value is obtained by evaluating the
              <code>select</code> attribute, adjusted to the type
              required by the <code>as</code> attribute</td>
            </tr>

            <tr>
              <td valign="top">present</td>

              <td valign="top">absent</td>

              <td valign="top">present</td>

              <td valign="top">Static error</td>
            </tr>

            <tr>
              <td valign="top">present</td>

              <td valign="top">present</td>

              <td valign="top">present</td>

              <td valign="top">Static error</td>
            </tr>

            <tr>
              <td valign="top">absent</td>

              <td valign="top">absent</td>

              <td valign="top">empty</td>

              <td valign="top">Value is a zero-length string</td>
            </tr>

            <tr>
              <td valign="top">absent</td>

              <td valign="top">present</td>

              <td valign="top">empty</td>

              <td valign="top">Value is an empty sequence, provided
              the <code>as</code> attribute permits an empty
              sequence</td>
            </tr>

            <tr>
              <td valign="top">absent</td>

              <td valign="top">absent</td>

              <td valign="top">present</td>

              <td valign="top"><span>Value is a document node whose
              content is obtained by evaluating the sequence
              constructor</span></td>
            </tr>

            <tr>
              <td valign="top">absent</td>

              <td valign="top">present</td>

              <td valign="top">present</td>

              <td valign="top">Value is obtained by evaluating the
              sequence constructor, adjusted to the type required
              by the <code>as</code> attribute</td>
            </tr>
          </tbody>
        </table>

        <p><a name="err-XTSE0620" id="err-XTSE0620"><span class=
        "error">[ERR XTSE0620]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a <a title="variable-binding element" href=
        "#dt-variable-binding-element">variable-binding element</a>
        has a <code>select</code> attribute and has non-empty
        content.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e12625" id="d5e12625"></a>Example: Values of
            Variables
          </div>

          <p>The value of the following variable is the sequence of
          integers (1, 2, 3):</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;
</pre>
          </div>

          <p>The value of the following variable is an integer,
          assuming that the attribute <code>@size</code> exists,
          and is annotated either as an integer, or as
          <span><code>xs:untypedAtomic</code></span>:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;
</pre>
          </div>

          <p>The value of the following variable is a zero-length
          string:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="z"/&gt;
</pre>
          </div>

          <p>The value of the following variable is document node
          containing an empty element as a child:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;
</pre>
          </div>

          <p>The value of the following variable is sequence of
          integers (2, 4, 6):</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
</pre>
          </div>

          <p>The value of the following variable is sequence of
          parentless attribute nodes:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;
</pre>
          </div>

          <p>The value of the following variable is an empty
          sequence:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;
</pre>
          </div>
        </div>

        <p>The actual value of the variable depends on the
        <a title="supplied value" href=
        "#dt-supplied-value">supplied value</a>, as described
        above, and the required type, which is determined by the
        value of the <code>as</code> attribute.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e12672" id="d5e12672"></a>Example: Pitfalls
            with Numeric Predicates
          </div>

          <p>When a variable is used to select nodes by position,
          be careful not to do:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre>
          </div>

          <p>This will output the values of all the <code>td</code>
          elements, space-separated (or in backwards compatibility
          mode, the value of the first <code>td</code> element),
          because the variable <code>n</code> will be bound to a
          node, not a number. Instead, do one of the following:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre>
          </div>

          <p>or</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;
</pre>
          </div>

          <p>or</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="temporary-trees" id="temporary-trees"></a>9.4
        <span>Creating implicit document nodes</span></h3>

        <p>A document node is created implicitly when evaluating an
        <a href="#element-variable"><code>xsl:variable</code></a>,
        <a href="#element-param"><code>xsl:param</code></a>, or
        <a href=
        "#element-with-param"><code>xsl:with-param</code></a>
        element that has non-empty content and that has no
        <code>as</code> attribute. This element is referred to as
        the variable-binding element. The value of the <a title=
        "variable" href="#dt-variable">variable</a> is a single
        node, the document node of the <a title="temporary tree"
        href="#dt-temporary-tree">temporary tree</a>. The content
        of the document node is formed from the result of
        evaluating the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        contained within the variable-binding element, as described
        in <a href="#constructing-complex-content"><i>5.7.1
        Constructing Complex Content</i></a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The construct:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;
</pre>
          </div>

          <p>can be regarded as a shorthand for:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;
</pre>
          </div>
        </div>

        <p>The base URI of the document node is taken from the base
        URI of the variable binding element in the stylesheet. (See
        <a href=
        "http://www.w3.org/TR/xpath-datamodel/#dm-base-uri">Section
        5.2 base-uri Accessor</a><sup><small>DM</small></sup> in
        <a href="#xpath-datamodel">[Data Model]</a>)</p>

        <p>No document-level validation takes place (which means,
        for example, that there is no checking that ID values are
        unique). However, type annotations on nodes within the new
        tree are copied unchanged.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The base URI of other nodes in the tree is determined
          by the rules for constructing complex content. The effect
          of these rules is that the base URI of a node in the
          temporary tree is determined as if all the nodes in the
          temporary tree came from a single entity whose URI was
          the base URI of the <a title="variable-binding element"
          href="#dt-variable-binding-element">variable-binding
          element</a>. Thus, the base URI of the document node will
          be equal to the base URI of the variable-binding element;
          an <code>xml:base</code> attribute within the temporary
          tree will change the base URI for its parent element and
          that element's descendants, just as it would within a
          document constructed by parsing.</p>
        </div>

        <p>The <code>document-uri</code> and
        <code>unparsed-entities</code> properties of the new
        document node are set to empty.</p>

        <p>A <a title="temporary tree" href=
        "#dt-temporary-tree">temporary tree</a> is available for
        processing in exactly the same way as any source document.
        For example, its nodes are accessible using path
        expressions, and they can be processed using instructions
        such as <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        and <a href=
        "#element-for-each"><code>xsl:for-each</code></a>. Also,
        the <a href="#function-key"><code>key</code></a> and
        <a href=
        "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
        <small>FO</small></sup> functions can be used to find nodes
        within a temporary tree <span>rooted at a document
        node</span>, provided that at the time the function is
        called, the context item is a node within the temporary
        tree.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e12785" id="d5e12785"></a>Example: Two-Phase
            Transformation
          </div>

          <p>For example, the following stylesheet uses a temporary
          tree as the intermediate result of a two-phase
          transformation, using different <a title="mode" href=
          "#dt-mode">modes</a> for the two phases (see <a href=
          "#modes"><i>6.5 Modes</i></a>). <span>Typically, the
          template rules in module <code>phase1.xsl</code> will be
          declared with <code>mode="phase1"</code>, while those in
          module <code>phase2.xsl</code> will be declared with
          <code>mode="phase2"</code>:</span></p>

          <div class="exampleInner">
            <pre>
&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
          </div>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The algorithm for matching nodes against template
          rules is exactly the same regardless which tree the nodes
          come from. <span>If different template rules are to be
          used when processing different trees, then unless</span>
          nodes from different trees can be distinguished by means
          of <a title="pattern" href="#dt-pattern">patterns</a>, it
          is a good idea to use <a title="mode" href=
          "#dt-mode">modes</a> to ensure that each tree is
          processed using the appropriate set of template
          rules.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="global-variables" id=
        "global-variables"></a>9.5 Global Variables and
        Parameters</h3>

        <p>Both <a href=
        "#element-variable"><code>xsl:variable</code></a> and
        <a href="#element-param"><code>xsl:param</code></a> are
        allowed as <a title="declaration" href=
        "#dt-declaration">declaration</a> elements<span>: that is,
        they may appear as children of the <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element.</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-global-variable" id="dt-global-variable" title=
        "global variable"></a>A top-level <a title=
        "variable-binding element" href=
        "#dt-variable-binding-element">variable-binding element</a>
        declares a <b>global variable</b> that is visible
        everywhere (except where it is <a title="shadows" href=
        "#dt-shadows">shadowed</a> by another binding).<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-stylesheet-parameter" id="dt-stylesheet-parameter"
        title="stylesheet parameter"></a>A top-level <a href=
        "#element-param"><code>xsl:param</code></a> element
        declares a <b>stylesheet parameter</b>. A stylesheet
        parameter is a global variable with the additional property
        that its value can be supplied by the caller when a
        transformation is initiated.<span class=
        "definition">]</span> <span>As described in <a href=
        "#parameters"><i>9.2 Parameters</i></a>, a stylesheet
        parameter may be declared as being mandatory, or may have a
        default value specified for use when no value is supplied
        by the caller.</span> <span>The mechanism by which the
        caller supplies a value for a stylesheet parameter is
        <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>.</span>
        An XSLT <a title="processor" href=
        "#dt-processor">processor</a> <span class=
        "verb">must</span> provide such a mechanism.</p>

        <p>It is an error if no value is supplied for a mandatory
        stylesheet parameter <span class="error">[see <a href=
        "#err-XTDE0050">ERR XTDE0050</a>]</span>.</p>

        <p>If a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> contains more than one
        binding for a global variable of a particular name, then
        the binding with the highest <a title="import precedence"
        href="#dt-import-precedence">import precedence</a> is
        used.</p>

        <p><a name="err-XTSE0630" id="err-XTSE0630"><span class=
        "error">[ERR XTSE0630]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> contains more than one
        binding of a global variable with the same name and same
        <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a><span>, unless
        it also contains another binding with the same name and
        higher import precedence</span>.</p>

        <p>For a global variable or the default value of a
        stylesheet parameter, the <a title="expression" href=
        "#dt-expression">expression</a> or <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        specifying the variable value is evaluated with a <a title=
        "singleton focus" href="#dt-singleton-focus">singleton
        focus</a> based on the <span>root</span> node of the
        <span>tree</span> containing the <a title=
        "initial context node" href=
        "#dt-initial-context-node">initial context node</a>. An
        XPath error will be reported if the evaluation of a global
        variable or parameter references the context item, context
        position, or context size when no initial context node is
        supplied. <span>The values of other components of the
        dynamic context are the initial values as defined in
        <a href="#xpath-dynamic-context"><i>5.4.3 Initializing the
        Dynamic Context</i></a> and <a href=
        "#additional-dynamic-context"><i>5.4.4 Additional Dynamic
        Context Components used by XSLT</i></a></span>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e12936" id="d5e12936"></a>Example: A
            Stylesheet Parameter
          </div>

          <p>The following example declares a global parameter
          <code>para-font-size</code>, which is referenced in an
          <a title="attribute value template" href=
          "#dt-attribute-value-template">attribute value
          template</a>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{$para-font-size}"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The implementation <span>must</span> provide a
          mechanism allowing the user to supply a value for the
          parameter <code>para-font-size</code> when invoking the
          stylesheet; the value <code>12pt</code> acts as a
          default.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="local-variables" id="local-variables"></a>9.6
        Local Variables and Parameters</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-local-variable" id="dt-local-variable" title=
        "local variable"></a>As well as being allowed as <a title=
        "declaration" href="#dt-declaration">declaration</a>
        elements, the <a href=
        "#element-variable"><code>xsl:variable</code></a> element
        is also allowed in <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructors</a>. Such
        a variable is known as a <b>local variable</b>.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-template-parameter" id="dt-template-parameter" title=
        "template parameter"></a> An <a href=
        "#element-param"><code>xsl:param</code></a> element may
        appear as a child of an <a href=
        "#element-template"><code>xsl:template</code></a> element,
        before any non-<a href=
        "#element-param"><code>xsl:param</code></a> children of
        that element. Such a parameter is known as a <b>template
        parameter</b>. A template parameter is a <a title=
        "local variable" href="#dt-local-variable">local
        variable</a> with the additional property that its value
        can be set when the template is called, using any of the
        instructions <a href=
        "#element-call-template"><code>xsl:call-template</code></a>,
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>,
        <span>or <a href=
        "#element-next-match"><code>xsl:next-match</code></a></span>.<span class="definition">
        ]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-function-parameter" id="dt-function-parameter" title=
        "function parameter"></a> An <a href=
        "#element-param"><code>xsl:param</code></a> element may
        appear as a child of an <a href=
        "#element-function"><code>xsl:function</code></a> element,
        before any non-<a href=
        "#element-param"><code>xsl:param</code></a> children of
        that element. Such a parameter is known as a <b>function
        parameter</b>. A function parameter is a <a title=
        "local variable" href="#dt-local-variable">local
        variable</a> with the additional property that its value
        can be set when the function is called, using a function
        call in an XPath <a title="expression" href=
        "#dt-expression">expression</a>.<span class=
        "definition">]</span></p>

        <p>The result of evaluating a local <a href=
        "#element-variable"><code>xsl:variable</code></a> or
        <a href="#element-param"><code>xsl:param</code></a> element
        (that is, the contribution it makes to the result of the
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> it is
        part of) is an empty sequence.</p>
      </div>

      <div class="div2">
        <h3><a name="scope-of-variables" id=
        "scope-of-variables"></a>9.7 Scope of Variables</h3>

        <p>For any <a title="variable-binding element" href=
        "#dt-variable-binding-element">variable-binding
        element</a>, there is a region <span>(more specifically, a
        set of element nodes)</span> of the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> within which the
        binding is visible. The set of variable bindings in scope
        for an XPath <a title="expression" href=
        "#dt-expression">expression</a> consists of those bindings
        that are visible at the point in the stylesheet where the
        expression occurs.</p>

        <p>A global <a title="variable-binding element" href=
        "#dt-variable-binding-element">variable binding element</a>
        is visible everywhere in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> (including other <a title=
        "stylesheet module" href="#dt-stylesheet-module">stylesheet
        modules</a>) except within the <a href=
        "#element-variable"><code>xsl:variable</code></a> or
        <a href="#element-param"><code>xsl:param</code></a> element
        itself and any region where it is <a title="shadows" href=
        "#dt-shadows">shadowed</a> by another variable binding.</p>

        <p>A local <a title="variable-binding element" href=
        "#dt-variable-binding-element">variable binding element</a>
        is visible for all following siblings and their
        descendants<span>, with two exceptions: it is not visible
        in any region where it is <a title="shadows" href=
        "#dt-shadows">shadowed</a> by another variable binding, and
        it is not visible within the subtree rooted at an <a href=
        "#element-fallback"><code>xsl:fallback</code></a>
        instruction that is a sibling of the variable binding
        element.</span> The binding is not visible for the <a href=
        "#element-variable"><code>xsl:variable</code></a> or
        <a href="#element-param"><code>xsl:param</code></a> element
        itself.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-shadows"
        id="dt-shadows" title="shadows"></a>A binding
        <b>shadows</b> another binding if the binding occurs at a
        point where the other binding is visible, and the bindings
        have the same name. <span class="definition">]</span> It is
        not an error if a binding established by a local <a href=
        "#element-variable"><code>xsl:variable</code></a> or
        <a href="#element-param"><code>xsl:param</code></a>
        <a title="shadows" href="#dt-shadows">shadows</a> a global
        binding. In this case, the global binding will not be
        visible in the region of the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> where it is shadowed by the
        other binding.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13122" id="d5e13122"></a>Example: Local
            Variable Shadowing a Global Variable
          </div>

          <p>The following is allowed:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>It is also not an error if a binding established by a
        local <a href=
        "#element-variable"><code>xsl:variable</code></a> element
        <a title="shadows" href="#dt-shadows">shadows</a> a binding
        established by another local <a href=
        "#element-variable"><code>xsl:variable</code></a> or
        <a href="#element-param"><code>xsl:param</code></a>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13143" id="d5e13143"></a>Example: Misuse of
            Variable Shadowing
          </div>

          <p>The following is not an error, but the effect is
          probably not what was intended. The template outputs
          <code>&lt;x value="1"/&gt;</code>, because the
          declaration of the inner variable named <code>$x</code>
          has no effect on the value of the outer variable named
          <code>$x</code>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{$x}"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Once a variable has been given a value, the value
          cannot subsequently be changed. XSLT does not provide an
          equivalent to the assignment operator available in many
          procedural programming languages.</p>

          <p>This is because an assignment operator would make it
          harder to create an implementation that processes a
          document other than in a batch-like way, starting at the
          beginning and continuing through to the end.</p>
        </div>

        <p>As well as global variables and local variables, an
        XPath <a title="expression" href=
        "#dt-expression">expression</a> may also declare range
        variables for use locally within an expression. For
        details, see <a href="#xpath20">[XPath 2.0]</a>.</p>

        <p>Where a reference to a variable occurs in an XPath
        expression, it is resolved first by reference to range
        variables that are in scope, then by reference to local
        variables and parameters, and finally by reference to
        global variables and parameters. A range variable may
        shadow a local variable or a global variable. XPath also
        allows a range variable to shadow another range
        variable.</p>
      </div>

      <div class="div2">
        <h3><a name="circularity" id="circularity"></a>9.8 Circular
        Definitions</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-circularity" id="dt-circularity" title=
        "circularity"></a>A <b>circularity</b> is said to exist if
        a construct such as a <a title="global variable" href=
        "#dt-global-variable">global variable</a>, an <a title=
        "attribute set" href="#dt-attribute-set">attribute set</a>,
        or a <a title="key" href="#dt-key">key</a> is defined in
        terms of itself. For example, if the <a title="expression"
        href="#dt-expression">expression</a> or <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        specifying the value of a <a title="global variable" href=
        "#dt-global-variable">global variable</a> <var>X</var>
        references a global variable <var>Y</var>, then the value
        for <var>Y</var> <span class="verb">must</span> be computed
        before the value of <var>X</var>. A circularity exists if
        it is impossible to do this for all global variable
        definitions.<span class="definition">]</span></p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13219" id="d5e13219"></a>Example: Circular
            Variable Definitions
          </div>

          <p>The following two declarations create a
          circularity:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13226" id="d5e13226"></a>Example:
            Circularity involving Variables and Functions
          </div>

          <p>The definition of a global variable can be circular
          even if no other variable is involved. For example the
          following two declarations (see <a href=
          "#stylesheet-functions"><i>10.3 Stylesheet
          Functions</i></a> for an explanation of the <a href=
          "#element-function"><code>xsl:function</code></a>
          element) also create a circularity:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13238" id="d5e13238"></a>Example:
            Circularity involving Variables and Templates
          </div>

          <p>The definition of a variable is also circular if the
          evaluation of the variable invokes an <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction and the variable is referenced in the pattern
          used in the <code>match</code> attribute of any template
          rule in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>. For example the
          following definition is circular:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e13254" id="d5e13254"></a>Example:
            Circularity involving Variables and Keys
          </div>

          <p>Similarly, a variable definition is circular if it
          causes a call on the <a href=
          "#function-key"><code>key</code></a> function, and the
          definition of that <a title="" href="#key">key</a> refers
          to that variable in its <code>match</code> or
          <code>use</code> attributes. So the following definition
          is circular:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="x" select="my:f(10)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:sequence select="key('k', $arg1)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;
</pre>
          </div>
        </div>

        <p><a name="err-XTDE0640" id="err-XTDE0640"><span class=
        "error">[ERR XTDE0640]</span></a> In general, a <a title=
        "circularity" href="#dt-circularity">circularity</a> in a
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        is a <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a>. However, as with all other dynamic errors, an
        implementation will signal the error only if it actually
        executes the instructions and expressions that participate
        in the circularity. Because different implementations may
        optimize the execution of a stylesheet in different ways,
        it is <a title="implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>
        whether a particular circularity will actually be
        signaled.</p>

        <p>For example, in the following declarations, the function
        declares a <span>local variable <code>$b</code>, but it
        returns a result that does not require the variable to be
        evaluated. It is <a title="implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>
        whether the value is actually evaluated</span>, and it is
        therefore implementation-dependent whether the circularity
        is signaled as an error:</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:variable name="x" select="my:f(1)/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;
</pre>
        </div>

        <p>Circularities usually involve global variables or
        parameters, but they can also exist between <a title=""
        href="#key">key</a> definitions (see <a href="#key"><i>16.3
        Keys</i></a>), between named <a title="attribute set" href=
        "#dt-attribute-set">attribute sets</a> (see <a href=
        "#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or
        between any combination of these constructs. For example, a
        circularity exists if a key definition invokes a function
        that references an attribute set that calls the <a href=
        "#function-key"><code>key</code></a> function, supplying
        the name of the original key definition as an argument.</p>

        <p>Circularity is not the same as recursion. Stylesheet
        functions (see <a href="#stylesheet-functions"><i>10.3
        Stylesheet Functions</i></a>) and named templates (see
        <a href="#named-templates"><i>10.1 Named Templates</i></a>)
        may call other functions and named templates without
        restriction. With careless coding, recursion may be
        non-terminating. Implementations are <span class=
        "verb">required</span> to signal circularity as a <a title=
        "dynamic error" href="#dt-dynamic-error">dynamic error</a>,
        but they are not <span class="verb">required</span> to
        detect non-terminating recursion.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="callable-components" id=
      "callable-components"></a>10 Callable Components</h2>

      <p>This section describes three constructs that can be used
      to provide subroutine-like functionality that can be invoked
      from anywhere in the stylesheet: named templates (see
      <a href="#named-templates"><i>10.1 Named Templates</i></a>),
      named attribute sets (see <a href="#attribute-sets"><i>10.2
      Named Attribute Sets</i></a>) and <a title=
      "stylesheet function" href=
      "#dt-stylesheet-function">stylesheet functions</a> (see
      <a href="#stylesheet-functions"><i>10.3 Stylesheet
      Functions</i></a>).</p>

      <div class="div2">
        <h3><a name="named-templates" id="named-templates"></a>10.1
        Named Templates</h3>

        <p class="element-syntax"><a name="element-call-template"
        id="element-call-template"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:call-template<br />
        &#160;&#160;<b>name</b> = <var>qname</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: <a href=
        "#element-with-param">xsl:with-param</a>* --&gt;<br />
        &lt;/xsl:call-template&gt;</code></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-named-template" id="dt-named-template" title=
        "named template"></a>Templates can be invoked by name. An
        <a href="#element-template"><code>xsl:template</code></a>
        element with a <code>name</code> attribute defines a
        <b>named template</b>.<span class="definition">]</span> The
        value of the <code>name</code> attribute is a <a title=
        "QName" href="#dt-qname">QName</a>, which is expanded as
        described in <a href="#qname"><i>5.1 Qualified
        Names</i></a>. If an <a href=
        "#element-template"><code>xsl:template</code></a> element
        has a <code>name</code> attribute, it may, but need not,
        also have a <code>match</code> attribute. An <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction invokes a template by name; it has a
        <span class="verb">required</span> <code>name</code>
        attribute that identifies the template to be invoked.
        Unlike <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        the <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction does not change the <a title="focus" href=
        "#dt-focus">focus</a>.</p>

        <p>The <code>match</code>, <code>mode</code> and
        <code>priority</code> attributes on an <a href=
        "#element-template"><code>xsl:template</code></a> element
        <span>have no effect when</span> the <a title="template"
        href="#dt-template">template</a> is invoked by an <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction. Similarly, the <code>name</code> attribute on
        an <a href=
        "#element-template"><code>xsl:template</code></a> element
        <span>has no effect when</span> the template is invoked by
        an <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>
        instruction.</p>

        <p><a name="err-XTSE0650" id="err-XTSE0650"><span class=
        "error">[ERR XTSE0650]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> contains an <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction whose <code>name</code> attribute does not
        match the <code>name</code> attribute of any <a href=
        "#element-template"><code>xsl:template</code></a> in the
        <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>.</p>

        <p><a name="err-XTSE0660" id="err-XTSE0660"><span class=
        "error">[ERR XTSE0660]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> contains more than one
        <a title="template" href="#dt-template">template</a> with
        the same name and the same <a title="import precedence"
        href="#dt-import-precedence">import precedence</a><span>,
        unless it also contains a <a title="template" href=
        "#dt-template">template</a> with the same name and higher
        <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a></span>.</p>

        <p>The target <a title="template" href=
        "#dt-template">template</a> for an <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction is the template whose <code>name</code>
        attribute matches the <code>name</code> attribute of the
        <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction and that has higher <a title=
        "import precedence" href="#dt-import-precedence">import
        precedence</a> than any other template with this name. The
        result of evaluating an <a href=
        "#element-call-template"><code>xsl:call-template</code></a>
        instruction is the sequence produced by evaluating the
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        contained in its target <a title="template" href=
        "#dt-template">template</a> (see <a href=
        "#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>).</p>

        <div class="div3">
          <h4><a name="with-param" id="with-param"></a>10.1.1
          Passing Parameters to Templates</h4>

          <p class="element-syntax"><a name="element-with-param"
          id="element-with-param"></a><code>&lt;xsl:with-param<br />

          &#160;&#160;<b>name</b> = <var>qname</var><br />
          &#160;&#160;select? = <var>expression</var><br />
          &#160;&#160;as? = <var>sequence-type</var><br />
          &#160;&#160;tunnel? = "yes" | "no"&gt;<br />
          &#160;&#160;&lt;!-- Content:
          <var>sequence-constructor</var> --&gt;<br />
          &lt;/xsl:with-param&gt;</code></p>

          <p>Parameters are passed to templates using the <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          element. The <span class="verb">required</span>
          <code>name</code> attribute specifies the name of the
          <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a> (the
          variable the value of whose binding is to be replaced).
          The value of the <code>name</code> attribute is a
          <a title="QName" href="#dt-qname">QName</a>, which is
          expanded as described in <a href="#qname"><i>5.1
          Qualified Names</i></a>.</p>

          <p><a href=
          "#element-with-param"><code>xsl:with-param</code></a> is
          allowed within <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <span>and <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>.</p>

          <p><a name="err-XTSE0670" id="err-XTSE0670"><span class=
          "error">[ERR XTSE0670]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a single <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <span>or <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>
          element contains two or more <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          elements with <span>matching <code>name</code>
          attributes</span>.</p>

          <p>The value of the parameter is specified in the same
          way as for <a href=
          "#element-variable"><code>xsl:variable</code></a> and
          <a href="#element-param"><code>xsl:param</code></a> (see
          <a href="#variable-values"><i>9.3 Values of Variables and
          Parameters</i></a>)<span>, taking account of the values
          of the <code>select</code> and <code>as</code> attributes
          and the content of the <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          element, if any.</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It is possible to have an <code>as</code> attribute
            on the <a href=
            "#element-with-param"><code>xsl:with-param</code></a>
            element that differs from the <code>as</code> attribute
            on the corresponding <a href=
            "#element-param"><code>xsl:param</code></a> element
            describing the formal parameters of the called
            template.</p>

            <p>In this situation, the supplied value of the
            parameter will first be processed according to the
            rules of the <code>as</code> attribute on the <a href=
            "#element-with-param"><code>xsl:with-param</code></a>
            element, and the resulting value will then be further
            processed according to the rules of the <code>as</code>
            attribute on the <a href=
            "#element-param"><code>xsl:param</code></a>
            element.</p>

            <p>For example, suppose the supplied value is a node
            with <a title="type annotation" href=
            "#dt-annotation">type annotation</a>
            <span><code>xs:untypedAtomic</code></span>, and the
            <a href=
            "#element-with-param"><code>xsl:with-param</code></a>
            element specifies <code>as="xs:integer"</code>, while
            the <a href="#element-param"><code>xsl:param</code></a>
            element specifies <code>as="xs:double"</code>. Then the
            node will first be atomized and the resulting untyped
            atomic value will be cast to <code>xs:integer</code>.
            If this succeeds, the <code>xs:integer</code> will then
            be promoted to an <code>xs:double</code>.</p>
          </div>

          <p>The <a title="focus" href="#dt-focus">focus</a> used
          for computing the value specified by the <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          element is the same as that used for the <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <a href=
          "#element-next-match"><code>xsl:next-match</code></a>, or
          <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          element within which it occurs.</p>

          <p><a name="err-XTSE0680" id="err-XTSE0680"><span class=
          "error">[ERR XTSE0680]</span></a> In the case of <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          it is a <a title="static error" href=
          "#dt-static-error">static error</a> to pass a
          <span>non-tunnel</span> parameter named <var>x</var> to a
          template that does not have a <a title=
          "template parameter" href=
          "#dt-template-parameter">template parameter</a> named
          <var>x</var><span>, unless <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled for the <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          instruction</span>. This is not an error in the case of
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <span>and <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>;
          in these cases the parameter is simply ignored.</p>

          <p>The optional <code>tunnel</code> attribute may be used
          to indicate that a parameter is a <a title=
          "tunnel parameter" href="#dt-tunnel-parameter">tunnel
          parameter</a>. The default is <code>no</code>. Tunnel
          parameters are described in <a href=
          "#tunnel-params"><i>10.1.2 Tunnel Parameters</i></a></p>

          <p><a name="err-XTSE0690" id="err-XTSE0690"><span class=
          "error">[ERR XTSE0690]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a template that is invoked using <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          declares a <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a>
          specifying <code>required="yes"</code> <span>and not
          specifying <code>tunnel="yes"</code></span>, if no value
          for this parameter is supplied by the calling
          instruction.</p>

          <p><a name="err-XTDE0700" id="err-XTDE0700"><span class=
          "error">[ERR XTDE0700]</span></a> In other cases, it is a
          <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the template that is invoked declares a
          <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a> with
          <code>required="yes"</code> and no value for this
          parameter is supplied by the calling instruction.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e13826" id="d5e13826"></a>Example: A Named
              Template
            </div>

            <p>This example defines a named template for a
            <code>numbered-block</code> with an argument to control
            the format of the number.</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{$format}"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre>
            </div>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Arguments to <a title="stylesheet function" href=
            "#dt-stylesheet-function">stylesheet functions</a> are
            supplied as part of an XPath function call: see
            <a href="#stylesheet-functions"><i>10.3 Stylesheet
            Functions</i></a></p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="tunnel-params" id="tunnel-params"></a>10.1.2
          Tunnel Parameters</h4>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-tunnel-parameter" id="dt-tunnel-parameter" title=
          "tunnel parameter"></a>A parameter passed to a template
          may be defined as a <b>tunnel parameter</b>. Tunnel
          parameters have the property that they are automatically
          passed on by the called template to any further templates
          that it calls, and so on recursively.<span class=
          "definition">]</span> Tunnel parameters thus allow values
          to be set that are accessible during an entire phase of
          stylesheet processing, without the need for each template
          that is used during that phase to be aware of the
          parameter.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Tunnel parameters are conceptually similar to
            dynamically-scoped variables in some functional
            programming languages.</p>
          </div>

          <p>A <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameter</a> is created by
          using an <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          element that specifies <code>tunnel="yes"</code>. A
          template that requires access to the value of a tunnel
          parameter must declare it using an <a href=
          "#element-param"><code>xsl:param</code></a> element that
          also specifies <code>tunnel="yes"</code>.</p>

          <p>On any template call using an <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>
          or <a href=
          "#element-next-match"><code>xsl:next-match</code></a>
          instruction, a set of <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameters</a> is passed
          from the calling template to the called template. This
          set consists of any parameters explicitly created using
          <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
          overlaid on a base set of tunnel parameters. If the
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>
          or <a href=
          "#element-next-match"><code>xsl:next-match</code></a>
          instruction has an <a href=
          "#element-template"><code>xsl:template</code></a>
          declaration as an ancestor element in the stylesheet,
          then the base set consists of the tunnel parameters that
          were passed to that template; otherwise (for example, if
          the instruction is within a global variable declaration,
          an <a title="attribute set" href=
          "#dt-attribute-set">attribute set</a> declaration, or a
          <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a>), the
          base set is empty. If a parameter created using
          <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the
          same <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> as a parameter in
          the base set, then the parameter created using <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          overrides the parameter in the base set; otherwise, the
          parameter created using <a href=
          "#element-with-param"><code>xsl:with-param</code></a> is
          added to the base set.</p>

          <p>When a template accesses the value of a <a title=
          "tunnel parameter" href="#dt-tunnel-parameter">tunnel
          parameter</a> by declaring it with <code>xsl:param
          tunnel="yes"</code>, this does not remove the parameter
          from the base set of tunnel parameters that is passed on
          to any templates called by this template.</p>

          <p>Two sibling <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          elements must have distinct parameter names, even if one
          is a <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameter</a> and the other
          is not. Equally, two sibling <a href=
          "#element-param"><code>xsl:param</code></a> elements
          representing <a title="template parameter" href=
          "#dt-template-parameter">template parameters</a> must
          have distinct parameter names, even if one is a <a title=
          "tunnel parameter" href="#dt-tunnel-parameter">tunnel
          parameter</a> and the other is not. However, the tunnel
          parameters that are implicitly passed in a template call
          may have names that duplicate the names of non-tunnel
          parameters that are explicitly passed on the same
          call.</p>

          <p><a title="tunnel parameter" href=
          "#dt-tunnel-parameter">Tunnel parameters</a> are not
          passed in calls to <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet functions</a>.</p>

          <p>All other options of <a href=
          "#element-with-param"><code>xsl:with-param</code></a> and
          <a href="#element-param"><code>xsl:param</code></a> are
          available with <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameters</a> just as with
          non-tunnel parameters. For example, parameters may be
          declared as mandatory or optional, a default value may be
          specified, and a required type may be specified. If any
          conversion is required from the supplied value of a
          tunnel parameter to the required type specified in
          <a href="#element-param"><code>xsl:param</code></a>, then
          the converted value is used within the receiving
          template, but the value that is passed on in any further
          template calls is the original supplied value before
          conversion. Equally, any default value is local to the
          template: specifying a default value for a tunnel
          parameter does not change the set of tunnel parameters
          that is passed on in further template calls.</p>

          <p>The set of <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameters</a> that is
          passed to the <a title="initial template" href=
          "#dt-initial-template">initial template</a> is empty.</p>

          <p><a title="tunnel parameter" href=
          "#dt-tunnel-parameter">Tunnel parameters</a> are passed
          unchanged through a built-in template rule (see <a href=
          "#built-in-rule"><i>6.6 Built-in Template
          Rules</i></a>).</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e13990" id="d5e13990"></a>Example: Using
              Tunnel Parameters
            </div>

            <p>Suppose that the equations in a scientific paper are
            to be sequentially numbered, but that the format of the
            number depends on the context in which the equations
            appear. It is possible to reflect this using a rule of
            the form:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{$equation-format}"/&gt;
&lt;/xsl:template&gt;
</pre>
            </div>

            <p>At any level of processing above this level, it is
            possible to determine how the equations will be
            numbered, for example:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;
</pre>
            </div>

            <p>The parameter value is passed transparently through
            all the intermediate layers of template rules until it
            reaches the rule with <code>match="equation"</code>.
            The effect is similar to using a global variable,
            except that the parameter can take different values
            during different phases of the transformation.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="attribute-sets" id="attribute-sets"></a>10.2
        Named Attribute Sets</h3>

        <p class="element-syntax"><a name="element-attribute-set"
        id="element-attribute-set"></a><code>&lt;!-- Category:
        declaration --&gt;<br />
        &lt;xsl:attribute-set<br />
        &#160;&#160;<b>name</b> = <var>qname</var><br />
        &#160;&#160;use-attribute-sets? =
        <var>qnames</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: <a href=
        "#element-attribute">xsl:attribute</a>* --&gt;<br />
        &lt;/xsl:attribute-set&gt;</code></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-attribute-set" id="dt-attribute-set" title=
        "attribute set"></a>The <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        element defines a named <b>attribute set</b>: that is, a
        collection of attribute <span>definitions</span> that can
        be used repeatedly on different constructed
        elements.<span class="definition">]</span></p>

        <p>The <span class="verb">required</span> <code>name</code>
        attribute specifies the name of the attribute set. The
        value of the <code>name</code> attribute is a <a title=
        "QName" href="#dt-qname">QName</a>, which is expanded as
        described in <a href="#qname"><i>5.1 Qualified
        Names</i></a>. The content of the <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        element consists of zero or more <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instructions that are evaluated to produce the attributes
        in the set.</p>

        <p>The result of evaluating an attribute set is a sequence
        of attribute nodes. Evaluating the same attribute set more
        than once can produce different results, because although
        an attribute set does not have parameters, it may contain
        expressions or instructions whose value depends on the
        evaluation context.</p>

        <p><a title="attribute set" href=
        "#dt-attribute-set">Attribute sets</a> are used by
        specifying a <code>use-attribute-sets</code> attribute on
        the <a href="#element-element"><code>xsl:element</code></a>
        or <a href="#element-copy"><code>xsl:copy</code></a>
        instruction, or by specifying an
        <code>xsl:use-attribute-sets</code> attribute on a literal
        result element. An attribute set may be defined in terms of
        other attribute sets by using the
        <code>use-attribute-sets</code> attribute on the <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        element itself. The value of the
        <code>[xsl:]use-attribute-sets</code> attribute is in each
        case a whitespace-separated list of names of attribute
        sets. Each name is specified as a <a title="QName" href=
        "#dt-qname">QName</a>, which is expanded as described in
        <a href="#qname"><i>5.1 Qualified Names</i></a>.</p>

        <p>Specifying a <code>use-attribute-sets</code> attribute
        is broadly equivalent to adding <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instructions for each of the attributes in each of the
        named attribute sets to the beginning of the content of the
        instruction with the <code>[xsl:]use-attribute-sets</code>
        attribute, in the same order in which the names of the
        attribute sets are specified in the
        <code>use-attribute-sets</code> attribute.</p>

        <p>More formally, an <code>xsl:use-attribute-sets</code>
        attribute is expanded using the following recursive
        algorithm, or any algorithm that produces the same
        results:</p>

        <ul>
          <li>
            <p>The value of the attribute is tokenized as a list of
            QNames.</p>
          </li>

          <li>
            <p>Each QName in the list is processed, in order, as
            follows:</p>

            <ul>
              <li>
                <p>The QName must match the <code>name</code>
                attribute of one or more <a href=
                "#element-attribute-set"><code>xsl:attribute-set</code></a>
                declarations in the stylesheet.</p>
              </li>

              <li>
                <p>Each <a href=
                "#element-attribute-set"><code>xsl:attribute-set</code></a>
                declaration whose name matches is processed as
                follows. Where two such declarations have different
                <a title="import precedence" href=
                "#dt-import-precedence">import precedence</a>, the
                one with lower import precedence is processed
                first. Where two declarations have the same import
                precedence, they are processed in <a title=
                "declaration order" href=
                "#dt-declaration-order">declaration order</a>.</p>

                <ul>
                  <li>
                    <p>If the <a href=
                    "#element-attribute-set"><code>xsl:attribute-set</code></a>
                    declaration has a
                    <code>use-attribute-sets</code> attribute, the
                    attribute is expanded by applying this
                    algorithm recursively.</p>
                  </li>

                  <li>
                    <p>If the <a href=
                    "#element-attribute-set"><code>xsl:attribute-set</code></a>
                    declaration contains one or more <a href=
                    "#element-attribute"><code>xsl:attribute</code></a>
                    instructions, these instructions are evaluated
                    (following the rules for evaluating a <a title=
                    "sequence constructor" href=
                    "#dt-sequence-constructor">sequence
                    constructor</a>: see <a href=
                    "#sequence-constructors"><i>5.7 Sequence
                    Constructors</i></a>) to produce a sequence of
                    attribute nodes. These attribute nodes are
                    appended to the result sequence.</p>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p>The <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instructions are evaluated using the same <a title="focus"
        href="#dt-focus">focus</a> as is used for evaluating the
        element that is the parent of the
        <code>[xsl:]use-attribute-sets</code> attribute forming the
        initial input to the algorithm. However, the static context
        for the evaluation depends on the position of the <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instruction in the stylesheet: thus, only local variables
        declared within an <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instruction, and global variables, are visible.</p>

        <p>The set of attribute nodes produced by expanding
        <code>xsl:use-attribute-sets</code> may include several
        attributes with the same name. When the attributes are
        added to an element node, only the last of the duplicates
        will take effect.</p>

        <p>The way in which each instruction uses the results of
        expanding the <code>[xsl:]use-attribute-sets</code>
        attribute is described in the specification for the
        relevant instruction: see <a href=
        "#literal-result-element"><i>11.1 Literal Result
        Elements</i></a>, <a href="#xsl-element"><i>11.2 Creating
        Element Nodes Using xsl:element</i></a> , and <a href=
        "#copying"><i>11.9 Copying Nodes</i></a>.</p>

        <p><a name="err-XTSE0710" id="err-XTSE0710"><span class=
        "error">[ERR XTSE0710]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the value of the <code>use-attribute-sets</code> attribute
        of an <a href="#element-copy"><code>xsl:copy</code></a>,
        <a href="#element-element"><code>xsl:element</code></a>, or
        <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        element, or the <code>xsl:use-attribute-sets</code>
        attribute of a <a title="literal result element" href=
        "#dt-literal-result-element">literal result element</a>, is
        not a <span>whitespace-separated</span> sequence of
        <a title="QName" href="#dt-qname">QNames</a>, or if it
        contains a QName that does not match the <code>name</code>
        attribute of any <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        declaration in the stylesheet.</p>

        <p><a name="err-XTSE0720" id="err-XTSE0720"><span class=
        "error">[ERR XTSE0720]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        element directly or indirectly references itself via the
        names contained in the <code>use-attribute-sets</code>
        attribute.</p>

        <p>Each attribute node produced by expanding an attribute
        set has a <a title="type annotation" href=
        "#dt-annotation">type annotation</a> determined by the
        rules for the <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instruction that created the attribute node: see <a href=
        "#annotation-for-constructed-attribute"><i>11.3.1 Setting
        the Type Annotation for a Constructed Attribute
        Node</i></a>. These type annotations may be preserved,
        stripped, or replaced as determined by the rules for the
        instruction that creates the element in which the
        attributes are used.</p>

        <p>Attribute sets are used as follows:</p>

        <ul>
          <li>
            <p>The <a href=
            "#element-copy"><code>xsl:copy</code></a> and <a href=
            "#element-element"><code>xsl:element</code></a>
            instructions have an <code>use-attribute-sets</code>
            attribute. The sequence of attribute nodes produced by
            evaluating this attribute is prepended to the sequence
            produced by evaluating the <a title=
            "sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a>
            contained within the instruction.</p>
          </li>

          <li>
            <p><a title="literal result element" href=
            "#dt-literal-result-element">Literal result
            elements</a> allow an
            <code>xsl:use-attribute-sets</code> attribute, which is
            evaluated in the same way as the
            <code>use-attribute-sets</code> attribute of <a href=
            "#element-element"><code>xsl:element</code></a> and
            <a href="#element-copy"><code>xsl:copy</code></a>. The
            sequence of attribute nodes produced by evaluating this
            attribute is prepended to the sequence of attribute
            nodes produced by evaluating the attributes of the
            literal result element, which in turn is prepended to
            the sequence produced by evaluating the <a title=
            "sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a>
            contained with the literal result element.</p>
          </li>
        </ul>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e14293" id="d5e14293"></a>Example: Using
            Attribute Sets
          </div>

          <p>The following example creates a named <a title=
          "attribute set" href="#dt-attribute-set">attribute
          set</a> <code>title-style</code> and uses it in a
          <a title="template rule" href=
          "#dt-template-rule">template rule</a>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e14309" id="d5e14309"></a>Example:
            Overriding Attributes in an Attribute Set
          </div>

          <p>The following example creates a named attribute set
          <code>base-style</code> and uses it in a template rule
          with multiple specifications of the attributes:</p>

          <dl>
            <dt class="label">font-family</dt>

            <dd>
              <p>is specified only in the attribute set</p>
            </dd>

            <dt class="label">font-size</dt>

            <dd>
              <p>is specified in the attribute set, is specified on
              the literal result element, and in an <a href=
              "#element-attribute"><code>xsl:attribute</code></a>
              instruction</p>
            </dd>

            <dt class="label">font-style</dt>

            <dd>
              <p>is specified in the attribute set, and on the
              literal result element</p>
            </dd>

            <dt class="label">font-weight</dt>

            <dd>
              <p>is specified in the attribute set, and in an
              <a href=
              "#element-attribute"><code>xsl:attribute</code></a>
              instruction</p>
            </dd>
          </dl>

          <p>Stylesheet fragment:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>Result:</p>

          <div class="exampleInner">
            <pre>
&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="stylesheet-functions" id=
        "stylesheet-functions"></a>10.3 Stylesheet Functions</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-stylesheet-function" id="dt-stylesheet-function" title=
        "stylesheet function"></a>An <a href=
        "#element-function"><code>xsl:function</code></a>
        declaration declares the name, parameters, and
        implementation of a <b>stylesheet function</b> that can be
        called from any XPath <a title="expression" href=
        "#dt-expression">expression</a> within the <a title=
        "stylesheet" href=
        "#dt-stylesheet">stylesheet</a>.<span class=
        "definition">]</span></p>

        <p class="element-syntax"><a name="element-function" id=
        "element-function"></a><code>&lt;!-- Category: declaration
        --&gt;<br />
        &lt;xsl:function<br />
        &#160;&#160;<b>name</b> = <var>qname</var><br />
        &#160;&#160;as? = <var>sequence-type</var><br />
        &#160;&#160;override? = "yes" | "no"&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-param">xsl:param</a>*,
        <var>sequence-constructor</var>) --&gt;<br />
        &lt;/xsl:function&gt;</code></p>

        <p>The <a href=
        "#element-function"><code>xsl:function</code></a>
        declaration defines a <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> that can
        be called from any XPath <a title="expression" href=
        "#dt-expression">expression</a> used in the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a>
        (including an XPath expression used within a predicate in a
        <a title="pattern" href="#dt-pattern">pattern</a>). The
        <code>name</code> attribute specifies the name of the
        function. The value of the <code>name</code> attribute is a
        <a title="QName" href="#dt-qname">QName</a>, which is
        expanded as described in <a href="#qname"><i>5.1 Qualified
        Names</i></a>.</p>

        <p>An <a href=
        "#element-function"><code>xsl:function</code></a>
        declaration can only appear as a top-level element in a
        <span>stylesheet module</span>.</p>

        <p><a name="err-XTSE0740" id="err-XTSE0740"><span class=
        "error">[ERR XTSE0740]</span></a> A <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a>
        <span class="verb">must</span> have a prefixed name, to
        remove any risk of a clash with a function in the default
        function namespace. It is a <a title="static error" href=
        "#dt-static-error">static error</a> if the name has no
        prefix..</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>To prevent the namespace declaration used for the
          function name appearing in the result document, use the
          <code>exclude-result-prefixes</code> attribute on the
          <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element: see <a href="#lre-namespaces"><i>11.1.3
          Namespace Nodes for Literal Result Elements</i></a>.</p>

          <p>The prefix <span class="verb">must not</span> refer to
          a <a title="reserved namespace" href=
          "#dt-reserved-namespace">reserved namespace</a>:
          <span class="error">[see <a href="#err-XTSE0080">ERR
          XTSE0080</a>]</span></p>
        </div>

        <p>The content of the <a href=
        "#element-function"><code>xsl:function</code></a> element
        consists of zero or more <a href=
        "#element-param"><code>xsl:param</code></a> elements that
        specify the formal arguments of the function, followed by
        <span>a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that
        defines the value to be returned by the
        function.</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-arity"
        id="dt-arity" title="arity"></a>The <b>arity</b> of a
        stylesheet function is the number of <a href=
        "#element-param"><code>xsl:param</code></a> elements in the
        function definition.<span class="definition">]</span>
        Optional arguments are not allowed.</p>

        <p><a name="err-XTSE0760" id="err-XTSE0760"><span class=
        "error">[ERR XTSE0760]</span></a> Because arguments to a
        stylesheet function call <span class="verb">must</span> all
        be specified, the <a href=
        "#element-param"><code>xsl:param</code></a> elements within
        an <a href=
        "#element-function"><code>xsl:function</code></a> element
        <span class="verb">must not</span> specify a default value:
        this means they <span class="verb">must</span> be empty,
        and <span class="verb">must not</span> have a
        <code>select</code> attribute.</p>

        <p>A <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> is
        included in the <em>in-scope functions</em> of the static
        context for all XPath expressions used in the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a>,
        unless</p>

        <ul>
          <li>
            <p>there is another <a title="stylesheet function"
            href="#dt-stylesheet-function">stylesheet function</a>
            with the same name and <a title="arity" href=
            "#dt-arity">arity</a>, and higher <a title=
            "import precedence" href="#dt-import-precedence">import
            precedence</a>, or</p>
          </li>

          <li>
            <p>the <code>override</code> attribute has the value
            <code>no</code> and there is already a function with
            the same name and <a title="arity" href=
            "#dt-arity">arity</a> in the in-scope functions.</p>
          </li>
        </ul>

        <p>The optional <code>override</code> attribute defines
        what happens if this function has the same name and
        <a title="arity" href="#dt-arity">arity</a> as a function
        provided by the implementer or made available in the static
        context using an implementation-defined mechanism. If the
        <code>override</code> attribute has the value
        <code>yes</code>, then this function is used in preference;
        if it has the value <code>no</code>, then the other
        function is used in preference. The default value is
        <code>yes</code>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Specifying <code>override="yes"</code> ensures
          interoperable behavior: the same code will execute with
          all processors. Specifying <code>override="no"</code> is
          useful when writing a fallback implementation of a
          function that is available with some processors but not
          others: it allows the vendor's implementation of the
          function <span>(or a user's implementation written as an
          extension function)</span> to be used in preference to
          the stylesheet implementation, which is useful when the
          <span>extension function</span> is more efficient.</p>

          <p>The <code>override</code> attribute does <em>not</em>
          affect the rules for deciding which of several <a title=
          "stylesheet function" href=
          "#dt-stylesheet-function">stylesheet functions</a> with
          the same name and <a title="arity" href=
          "#dt-arity">arity</a> takes precedence.</p>
        </div>

        <p><a name="err-XTSE0770" id="err-XTSE0770"><span class=
        "error">[ERR XTSE0770]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> for
        a <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> to contain two or more
        functions with the same <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a>, the same <a title=
        "arity" href="#dt-arity">arity</a>, and the same <a title=
        "import precedence" href="#dt-import-precedence">import
        precedence</a>, unless there is another function with the
        same <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> and arity, and a
        higher import precedence.</p>

        <p>As defined in XPath, the function that is executed as
        the result of a function call is identified by looking in
        the in-scope functions of the static context for a function
        whose name and <a title="arity" href="#dt-arity">arity</a>
        matches the name and number of arguments in the function
        call.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Functions are not polymorphic. Although the XPath
          function call mechanism allows two functions to have the
          same name and different <a title="arity" href=
          "#dt-arity">arity</a>, it does not allow them to be
          distinguished by the types of their arguments.</p>
        </div>

        <p>The optional <code>as</code> attribute indicates the
        <a title="required type" href="#dt-required-type">required
        type</a> of the result of the function. The value of the
        <code>as</code> attribute is a <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-SequenceType">SequenceType</a><sup>
        <small>XP</small></sup>, as defined in <a href=
        "#xpath20">[XPath 2.0]</a>.</p>

        <p><a name="err-XTTE0780" id="err-XTTE0780"><span class=
        "error">[ERR XTTE0780]</span></a> If the <code>as</code>
        attribute is specified, then the result evaluated by the
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> (see
        <a href="#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>) is converted to the required type,
        using the <a title="function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>. It is a <a title="type errors" href=
        "#dt-type-error">type error</a> if this conversion fails.
        If the <code>as</code> attribute is omitted, the calculated
        result is used as supplied, and no conversion takes
        place.</p>

        <p>If a <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> has been
        defined with a particular <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a>, then a call on
        <a href=
        "#function-function-available"><code>function-available</code></a>
        will return true when called with an argument that is a
        <a title="lexical QName" href="#dt-lexical-qname">lexical
        QName</a> that expands to this same <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a>.</p>

        <p>The <a href="#element-param"><code>xsl:param</code></a>
        elements define the formal arguments to the function. These
        are interpreted positionally. When the function is called
        using a function-call in an XPath <a title="expression"
        href="#dt-expression">expression</a>, the first argument
        supplied is assigned to the first <a href=
        "#element-param"><code>xsl:param</code></a> element, the
        second argument supplied is assigned to the second <a href=
        "#element-param"><code>xsl:param</code></a> element, and so
        on.</p>

        <p>The <code>as</code> attribute of the <a href=
        "#element-param"><code>xsl:param</code></a> element defines
        the required type of the parameter. The rules for
        converting the values of the actual arguments supplied in
        the function call to the types required by each <a href=
        "#element-param"><code>xsl:param</code></a> element are
        defined in <a href="#xpath20">[XPath 2.0]</a>. The rules
        that apply are those for the case where <a title=
        "XPath 1.0 compatibility mode" href=
        "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
        is set to <code>false</code>.</p>

        <p><a name="err-XTTE0790" id="err-XTTE0790"><span class=
        "error">[ERR XTTE0790]</span></a> If the value of a
        parameter to a <a title="stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> cannot be
        converted to the required type, a <a title="type errors"
        href="#dt-type-error">type error</a> is signaled.</p>

        <p>If the <code>as</code> attribute is omitted, no
        conversion takes place and any value is accepted.</p>

        <p>Within the body of a stylesheet function, the <a title=
        "focus" href="#dt-focus">focus</a> is initially undefined;
        this means that any attempt to reference the context item,
        context position, or context size is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a>. <span>[XPDY0002]</span></p>

        <p>It is not possible within the body of the <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> to access
        the values of local variables that were in scope in the
        place where the function call was written. Global
        variables, however, remain available.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e14761" id="d5e14761"></a>Example: A
            Stylesheet Function
          </div>

          <p>The following example creates a recursive <a title=
          "stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a> named
          <code>str:reverse</code> that reverses the words in a
          supplied sentence, and then invokes this function from
          within a <a title="template rule" href=
          "#dt-template-rule">template rule</a>.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:str="http://example.com/namespace"
  version="2.0"
  exclude-result-prefixes="str"&gt;

&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:sequence  
     select="if (contains($sentence, ' '))
             then concat(str:reverse(substring-after($sentence, ' ')),
                         ' ',
                         substring-before($sentence, ' '))
             else $sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
&lt;output&gt;
  &lt;xsl:value-of select="str:reverse('DOG BITES MAN')"/&gt;
&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;
</pre>
          </div>

          <p>An alternative way of writing the same function is to
          implement the conditional logic at the XSLT level,
          thus:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:function name="str:reverse" as="xs:string"&gt;
  &lt;xsl:param name="sentence" as="xs:string"/&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="contains($sentence, ' ')"&gt;  
      &lt;xsl:sequence select="concat(str:reverse(substring-after($sentence, ' ')),
                                ' ',
                                substring-before($sentence, ' '))"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:sequence select="$sentence"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/xsl:function&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e14781" id="d5e14781"></a>Example: Declaring
            the Return Type of a Function
          </div>

          <p>The following example illustrates the use of the
          <code>as</code> attribute in a function definition. It
          returns a string containing the representation of its
          integer argument, expressed as a roman numeral. For
          example, the function call <code>num:roman(7)</code> will
          return the string <code>"vii"</code>. This example uses
          the <a href="#element-number"><code>xsl:number</code></a>
          instruction, described in <a href="#number"><i>12
          Numbering</i></a>. The <a href=
          "#element-number"><code>xsl:number</code></a> instruction
          returns a text node, and the <a title=
          "function conversion rules" href=
          "#dt-function-conversion-rules">function conversion
          rules</a> are invoked to convert this text node to the
          type declared in the <a href=
          "#element-function"><code>xsl:function</code></a>
          element, namely <code>xs:string</code>. So the text node
          is <a title="atomize" href="#dt-atomization">atomized</a>
          to a string.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;
</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="creating-new-nodes" id=
      "creating-new-nodes"></a>11 Creating Nodes and Sequences</h2>

      <p>This section describes instructions that directly create
      new nodes, or sequences of nodes and atomic values.</p>

      <div class="div2">
        <h3><a name="literal-result-element" id=
        "literal-result-element"></a>11.1 Literal Result
        Elements</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-literal-result-element" id="dt-literal-result-element"
        title="literal result element"></a>In a <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, an
        element in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> that does not belong to the
        <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
        namespace</a> and that is not an <a title=
        "extension instruction" href=
        "#dt-extension-instruction">extension instruction</a> (see
        <a href="#extension-instruction"><i>18.2 Extension
        Instructions</i></a>) is classified as a <b>literal result
        element</b>.<span class="definition">]</span> A literal
        result element is evaluated to construct a new element node
        with the same <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> <span>(that is, the
        same namespace URI, local name, and namespace
        prefix)</span>. The result of evaluating a literal result
        element is a node sequence containing one element, the
        newly constructed element node.</p>

        <p>The content of the element is a <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> (see
        <a href="#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>). The sequence obtained by evaluating
        this sequence constructor, after prepending any attribute
        nodes produced as described in <a href=
        "#attributes-for-lres"><i>11.1.2 Attribute Nodes for
        Literal Result Elements</i></a> and namespace nodes
        produced as described in <a href=
        "#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal
        Result Elements</i></a>, is used to construct the content
        of the element, following the rules in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a></p>

        <p>The base URI of the new element is copied from the base
        URI of the literal result element in the stylesheet, unless
        the content of the new element includes an
        <code>xml:base</code> attribute, in which case the base URI
        of the new element is the value of that attribute, resolved
        (if it is a relative URI) against the base URI of the
        literal result element in the stylesheet. (Note, however,
        that this is only relevant when creating a parentless
        element. When the literal result element is copied to form
        a child of an element or document node, the base URI of the
        new copy is taken from that of its new parent.)</p>

        <div class="div3">
          <h4><a name="setting-annotation-for-lre" id=
          "setting-annotation-for-lre"></a>11.1.1 Setting the Type
          Annotation for Literal Result Elements</h4>

          <p>The attributes <code>xsl:type</code> and
          <code>xsl:validation</code> may be used on a literal
          result element to invoke validation of the contents of
          the element against a type definition or element
          declaration in a schema, and to determine the <a title=
          "type annotation" href="#dt-annotation">type
          annotation</a> that the new element node will carry.
          These attributes also affect the type annotation carried
          by any elements and attributes that have the new element
          node as an ancestor. These two attributes are both
          optional, and if one is specified then the other
          <span class="verb">must</span> be omitted.</p>

          <p>The value of the <code>xsl:validation</code>
          attribute, if present, must be one of the values
          <code>strict</code>, <code>lax</code>,
          <code>preserve</code>, or <code>strip</code>. The value
          of the <code>xsl:type</code> attribute, if present, must
          be a <a title="QName" href="#dt-qname">QName</a>
          identifying a type definition that is present in the
          <a title="in-scope schema component" href=
          "#dt-in-scope-schema-component">in-scope schema
          components</a> for the stylesheet. Neither attribute may
          be specified as an <a title="attribute value template"
          href="#dt-attribute-value-template">attribute value
          template.</a> The effect of these attributes is described
          in <a href="#validation"><i>19.2 Validation</i></a>.</p>
        </div>

        <div class="div3">
          <h4><a name="attributes-for-lres" id=
          "attributes-for-lres"></a>11.1.2 Attribute Nodes for
          Literal Result Elements</h4>

          <p>Attribute nodes for a literal result element may be
          created by including <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instructions within the <a title="sequence constructor"
          href="#dt-sequence-constructor">sequence constructor</a>.
          Additionally, attribute nodes are created corresponding
          to the attributes of the literal result element in the
          stylesheet, and as a result of expanding the
          <code>xsl:use-attribute-sets</code> attribute of the
          literal result element, if present.</p>

          <p>The sequence that is used to construct the content of
          the literal result element (as described in <a href=
          "#constructing-complex-content"><i>5.7.1 Constructing
          Complex Content</i></a>) is the concatenation of the
          following four sequences, in order:</p>

          <ol class="enumar">
            <li>
              <p>The sequence of namespace nodes produced as
              described in <a href="#lre-namespaces"><i>11.1.3
              Namespace Nodes for Literal Result
              Elements</i></a>.</p>
            </li>

            <li>
              <p>The sequence of attribute nodes produced by
              expanding the <code>xsl:use-attribute-sets</code>
              attribute (if present) following the rules given in
              <a href="#attribute-sets"><i>10.2 Named Attribute
              Sets</i></a></p>
            </li>

            <li>
              <p>The attributes produced by processing the
              attributes of the literal result element itself,
              other than attributes in the <a title="" href=
              "#xslt-namespace">XSLT namespace</a>. The way these
              are processed is described below.</p>
            </li>

            <li>
              <p>The sequence produced by evaluating the contained
              <a title="sequence constructor" href=
              "#dt-sequence-constructor">sequence constructor</a>,
              if the element is not empty.</p>
            </li>
          </ol>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The significance of this order is that an attribute
            produced by an <code>xsl:attribute</code><span>,
            <a href="#element-copy"><code>xsl:copy</code></a>, or
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a></span>
            instruction in the content of the literal result
            element takes precedence over an attribute produced by
            expanding an attribute of the literal result element
            itself, which in turn takes precedence over an
            attribute produced by expanding the
            <code>xsl:use-attribute-sets</code> attribute. This is
            because of the rules in <a href=
            "#constructing-complex-content"><i>5.7.1 Constructing
            Complex Content</i></a>, which specify that when two or
            more attributes in the sequence have the same name, all
            but the last of the duplicates are discarded.</p>

            <p>Although the above rules place namespace nodes
            before attributes, this is not strictly necessary,
            because the rules in <a href=
            "#constructing-complex-content"><i>5.7.1 Constructing
            Complex Content</i></a> allow the namespaces and
            attributes to appear in any order so long as both come
            before other kinds of node. The order of namespace
            nodes and attribute nodes in the sequence has no effect
            on the relative position of the nodes in document order
            once they are added to a tree.</p>
          </div>

          <p>Each attribute of the literal result element, other
          than an attribute in the <a title="XSLT namespace" href=
          "#dt-xslt-namespace">XSLT namespace</a>, is processed to
          produce an attribute for the element in the <a title=
          "result tree" href="#dt-result-tree">result tree</a>.</p>

          <p>The value of such an attribute is interpreted as an
          <a title="attribute value template" href=
          "#dt-attribute-value-template">attribute value
          template</a>: it can therefore contain <a title=
          "expression" href="#dt-expression">expressions</a>
          contained in curly brackets (<code>{}</code>). The new
          attribute node will have the same <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> <span>(that is,
          the same namespace URI, local name, and namespace
          prefix)</span> as the attribute in the stylesheet tree,
          and its <a title="string value" href=
          "#dt-string-value">string value</a> will be the same as
          the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          attribute in the stylesheet tree. The <a title=
          "type annotation" href="#dt-annotation">type
          annotation</a> on the attribute will initially be
          <span><code>xs:untypedAtomic</code></span>, and the
          <a title="typed value" href="#dt-typed-value">typed
          value</a> of the attribute node will be the same as its
          <a title="string value" href="#dt-string-value">string
          value</a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The eventual <a title="type annotation" href=
            "#dt-annotation">type annotation</a> of the attribute
            in the <a title="result tree" href=
            "#dt-result-tree">result tree</a> depends on the
            <code>xsl:validation</code> and <code>xsl:type</code>
            attributes of the parent literal result element, and on
            the instructions used to create its ancestor elements.
            If the <code>xsl:validation</code> attribute is set to
            <code>preserve</code> or <code>strip</code>, the type
            annotation will be
            <span><code>xs:untypedAtomic</code></span>, and the
            <a title="typed value" href="#dt-typed-value">typed
            value</a> of the attribute node will be the same as its
            <a title="string value" href="#dt-string-value">string
            value</a>. If the <code>xsl:validation</code> attribute
            is set to <code>strict</code> or <code>lax</code>, or
            if the <code>xsl:type</code> attribute is used, the
            type annotation on the attribute will be set as a
            result of the schema validation process applied to the
            parent element. If neither attribute is present, the
            type annotation on the attribute will be
            <span><code>xs:untypedAtomic</code></span>.</p>
          </div>

          <p>If the name of a constructed attribute is
          <code>xml:id</code>, the processor must perform attribute
          value normalization by effectively applying the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-normalize-space">
          <code>normalize-space</code></a><sup><small>FO</small></sup>
          function to the value of the attribute, and the resulting
          attribute node must be given the <code>is-id</code>
          property.</p>

          <p><a name="err-XTRE0795" id="err-XTRE0795"><span class=
          "error">[ERR XTRE0795]</span></a> It is a <a title=
          "recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          the name of a constructed attribute is
          <code>xml:space</code> and the value is not either
          <code>default</code> or <code>preserve</code>. The
          <a title="optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to construct the attribute with the value
          as requested.. This applies whether the attribute is
          constructed using a literal result element, or by using
          the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>, or
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>
          instructions.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The <code>xml:base</code>, <code>xml:lang</code>,
            <code>xml:space</code>, and <code>xml:id</code>
            attributes have two effects in XSLT. They behave as
            standard XSLT attributes, which means for example that
            if they appear on a literal result element, they will
            be copied to the <a title="result tree" href=
            "#dt-result-tree">result tree</a> in the same way as
            any other attribute. In addition, they have their
            standard meaning as defined in the core XML
            specifications. Thus, an <code>xml:base</code>
            attribute in the stylesheet affects the base URI of the
            element on which it appears, and an
            <code>xml:space</code> attribute affects the
            interpretation of <a title="whitespace text node" href=
            "#dt-whitespace-text-node">whitespace text nodes</a>
            within that element. One consequence of this is that it
            is inadvisable to write these attributes as attribute
            value templates: although an XSLT processor will
            understand this notation, the XML parser will not. See
            also <a href="#namespace-aliasing"><i>11.1.4 Namespace
            Aliasing</i></a> which describes how to use <a href=
            "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
            with these attributes.</p>

            <p>The same is true of the schema-defined attributes
            <code>xsi:type</code>, <code>xsi:nil</code>,
            <span><code>xsi:noNamespaceSchemaLocation</code></span>,
            and <code>xsi:schemaLocation</code>. If the stylesheet
            is processed by a schema processor, these attributes
            will be recognized and interpreted by the schema
            processor, but <span>in addition the XSLT processor
            treats them like any other attribute on a literal
            result element: that is, their <a title=
            "effective value" href="#dt-effective-value">effective
            value</a> (after expanding <a title=
            "attribute value template" href=
            "#dt-attribute-value-template">attribute value
            templates</a>) is copied to the result tree in the same
            way as any other attribute.</span> If the <a title=
            "result tree" href="#dt-result-tree">result tree</a> is
            validated, the copied attributes will again be
            recognized and interpreted by the schema processor.</p>

            <p>None of these attributes will be generated in the
            <a title="result tree" href="#dt-result-tree">result
            tree</a> unless the stylesheet writes them to the
            result tree explicitly, in the same way as any other
            attribute.</p>
          </div>

          <p><a name="err-XTSE0805" id="err-XTSE0805"><span class=
          "error">[ERR XTSE0805]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if an attribute on a literal result element is in the
          <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, unless it is one of the attributes
          explicitly defined in this specification.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>If there is a need to create attributes in the XSLT
            namespace, this can be achieved using <a href=
            "#element-attribute"><code>xsl:attribute</code></a>, or
            by means of the <a href=
            "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
            declaration.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="lre-namespaces" id=
          "lre-namespaces"></a>11.1.3 Namespace Nodes for Literal
          Result Elements</h4>

          <p>The created element node will have a copy of the
          namespace nodes that were present on the element node in
          the stylesheet tree with the exception of any namespace
          node whose <a title="string value" href=
          "#dt-string-value">string value</a> is designated as an
          <b>excluded namespace</b>. Special considerations apply
          to aliased namespaces: see <a href=
          "#namespace-aliasing"><i>11.1.4 Namespace
          Aliasing</i></a></p>

          <p>The following namespaces are designated as excluded
          namespaces:</p>

          <ul>
            <li>
              <p>The <a title="XSLT namespace" href=
              "#dt-xslt-namespace">XSLT namespace</a> URI
              (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
            </li>

            <li>
              <p>A namespace URI declared as an extension namespace
              (see <a href="#extension-instruction"><i>18.2
              Extension Instructions</i></a>)</p>
            </li>

            <li>
              <p>A namespace URI designated by using an
              <code>[xsl:]exclude-result-prefixes</code> attribute
              either on the literal result element itself or on an
              ancestor element. The attribute <span class=
              "verb">must</span> be in the XSLT namespace only if
              its parent element is <em>not</em> in the XSLT
              namespace.</p>

              <p>The value of the attribute is either
              <code>#all</code>, or a whitespace-separated list of
              tokens, each of which is either a namespace prefix or
              <code>#default</code>. The namespace bound to each of
              the prefixes is designated as an excluded
              namespace.</p>

              <p><a name="err-XTSE0808" id=
              "err-XTSE0808"><span class="error">[ERR
              XTSE0808]</span></a> It is a <a title="static error"
              href="#dt-static-error">static error</a> if a
              namespace prefix is used within the
              <code>[xsl:]exclude-result-prefixes</code> attribute
              and there is no namespace binding in scope for that
              prefix.</p>

              <p>The default namespace of the parent element of the
              <code>[xsl:]exclude-result-prefixes</code> attribute
              (see <a href=
              "http://www.w3.org/TR/xpath-datamodel/#ElementNode">Section
              6.2 Element Nodes</a><sup><small>DM</small></sup>)
              may be designated as an excluded namespace by
              including <code>#default</code> in the list of
              namespace prefixes.</p>

              <p><a name="err-XTSE0809" id=
              "err-XTSE0809"><span class="error">[ERR
              XTSE0809]</span></a> It is a <a title="static error"
              href="#dt-static-error">static error</a> if the value
              <code>#default</code> is used within the
              <code>[xsl:]exclude-result-prefixes</code> attribute
              and the parent element of the
              <code>[xsl:]exclude-result-prefixes</code> attribute
              has no default namespace.</p>

              <p>The value <code>#all</code> indicates that all
              namespaces that are in scope for the stylesheet
              element that is the parent of the
              <code>[xsl:]exclude-result-prefixes</code> attribute
              are designated as excluded namespaces.</p>

              <p>The designation of a namespace as an excluded
              namespace is effective within the subtree of the
              stylesheet module rooted at the element bearing the
              <code>[xsl:]exclude-result-prefixes</code> attribute;
              a subtree rooted at an <a href=
              "#element-stylesheet"><code>xsl:stylesheet</code></a>
              element does not include any stylesheet modules
              imported or included by children of that <a href=
              "#element-stylesheet"><code>xsl:stylesheet</code></a>
              element.</p>
            </li>
          </ul>

          <p>The excluded namespaces, as described above,
          <em>only</em> affect namespace nodes copied from the
          stylesheet when processing a literal result element.
          There is no guarantee that an excluded namespace will not
          appear on the <a title="result tree" href=
          "#dt-result-tree">result tree</a> for some other reason.
          Namespace nodes are also written to the result tree as
          part of the process of namespace fixup (see <a href=
          "#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>), or
          as the result of instructions such as <a href=
          "#element-copy"><code>xsl:copy</code></a> and <a href=
          "#element-element"><code>xsl:element</code></a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>When a stylesheet uses a namespace declaration only
            for the purposes of addressing a <a title="source tree"
            href="#dt-source-tree">source tree</a>, specifying the
            prefix in the
            <code>[xsl:]exclude-result-prefixes</code> attribute
            will avoid superfluous namespace declarations in the
            serialized <a title="result tree" href=
            "#dt-result-tree">result tree</a>. The attribute is
            also useful to prevent namespaces used solely for the
            naming of stylesheet functions or extension functions
            from appearing in the serialized result tree.</p>
          </div>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e15344" id="d5e15344"></a>Example:
              Excluding Namespaces from the Result Tree
            </div>

            <p>For example, consider the following stylesheet:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:stylesheet xsl:version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"&gt;
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
            </div>

            <p>The result of this stylesheet will be:</p>

            <div class="exampleInner">
              <pre>
&lt;foo xmlns:d="d.uri"/&gt;
</pre>
            </div>

            <p>The namespaces <code>a.uri</code> and
            <code>b.uri</code> are excluded by virtue of the
            <code>exclude-result-prefixes</code> attribute on the
            <a href=
            "#element-stylesheet"><code>xsl:stylesheet</code></a>
            element, and the namespace <code>c.uri</code> is
            excluded by virtue of the
            <code>xsl:exclude-result-prefixes</code> attribute on
            the <code>foo</code> element. The setting
            <code>#all</code> does not affect the namespace
            <code>d.uri</code> because <code>d.uri</code> is not an
            in-scope namespace for the <a href=
            "#element-stylesheet"><code>xsl:stylesheet</code></a>
            element. The element in the <a title="result tree"
            href="#dt-result-tree">result tree</a> does not have a
            namespace node corresponding to
            <code>xmlns:a2="a.uri"</code> because the effect of
            <code>exclude-result-prefixes</code> is to designate
            the namespace URI <code>a.uri</code> as an excluded
            namespace, irrespective of how many prefixes are bound
            to this namespace URI.</p>

            <p>If the stylesheet is changed so that the literal
            result element has an attribute <code>b:bar="3"</code>,
            then the element in the <a title="result tree" href=
            "#dt-result-tree">result tree</a> will typically have a
            namespace declaration <code>xmlns:b="b.uri"</code>
            <span>(the processor may choose a different namespace
            prefix if this is necessary to avoid conflicts)</span>.
            The <code>exclude-result-prefixes</code> attribute
            makes <code>b.uri</code> an excluded namespace, so the
            namespace node is not automatically copied from the
            stylesheet, but the presence of an attribute whose name
            is in the namespace <code>b.uri</code> forces the
            namespace fixup process (see <a href=
            "#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>) to
            introduce a namespace node for this namespace.</p>
          </div>

          <p>A literal result element may have an optional
          <code>xsl:inherit-namespaces</code> attribute, with the
          value <code>yes</code> or <code>no</code>. The default
          value is <code>yes</code>. If the value is set to
          <code>yes</code>, or is omitted, then the namespace nodes
          created for the newly constructed element are copied to
          the children and descendants of the newly constructed
          element, as described in <a href=
          "#constructing-complex-content"><i>5.7.1 Constructing
          Complex Content</i></a>. If the value is set to
          <code>no</code>, then these namespace nodes are not
          automatically copied to the children. This may result in
          namespace undeclarations (such as <code>xmlns=""</code>
          or, in the case of XML 1.1, <code>xmlns:p=""</code>)
          appearing on the child elements when a <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> is serialized.</p>
        </div>

        <div class="div3">
          <h4><a name="namespace-aliasing" id=
          "namespace-aliasing"></a>11.1.4 Namespace Aliasing</h4>

          <p>When a stylesheet is used to define a transformation
          whose output is itself a stylesheet module, or in certain
          other cases where the result document uses namespaces
          that it would be inconvenient to use in the stylesheet,
          namespace aliasing can be used to declare a mapping
          between a namespace URI used in the stylesheet and the
          corresponding namespace URI to be used in the result
          document.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-literal-namespace-uri" id="dt-literal-namespace-uri"
          title="literal namespace URI"></a>A namespace URI in the
          stylesheet tree that is being used to specify a namespace
          URI in the <a title="result tree" href=
          "#dt-result-tree">result tree</a> is called a <b>literal
          namespace URI</b>.<span class="definition">]</span></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-target-namespace-uri" id="dt-target-namespace-uri"
          title="target namespace URI"></a>The namespace URI that
          is to be used in the <a title="result tree" href=
          "#dt-result-tree">result tree</a> as a substitute for a
          <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> is
          called the <b>target namespace URI</b>.<span class=
          "definition">]</span></p>

          <p>Either of the <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> or
          the <a title="target namespace URI" href=
          "#dt-target-namespace-uri">target namespace URI</a> can
          be <em>null</em>: this is treated as a reference to the
          set of names that are in no namespace.</p>

          <p class="element-syntax"><a name=
          "element-namespace-alias" id=
          "element-namespace-alias"></a><code>&lt;!-- Category:
          declaration --&gt;<br />
          &lt;xsl:namespace-alias<br />
          &#160;&#160;<b>stylesheet-prefix</b> = <var>prefix</var>
          | "#default"<br />
          &#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
          "#default"&#160;/&gt;</code></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name="dt-alias"
          id="dt-alias" title="alias"></a>A stylesheet can use the
          <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          element to declare that a <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> is
          being used as an <b>alias</b> for a <a title=
          "target namespace URI" href=
          "#dt-target-namespace-uri">target namespace
          URI</a>.<span class="definition">]</span></p>

          <p>The effect is that when names in the namespace
          identified by the <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> are
          copied to the <a title="result tree" href=
          "#dt-result-tree">result tree</a>, the namespace URI in
          the result tree will be the <a title=
          "target namespace URI" href=
          "#dt-target-namespace-uri">target namespace URI</a>,
          instead of the literal namespace URI. This applies
          to:</p>

          <ul>
            <li>
              <p>the namespace URI in the <a title="expanded-QName"
              href="#dt-expanded-qname">expanded-QName</a> of a
              literal result element in the stylesheet</p>
            </li>

            <li>
              <p>the namespace URI in the <a title="expanded-QName"
              href="#dt-expanded-qname">expanded-QName</a> of an
              attribute specified on a literal result element in
              the stylesheet</p>
            </li>
          </ul>

          <p>Where namespace aliasing changes the namespace URI
          part of the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> containing the
          name of an element or attribute node, the namespace
          prefix in that expanded-QName is replaced by the prefix
          indicated by the <code>result-prefix</code> attribute of
          the <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          declaration.</p>

          <p>The <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          element declares that the namespace URI bound to the
          prefix specified by the <code>stylesheet-prefix</code> is
          the <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a>,
          and the namespace URI bound to the prefix specified by
          the <code>result-prefix</code> attribute is the <a title=
          "target namespace URI" href=
          "#dt-target-namespace-uri">target namespace URI</a>.
          Thus, the <code>stylesheet-prefix</code> attribute
          specifies the namespace URI that will appear in the
          stylesheet, and the <code>result-prefix</code> attribute
          specifies the corresponding namespace URI that will
          appear in the <a title="result tree" href=
          "#dt-result-tree">result tree</a>.</p>

          <p>The default namespace (as declared by
          <code>xmlns</code>) may be specified by using
          <code>#default</code> instead of a prefix. <span>If no
          default namespace is in force, specifying
          <code>#default</code> denotes the null namespace URI.
          This allows elements that are in no namespace in the
          stylesheet to acquire a namespace in the result document,
          or vice versa.</span></p>

          <p>If a <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> is
          declared to be an alias for multiple different <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">target namespace URIs</a>,
          then the declaration with the highest <a title=
          "import precedence" href="#dt-import-precedence">import
          precedence</a> is used.</p>

          <p><a name="err-XTSE0810" id="err-XTSE0810"><span class=
          "error">[ERR XTSE0810]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if there is more than one such declaration with the same
          <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> and
          the same <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a> and
          different values for the <a title="target namespace URI"
          href="#dt-target-namespace-uri">target namespace URI</a>,
          unless there is also an <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          declaration with the same <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> and
          a higher import precedence.</p>

          <p><a name="err-XTSE0812" id="err-XTSE0812"><span class=
          "error">[ERR XTSE0812]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a value other than <code>#default</code> is specified
          for either the <code>stylesheet-prefix</code> or the
          <code>result-prefix</code> attributes of the <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          element when there is no in-scope binding for that
          namespace prefix.</p>

          <p>When a literal result element is processed, its
          namespace nodes are handled as follows:</p>

          <ul>
            <li>
              <p>A namespace node whose string value is a <a title=
              "literal namespace URI" href=
              "#dt-literal-namespace-uri">literal namespace URI</a>
              is not copied to the <a title="result tree" href=
              "#dt-result-tree">result tree</a>.</p>
            </li>

            <li>
              <p>A namespace node whose string value is a <a title=
              "target namespace URI" href=
              "#dt-target-namespace-uri">target namespace URI</a>
              is copied to the <a title="result tree" href=
              "#dt-result-tree">result tree</a>, whether or not the
              URI identifies an excluded namespace.</p>
            </li>
          </ul>

          <p>In the event that the same URI is used as a <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> and
          a <a title="target namespace URI" href=
          "#dt-target-namespace-uri">target namespace URI</a>, the
          second of these rules takes precedence.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>These rules achieve the effect that the element
            generated from the literal result element will have an
            in-scope namespace node that binds the
            <code>result-prefix</code> to the <a title=
            "target namespace URI" href=
            "#dt-target-namespace-uri">target namespace URI</a>,
            provided that the namespace declaration associating
            this prefix with this URI is in scope for both the
            <a href=
            "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
            instruction and for the literal result element.
            Conversely, the <code>stylesheet-prefix</code> and the
            <a title="literal namespace URI" href=
            "#dt-literal-namespace-uri">literal namespace URI</a>
            will not normally appear in the <a title="result tree"
            href="#dt-result-tree">result tree</a>.</p>
          </div>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e15715" id="d5e15715"></a>Example: Using
              <code>xsl:namespace-alias</code> to Generate a
              Stylesheet
            </div>

            <p>When literal result elements are being used to
            create element, attribute, or namespace nodes that use
            the <a title="XSLT namespace" href=
            "#dt-xslt-namespace">XSLT namespace</a> URI, the
            stylesheet may use an alias.</p>

            <p>For example, the stylesheet</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="2.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;axsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
            </div>

            <p>will generate an XSLT stylesheet from a document of
            the form:</p>

            <div class="exampleInner">
              <pre>
&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;
</pre>
            </div>

            <p>The output of the transformation will be a
            stylesheet such as the following. Whitespace has been
            added for clarity. Note that an implementation may
            output different namespace prefixes from those
            appearing in this example; however, the rules guarantee
            that there will be a namespace node that binds the
            prefix <code>xsl</code> to the URI
            <code>http://www.w3.org/1999/XSL/Transform</code>,
            which makes it safe to use the QName
            <code>xsl:version</code> in the content of the
            generated stylesheet.</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:stylesheet
  version="2.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
            </div>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It may be necessary also to use aliases for
            namespaces other than the XSLT namespace URI. For
            example, it can be useful to define an alias for the
            namespace
            <code>http://www.w3.org/2001/XMLSchema-instance</code>,
            so that the stylesheet can use the attributes
            <code>xsi:type</code>, <code>xsi:nil</code>, and
            <code>xsi:schemaLocation</code> on a literal result
            element, without running the risk that a schema
            processor will interpret these as applying to the
            stylesheet itself. Equally, literal result elements
            belonging to a namespace dealing with digital
            signatures might cause XSLT stylesheets to be
            mishandled by general-purpose security software; using
            an alias for the namespace would avoid the possibility
            of such mishandling.</p>
          </div>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e15762" id="d5e15762"></a>Example:
              Aliasing the XML Namespace
            </div>

            <p>It is possible to define an alias for the XML
            namespace.</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="2.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
            </div>

            <p>produces the output:</p>

            <div class="exampleInner">
              <pre>
&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;
</pre>
            </div>

            <p>This allows an <code>xml:space</code> attribute to
            be generated in the output without affecting the way
            the stylesheet is parsed. The same technique can be
            used for other attributes such as
            <code>xml:lang</code>, <code>xml:base</code>, and
            <code>xml:id</code>.</p>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Namespace aliasing is only necessary when literal
            result elements are used. The problem of reserved
            namespaces does not arise when using <a href=
            "#element-element"><code>xsl:element</code></a> and
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a> to
            construct the <a title="result tree" href=
            "#dt-result-tree">result tree</a>. Therefore, as an
            alternative to using <a href=
            "#element-namespace-alias"><code>xsl:namespace-alias</code></a>,
            it is always possible to achieve the desired effect by
            replacing literal result elements with <a href=
            "#element-element"><code>xsl:element</code></a> and
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>
            instructions.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="xsl-element" id="xsl-element"></a>11.2
        Creating Element Nodes Using <code>xsl:element</code></h3>

        <p class="element-syntax"><a name="element-element" id=
        "element-element"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:element<br />
        &#160;&#160;<b>name</b> = { <var>qname</var> }<br />
        &#160;&#160;namespace? = { <var>uri-reference</var> }<br />
        &#160;&#160;inherit-namespaces? = "yes" | "no"<br />
        &#160;&#160;use-attribute-sets? = <var>qnames</var><br />
        &#160;&#160;type? = <var>qname</var><br />
        &#160;&#160;validation? = "strict" | "lax" | "preserve" |
        "strip"&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:element&gt;</code></p>

        <p>The <a href=
        "#element-element"><code>xsl:element</code></a> instruction
        allows an element to be created with a computed name. The
        <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the element to
        be created is specified by a <span class=
        "verb">required</span> <code>name</code> attribute and an
        optional <code>namespace</code> attribute.</p>

        <p>The content of the <a href=
        "#element-element"><code>xsl:element</code></a> instruction
        is a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> for the
        children, attributes, and namespaces of the created
        element. The sequence obtained by evaluating this sequence
        constructor (see <a href="#sequence-constructors"><i>5.7
        Sequence Constructors</i></a>) is used to construct the
        content of the element, as described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>.</p>

        <p>The <a href=
        "#element-element"><code>xsl:element</code></a> element may
        have a <code>use-attribute-sets</code> attribute, whose
        value is a whitespace-separated list of QNames that
        identify <a href=
        "#element-attribute-set"><code>xsl:attribute-set</code></a>
        declarations. If this attribute is present, it is expanded
        as described in <a href="#attribute-sets"><i>10.2 Named
        Attribute Sets</i></a> to produce a sequence of attribute
        nodes. This sequence is prepended to the sequence produced
        as a result of evaluating the <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, as
        described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>.</p>

        <p>The result of evaluating the <a href=
        "#element-element"><code>xsl:element</code></a>
        instruction, except in error cases, is the newly
        constructed element node.</p>

        <p>The <code>name</code> attribute is interpreted as an
        <a title="attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>, whose <a title="effective value" href=
        "#dt-effective-value">effective value</a> <span class=
        "verb">must</span> be a <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a>.</p>

        <p><a name="err-XTDE0820" id="err-XTDE0820"><span class=
        "error">[ERR XTDE0820]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is not a <a title=
        "lexical QName" href="#dt-lexical-qname">lexical
        QName</a>.</p>

        <p><a name="err-XTDE0830" id="err-XTDE0830"><span class=
        "error">[ERR XTDE0830]</span></a> In the case of an
        <a href="#element-element"><code>xsl:element</code></a>
        instruction with no <code>namespace</code> attribute, it is
        a <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is a <a title="QName" href=
        "#dt-qname">QName</a> whose prefix is not declared in an
        in-scope namespace declaration for the <a href=
        "#element-element"><code>xsl:element</code></a>
        instruction.</p>

        <p>If the <code>namespace</code> attribute is not present
        then the <a title="QName" href="#dt-qname">QName</a> is
        expanded into an <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> using the namespace
        declarations in effect for the <a href=
        "#element-element"><code>xsl:element</code></a> element,
        including any default namespace declaration.</p>

        <p>If the <code>namespace</code> attribute is present, then
        it too is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>. The <a title="effective value" href=
        "#dt-effective-value">effective value</a>
        <span><span class="verb">must</span> be in the lexical
        space of the <code>xs:anyURI</code> type.</span> If the
        string is zero-length, then the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> of the element
        has a null namespace URI. Otherwise, the string is used as
        the namespace URI of the <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the element to
        be created. The local part of the <a title="lexical QName"
        href="#dt-lexical-qname">lexical QName</a> specified by the
        <code>name</code> attribute is used as the local part of
        the <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the element to
        be created.</p>

        <p><a name="err-XTDE0835" id="err-XTDE0835"><span class=
        "error">[ERR XTDE0835]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>namespace</code> attribute is not in the lexical
        space of the <code>xs:anyURI</code> data type.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The <span>XDM</span> data model requires the name of a
          node to be an instance of <code>xs:QName</code>, and XML
          Schema defines the namespace part of an
          <code>xs:QName</code> to be an instance of
          <code>xs:anyURI</code>. However, the schema
          specification, and the specifications that it refers to,
          give implementations some flexibility in how strictly
          they enforce these constraints.</p>
        </div>

        <p>The prefix of the <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a> specified in the
        <code>name</code> attribute (or the absence of a prefix) is
        copied to the prefix part of the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> representing
        the name of the new element node. In the event of a
        conflict <span>a prefix may subsequently be added, changed,
        or removed</span> during the namespace fixup process (see
        <a href="#namespace-fixup"><i>5.7.3 Namespace
        Fixup</i></a>).</p>

        <p>The <a href=
        "#element-element"><code>xsl:element</code></a> instruction
        has an optional <code>inherit-namespaces</code> attribute,
        with the value <code>yes</code> or <code>no</code>. The
        default value is <code>yes</code>. If the value is set to
        <code>yes</code>, or is omitted, then the namespace nodes
        created for the newly constructed element (whether these
        were copied from those of the source node, or generated as
        a result of namespace fixup) are copied to the children and
        descendants of the newly constructed element, as described
        in <a href="#constructing-complex-content"><i>5.7.1
        Constructing Complex Content</i></a>. If the value is set
        to <code>no</code>, then these namespace nodes are not
        automatically copied to the children. This may result in
        namespace undeclarations (such as <code>xmlns=""</code> or,
        in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>)
        appearing on the child elements when a <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a> is serialized.</p>

        <p>The base URI of the new element is copied from the base
        URI of the <a href=
        "#element-element"><code>xsl:element</code></a> instruction
        in the stylesheet, unless the content of the new element
        includes an <code>xml:base</code> attribute, in which case
        the base URI of the new element is the value of that
        attribute, resolved (if it is a relative URI) against the
        base URI of the <a href=
        "#element-element"><code>xsl:element</code></a> instruction
        in the stylesheet. (Note, however, that this is only
        relevant when creating parentless elements. When the new
        element is copied to form a child of an element or document
        node, the base URI of the new copy is taken from that of
        its new parent.)</p>

        <div class="div3">
          <h4><a name="annotation-for-constructed-element" id=
          "annotation-for-constructed-element"></a>11.2.1 Setting
          the Type Annotation for a Constructed Element Node</h4>

          <p>The optional attributes <code>type</code> and
          <code>validation</code> may be used on the <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction to invoke validation of the contents of the
          element against a type definition or element declaration
          in a schema, and to determine the <a title=
          "type annotation" href="#dt-annotation">type
          annotation</a> that the new element node will carry.
          These attributes also affect the type annotation carried
          by any elements and attributes that have the new element
          node as an ancestor. These two attributes are both
          optional, and if one is specified then the other
          <span class="verb">must</span> be omitted. The permitted
          values of these attributes and their semantics are
          described in <a href="#validation"><i>19.2
          Validation</i></a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The final type annotation of the element in the
            <a title="result tree" href="#dt-result-tree">result
            tree</a> also depends on the <code>type</code> and
            <code>validation</code> attributes of the instructions
            used to create the ancestors of the element.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-attributes" id=
        "creating-attributes"></a>11.3 Creating Attribute Nodes
        Using <code>xsl:attribute</code></h3>

        <p class="element-syntax"><a name="element-attribute" id=
        "element-attribute"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:attribute<br />
        &#160;&#160;<b>name</b> = { <var>qname</var> }<br />
        &#160;&#160;namespace? = { <var>uri-reference</var> }<br />
        &#160;&#160;select? = <var>expression</var><br />
        &#160;&#160;separator? = { <var>string</var> }<br />
        &#160;&#160;type? = <var>qname</var><br />
        &#160;&#160;validation? = "strict" | "lax" | "preserve" |
        "strip"&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:attribute&gt;</code></p>

        <p>The <a href=
        "#element-attribute"><code>xsl:attribute</code></a> element
        can be used to add attributes to result elements whether
        created by literal result elements in the stylesheet or by
        instructions such as <a href=
        "#element-element"><code>xsl:element</code></a> or <a href=
        "#element-copy"><code>xsl:copy</code></a>. The <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the attribute to
        be created is specified by a <span class=
        "verb">required</span> <code>name</code> attribute and an
        optional <code>namespace</code> attribute. <span>Except in
        error cases,</span> the result of evaluating an <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instruction is the newly constructed attribute node.</p>

        <p>The string value of the new attribute node may be
        defined either by using the <code>select</code> attribute,
        or by the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that
        forms the content of the <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        element. These are mutually exclusive. If neither is
        present, the value of the new attribute node will be a
        zero-length string. The way in which the value is
        constructed is specified in <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a>.</p>

        <p><a name="err-XTSE0840" id="err-XTSE0840"><span class=
        "error">[ERR XTSE0840]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <code>select</code> attribute of the <a href=
        "#element-attribute"><code>xsl:attribute</code></a> element
        is present unless the element has empty content.</p>

        <p>If the <code>separator</code> attribute is present, then
        the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of this attribute
        is used to separate adjacent items in the result sequence,
        as described in <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a>. In the absence of this attribute, the
        default separator is a single space (#x20) when the content
        is specified using the <code>select</code> attribute, or a
        zero-length string when the content is specified using a
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>.</p>

        <p>The <code>name</code> attribute is interpreted as an
        <a title="attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a><span>, whose <a title="effective value" href=
        "#dt-effective-value">effective value</a> <span class=
        "verb">must</span> be a <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a>.</span></p>

        <p><a name="err-XTDE0850" id="err-XTDE0850"><span class=
        "error">[ERR XTDE0850]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is not a <a title=
        "lexical QName" href="#dt-lexical-qname">lexical
        QName</a>.</p>

        <p><a name="err-XTDE0855" id="err-XTDE0855"><span class=
        "error">[ERR XTDE0855]</span></a> In the case of an
        <a href="#element-attribute"><code>xsl:attribute</code></a>
        instruction with no <code>namespace</code> attribute, it is
        a <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is the string
        <code>xmlns</code>.</p>

        <p><a name="err-XTDE0860" id="err-XTDE0860"><span class=
        "error">[ERR XTDE0860]</span></a> In the case of an
        <a href="#element-attribute"><code>xsl:attribute</code></a>
        instruction with no <code>namespace</code> attribute, it is
        a <a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is a <a title="lexical QName"
        href="#dt-lexical-qname">lexical QName</a> whose prefix is
        not declared in an in-scope namespace declaration for the
        <a href="#element-attribute"><code>xsl:attribute</code></a>
        instruction.</p>

        <p>If the <code>namespace</code> attribute is not present,
        then the <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a> is expanded into an
        <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> using the namespace
        declarations in effect for the <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        element, <em>not</em> including any default namespace
        declaration.</p>

        <p>If the <code>namespace</code> attribute is present, then
        it too is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>. The <a title="effective value" href=
        "#dt-effective-value">effective value</a>
        <span><span class="verb">must</span> be in the lexical
        space of the <code>xs:anyURI</code> type.</span> If the
        string is zero-length, then the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> of the
        attribute has a null namespace URI. Otherwise, the string
        is used as the namespace URI of the <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the attribute to
        be created. The local part of the <a title="lexical QName"
        href="#dt-lexical-qname">lexical QName</a> specified by the
        <code>name</code> attribute is used as the local part of
        the <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of the attribute to
        be created.</p>

        <p><a name="err-XTDE0865" id="err-XTDE0865"><span class=
        "error">[ERR XTDE0865]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>namespace</code> attribute is not in the lexical
        space of the <code>xs:anyURI</code> data type.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The same considerations apply as for elements:
          <span class="error">[see <a href="#err-XTDE0835">ERR
          XTDE0835</a>]</span> in <a href="#xsl-element"><i>11.2
          Creating Element Nodes Using xsl:element</i></a> .</p>
        </div>

        <p>The prefix of the <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a> specified in the
        <code>name</code> attribute (or the absence of a prefix) is
        copied to the prefix part of the <a title="expanded-QName"
        href="#dt-expanded-qname">expanded-QName</a> representing
        the name of the new attribute node. In the event of a
        conflict this prefix (or absence of a prefix) may
        subsequently be changed during the namespace fixup process
        (see <a href="#namespace-fixup"><i>5.7.3 Namespace
        Fixup</i></a>). If the attribute is in a non-null namespace
        and no prefix is specified, then the namespace fixup
        process will invent a prefix.</p>

        <p>If the name of a constructed attribute is
        <code>xml:id</code>, <span>the processor must perform
        attribute value normalization by effectively applying the
        <a href=
        "http://www.w3.org/TR/xpath-functions/#func-normalize-space">
        <code>normalize-space</code></a><sup><small>FO</small></sup>
        function to the value of the attribute,</span> and the
        resulting attribute node must be given the
        <code>is-id</code> property. This applies whether the
        attribute is constructed using the <a href=
        "#element-attribute"><code>xsl:attribute</code></a>
        instruction or whether it is constructed using an attribute
        of a literal result element. This does not imply any
        constraints on the value of the attribute, or on its
        uniqueness, and it does not affect the <a title=
        "type annotation" href="#dt-annotation">type annotation</a>
        of the attribute, unless the containing document is
        validated.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The effect of setting the <code>is-id</code> property
          is that the parent element can be located within the
          containing document by use of the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
          <small>FO</small></sup> function. In effect, XSLT when
          constructing a document performs some of the functions of
          an <code>xml:id</code> processor, as defined in <a href=
          "#xml-id">[xml:id]</a>; the other aspects of
          <code>xml:id</code> processing are performed during
          validation.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e16466" id="d5e16466"></a>Example: Creating
            a List-Valued Attribute
          </div>

          <p>The following instruction creates the attribute
          <code>colors="red green blue"</code>:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e16476" id="d5e16476"></a>Example:
            Namespaces are not Attributes
          </div>

          <p>It is not an error to write:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"&gt;http://www.w3.org/1999/XSL/Transform&lt;/xsl:attribute&gt;
</pre>
          </div>

          <p>However, this will not result in the namespace
          declaration
          <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code>
          being output. Instead, it will produce an attribute node
          with local name <code>xsl</code>, and with a
          system-allocated namespace prefix mapped to the namespace
          URI <code>file://some.namespace</code>. This is because
          the namespace fixup process is not allowed to use
          <code>xmlns</code> as the name of a namespace node.</p>
        </div>

        <p>As described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>, <span>in a sequence that is used
        to construct the content of an element,</span> any
        attribute nodes <span class="verb">must</span> appear in
        the sequence before any element, text, comment, or
        processing instruction nodes. Where the sequence contains
        two or more attribute nodes with the same <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a>, the one that comes
        last is the only one that takes effect.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>If a collection of attributes is generated repeatedly,
          this can be done conveniently by using named attribute
          sets: see <a href="#attribute-sets"><i>10.2 Named
          Attribute Sets</i></a></p>
        </div>

        <div class="div3">
          <h4><a name="annotation-for-constructed-attribute" id=
          "annotation-for-constructed-attribute"></a>11.3.1 Setting
          the Type Annotation for a Constructed Attribute Node</h4>

          <p>The optional attributes <code>type</code> and
          <code>validation</code> may be used on the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction to invoke validation of the contents of the
          attribute against a type definition or attribute
          declaration in a schema, and to determine the <a title=
          "type annotation" href="#dt-annotation">type
          annotation</a> that the new attribute node will carry.
          These two attributes are both optional, and if one is
          specified then the other <span class="verb">must</span>
          be omitted. The permitted values of these attributes and
          their semantics are described in <a href=
          "#validation"><i>19.2 Validation</i></a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The final <a title="type annotation" href=
            "#dt-annotation">type annotation</a> of the attribute
            in the <a title="result tree" href=
            "#dt-result-tree">result tree</a> also depends on the
            <code>type</code> and <code>validation</code>
            attributes of the instructions used to create the
            ancestors of the attribute.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-text-nodes" id=
        "creating-text-nodes"></a>11.4 Creating Text Nodes</h3>

        <p>This section describes three different ways of creating
        text nodes: by means of literal text nodes in the
        stylesheet, or by using the <a href=
        "#element-text"><code>xsl:text</code></a> and <a href=
        "#element-value-of"><code>xsl:value-of</code></a>
        instructions. It is also possible to create text nodes
        using the <a href=
        "#element-number"><code>xsl:number</code></a> instruction
        described in <a href="#number"><i>12 Numbering</i></a>.</p>

        <p>If and when the sequence that results from evaluating a
        <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> is used
        to form the content of a node, as described in <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a> and <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>, adjacent text nodes in the
        sequence are merged. Within the sequence itself, however,
        they exist as distinct nodes.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e16577" id="d5e16577"></a>Example: A
            sequence of text nodes
          </div>

          <p>The following function returns a sequence of three
          text nodes:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;
</pre>
          </div>

          <p>When this function is called as follows:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:value-of select="f:wrap('---')"/&gt;
</pre>
          </div>

          <p>the result is:</p>

          <div class="exampleInner">
            <pre>
(---)
</pre>
          </div>

          <p>No additional spaces are inserted, because the calling
          <a href="#element-value-of"><code>xsl:value-of</code></a>
          instruction merges adjacent text nodes before atomizing
          the sequence. However, the result of the instruction:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;
</pre>
          </div>

          <p>is:</p>

          <div class="exampleInner">
            <pre>
( --- )
</pre>
          </div>

          <p>because in this case the three text nodes are atomized
          to form three strings, and spaces are inserted between
          adjacent strings.</p>
        </div>

        <p>It is possible to construct text nodes whose string
        value is zero-length. A zero-length text node, when
        atomized, produces a zero-length string. However,
        zero-length text nodes are ignored when they appear in a
        sequence that is used to form the content of a node, as
        described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a> and <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a>.</p>

        <div class="div3">
          <h4><a name="literal-text-nodes" id=
          "literal-text-nodes"></a>11.4.1 Literal Text Nodes</h4>

          <p>A <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> can
          contain text nodes. Each text node in a sequence
          constructor remaining after <a title=
          "whitespace text node" href=
          "#dt-whitespace-text-node">whitespace text nodes</a> have
          been stripped as specified in <a href=
          "#stylesheet-stripping"><i>4.2 Stripping Whitespace from
          the Stylesheet</i></a> will construct a new text node
          with the same <a title="string value" href=
          "#dt-string-value">string value</a>. The resulting text
          node is added to the result of the containing sequence
          constructor.</p>

          <p>Text is processed at the tree level. Thus, markup of
          <code>&amp;lt;</code> in a template will be represented
          in the stylesheet tree by a text node that includes the
          character <code>&lt;</code>. This will create a text node
          in the <a title="result tree" href=
          "#dt-result-tree">result tree</a> that contains a
          <code>&lt;</code> character, which will be represented by
          the markup <code>&amp;lt;</code> (or an equivalent
          character reference) when the result tree is serialized
          as an XML document, unless otherwise specified using
          <a title="character map" href=
          "#dt-character-map">character maps</a> (see <a href=
          "#character-maps"><i>20.1 Character Maps</i></a>) or
          <code>disable-output-escaping</code> (see <a href=
          "#disable-output-escaping"><i>20.2 Disabling Output
          Escaping</i></a>).</p>
        </div>

        <div class="div3">
          <h4><a name="xsl-text" id="xsl-text"></a>11.4.2 Creating
          Text Nodes Using <code>xsl:text</code></h4>

          <p class="element-syntax"><a name="element-text" id=
          "element-text"></a><code>&lt;!-- Category: instruction
          --&gt;<br />
          &lt;xsl:text<br />
          &#160;&#160;<span class=
          "grayed">[disable-output-escaping]?</span> = "yes" |
          "no"&gt;<br />
          &#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
          &lt;/xsl:text&gt;</code></p>

          <p>The <a href="#element-text"><code>xsl:text</code></a>
          element is evaluated to contruct a new text node. The
          content of the <a href=
          "#element-text"><code>xsl:text</code></a> element is a
          single text node whose value forms the <a title=
          "string value" href="#dt-string-value">string value</a>
          of the <span>new</span> text node. An <a href=
          "#element-text"><code>xsl:text</code></a> element may be
          empty, in which case the result of evaluating the
          instruction is <span>a text node whose string value is
          the zero-length string</span>.</p>

          <p>The result of evaluating an <a href=
          "#element-text"><code>xsl:text</code></a> instruction is
          the newly constructed text node.</p>

          <p>A text node that is an immediate child of an <a href=
          "#element-text"><code>xsl:text</code></a> instruction
          will not be stripped from the stylesheet tree, even if it
          consists entirely of whitespace (see <a href=
          "#strip"><i>4.4 Stripping Whitespace from a Source
          Tree</i></a>).</p>

          <p>For the effect of the <a title="deprecated" href=
          "#dt-deprecated">deprecated</a>
          <code>disable-output-escaping</code> attribute, see
          <a href="#disable-output-escaping"><i>20.2 Disabling
          Output Escaping</i></a></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It is not always necessary to use the <a href=
            "#element-text"><code>xsl:text</code></a> instruction
            to write text nodes to the <a title="result tree" href=
            "#dt-result-tree">result tree</a>. Literal text can be
            written to the result tree by including it anywhere in
            a <a title="sequence constructor" href=
            "#dt-sequence-constructor">sequence constructor</a>,
            while computed text can be output using the <a href=
            "#element-value-of"><code>xsl:value-of</code></a>
            instruction. The principal reason for using <a href=
            "#element-text"><code>xsl:text</code></a> is that it
            offers improved control over whitespace handling.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="value-of" id="value-of"></a>11.4.3
          Generating Text with <a href=
          "#element-value-of"><code>xsl:value-of</code></a></h4>

          <p>Within a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, the
          <a href="#element-value-of"><code>xsl:value-of</code></a>
          instruction can be used to generate computed text nodes.
          The <a href=
          "#element-value-of"><code>xsl:value-of</code></a>
          instruction computes the text using an <a title=
          "expression" href="#dt-expression">expression</a> that is
          specified as the value of the <code>select</code>
          attribute, or by means of contained instructions. This
          might, for example, extract text from a <a title=
          "source tree" href="#dt-source-tree">source tree</a> or
          insert the value of a variable.</p>

          <p class="element-syntax"><a name="element-value-of" id=
          "element-value-of"></a><code>&lt;!-- Category:
          instruction --&gt;<br />
          &lt;xsl:value-of<br />
          &#160;&#160;select? = <var>expression</var><br />
          &#160;&#160;separator? = { <var>string</var> }<br />
          &#160;&#160;<span class=
          "grayed">[disable-output-escaping]?</span> = "yes" |
          "no"&gt;<br />
          &#160;&#160;&lt;!-- Content:
          <var>sequence-constructor</var> --&gt;<br />
          &lt;/xsl:value-of&gt;</code></p>

          <p>The <a href=
          "#element-value-of"><code>xsl:value-of</code></a>
          instruction is evaluated to construct a new text node;
          the result of the instruction is the newly constructed
          text node.</p>

          <p>The string value of the new text node may be defined
          either by using the <code>select</code> attribute, or by
          the <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> (see
          <a href="#sequence-constructors"><i>5.7 Sequence
          Constructors</i></a>) that forms the content of the
          <a href="#element-value-of"><code>xsl:value-of</code></a>
          element. These are mutually exclusive, and one of them
          must be present. The way in which the value is
          constructed is specified in <a href=
          "#constructing-simple-content"><i>5.7.2 Constructing
          Simple Content</i></a>.</p>

          <p><a name="err-XTSE0870" id="err-XTSE0870"><span class=
          "error">[ERR XTSE0870]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the <code>select</code> attribute of the <a href=
          "#element-value-of"><code>xsl:value-of</code></a> element
          is present when the content of the element is non-empty,
          or if the <code>select</code> attribute is absent when
          the content is empty.</p>

          <p>If the <code>separator</code> attribute is present,
          then the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of this
          attribute is used to separate adjacent items in the
          result sequence, as described in <a href=
          "#constructing-simple-content"><i>5.7.2 Constructing
          Simple Content</i></a>. In the absence of this attribute,
          the default separator is a single space (#x20) when the
          content is specified using the <code>select</code>
          attribute, or a zero-length string when the content is
          specified using a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>.</p>

          <p>Special rules apply when <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled for the instruction. If no
          <code>separator</code> attribute is present, and if the
          <code>select</code> attribute is present, then all items
          in the <a title="atomize" href=
          "#dt-atomization">atomized</a> result sequence other than
          the first are ignored.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e16837" id="d5e16837"></a>Example:
              Generating a List with Separators
            </div>

            <p>The instruction:</p>

            <div class="exampleInner">
              <pre>
&lt;x&gt;&lt;xsl:value-of select="1 to 4" separator="|"/&gt;&lt;/x&gt;
</pre>
            </div>

            <p>produces the output:</p>

            <div class="exampleInner">
              <pre>
&lt;x&gt;1|2|3|4&lt;/x&gt;
</pre>
            </div>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a> element
            can be used to copy a sequence of nodes to the
            <a title="result tree" href="#dt-result-tree">result
            tree</a> without <a title="atomize" href=
            "#dt-atomization">atomization</a>. See <a href=
            "#copy-of"><i>11.9.2 Deep Copy</i></a>.</p>
          </div>

          <p>For the effect of the <a title="deprecated" href=
          "#dt-deprecated">deprecated</a>
          <code>disable-output-escaping</code> attribute, see
          <a href="#disable-output-escaping"><i>20.2 Disabling
          Output Escaping</i></a></p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-document-nodes" id=
        "creating-document-nodes"></a>11.5 Creating Document
        Nodes</h3>

        <p class="element-syntax"><a name="element-document" id=
        "element-document"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:document<br />
        &#160;&#160;validation? = "strict" | "lax" | "preserve" |
        "strip"<br />
        &#160;&#160;type? = <var>qname</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:document&gt;</code></p>

        <p>The <a href=
        "#element-document"><code>xsl:document</code></a>
        instruction is used to create a new document node. The
        content of the <a href=
        "#element-document"><code>xsl:document</code></a> element
        is a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> for the
        children of the new document node. A document node is
        created, and the sequence obtained by evaluating the
        sequence constructor is used to construct the content of
        the document, as described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>. The <a title="temporary tree"
        href="#dt-temporary-tree">temporary tree</a> rooted at this
        document node forms the <a title="result tree" href=
        "#dt-result-tree">result tree</a>.</p>

        <p>Except in error situations, the result of evaluating the
        <a href="#element-document"><code>xsl:document</code></a>
        instruction is a single node, the newly constructed
        document node.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The new document is not serialized. To construct a
          document that is to form a final result rather than an
          intermediate result, use the <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction described in <a href=
          "#creating-result-trees"><i>19.1 Creating Final Result
          Trees</i></a>.</p>
        </div>

        <p>The optional attributes <code>type</code> and
        <code>validation</code> may be used on the <a href=
        "#element-document"><code>xsl:document</code></a>
        instruction to validate the contents of the new document,
        and to determine the <a title="type annotation" href=
        "#dt-annotation">type annotation</a> that elements and
        attributes within the <a title="result tree" href=
        "#dt-result-tree">result tree</a> will carry. The permitted
        values and their semantics are described in <a href=
        "#validating-document-nodes"><i>19.2.2 Validating Document
        Nodes</i></a>.</p>

        <p>The base URI of the new document node is taken from the
        base URI of the <a href=
        "#element-document"><code>xsl:document</code></a>
        instruction.</p>

        <p>The <code>document-uri</code> and
        <code>unparsed-entities</code> properties of the new
        document node are set to empty.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e16953" id="d5e16953"></a>Example: Checking
            Uniqueness Constraints in a Temporary Tree
          </div>

          <p>The following example creates a temporary tree held in
          a variable. The use of an enclosed <a href=
          "#element-document"><code>xsl:document</code></a>
          instruction ensures that uniqueness constraints defined
          in the schema for the relevant elements are checked.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-processing-instructions" id=
        "creating-processing-instructions"></a>11.6 Creating
        Processing Instructions</h3>

        <p class="element-syntax"><a name=
        "element-processing-instruction" id=
        "element-processing-instruction"></a><code>&lt;!--
        Category: instruction --&gt;<br />
        &lt;xsl:processing-instruction<br />
        &#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
        &#160;&#160;select? = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:processing-instruction&gt;</code></p>

        <p>The <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        element is evaluated to create a processing instruction
        node.</p>

        <p>The <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        element has a <span class="verb">required</span>
        <code>name</code> attribute that specifies the name of the
        processing instruction node. The value of the
        <code>name</code> attribute is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>.</p>

        <p>The string value of the new processing-instruction node
        may be defined either by using the <code>select</code>
        attribute, or by the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that
        forms the content of the <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        element. These are mutually exclusive. If neither is
        present, the string value of the new processing-instruction
        node will be a zero-length string. The way in which the
        value is constructed is specified in <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a>.</p>

        <p><a name="err-XTSE0880" id="err-XTSE0880"><span class=
        "error">[ERR XTSE0880]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <code>select</code> attribute of the <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        element is present unless the element has empty
        content.</p>

        <p>Except in error situations, the result of evaluating the
        <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        instruction is a single node, the newly constructed
        processing instruction <span>node</span>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e17032" id="d5e17032"></a>Example: Creating
            a Processing Instruction
          </div>

          <p>This instruction:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;)"/&gt;
</pre>
          </div>

          <p>creates the processing instruction</p>

          <div class="exampleInner">
            <pre>
&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;
</pre>
          </div>

          <p>Note that the <code>xml-stylesheet</code> processing
          instruction contains <em>pseudo-attributes</em> in the
          form <code>name="value"</code>. Although these have the
          same textual form as attributes in an element start tag,
          they are not represented as <span>XDM</span> attribute
          nodes, and cannot therefore be constructed using <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instructions.</p>
        </div>

        <p><a name="err-XTDE0890" id="err-XTDE0890"><span class=
        "error">[ERR XTDE0890]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is not both an <a href=
        "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
        <small>Names</small></sup> and a <a href=
        "http://www.w3.org/TR/2000/REC-xml-20001006#NT-PITarget">PITarget</a><sup>
        <small>XML</small></sup>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p><span>Because these rules disallow the name
          <code>xml</code>,</span> the <a href=
          "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
          cannot be used to output an XML declaration. The <a href=
          "#element-output"><code>xsl:output</code></a> declaration
          should be used to control this instead (see <a href=
          "#serialization"><i>20 Serialization</i></a>).</p>
        </div>

        <p>If the result of evaluating the content of the <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        contains the string <code>?&gt;</code>, this string is
        modified by inserting a space between the <code>?</code>
        and <code>&gt;</code> characters.</p>

        <p>The base URI of the new processing-instruction is copied
        from the base URI of the <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
        element in the stylesheet. (Note, however, that this is
        only relevant when creating a parentless processing
        instruction. When the new processing instruction is copied
        to form a child of an element or document node, the base
        URI of the new copy is taken from that of its new
        parent.)</p>
      </div>

      <div class="div2">
        <h3><a name="creating-namespace-nodes" id=
        "creating-namespace-nodes"></a>11.7 Creating Namespace
        Nodes</h3>

        <p class="element-syntax"><a name="element-namespace" id=
        "element-namespace"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:namespace<br />
        &#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
        &#160;&#160;select? = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:namespace&gt;</code></p>

        <p>The <a href=
        "#element-namespace"><code>xsl:namespace</code></a> element
        is evaluated to create a namespace node. Except in error
        situations, the result of evaluating the <a href=
        "#element-namespace"><code>xsl:namespace</code></a>
        instruction is a single node, the newly constructed
        namespace node.</p>

        <p>The <a href=
        "#element-namespace"><code>xsl:namespace</code></a> element
        has a <span class="verb">required</span> <code>name</code>
        attribute that specifies the name of the namespace node
        (that is, the namespace prefix). The value of the
        <code>name</code> attribute is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>. If the <span><a title="effective value" href=
        "#dt-effective-value">effective value</a></span> of the
        <code>name</code> attribute is a zero-length string, a
        namespace node is added for the default namespace.</p>

        <p>The string value of the new namespace node (that is, the
        namespace URI) may be defined either by using the
        <code>select</code> attribute, or by the <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that
        forms the content of the <a href=
        "#element-namespace"><code>xsl:namespace</code></a>
        element. These are mutually exclusive. Since the string
        value of a namespace node cannot be a zero-length string,
        one of them must be present. The way in which the value is
        constructed is specified in <a href=
        "#constructing-simple-content"><i>5.7.2 Constructing Simple
        Content</i></a>.</p>

        <p><a name="err-XTDE0905" id="err-XTDE0905"><span class=
        "error">[ERR XTDE0905]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the string value of the new namespace node is
        not valid in the lexical space of the data type
        <code>xs:anyURI</code>. <span class="error">[see <a href=
        "#err-XTDE0835">ERR XTDE0835</a>]</span></p>

        <p><a name="err-XTSE0910" id="err-XTSE0910"><span class=
        "error">[ERR XTSE0910]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <code>select</code> attribute of the <a href=
        "#element-namespace"><code>xsl:namespace</code></a> element
        is present when the element has content other than one or
        more <a href=
        "#element-fallback"><code>xsl:fallback</code></a>
        instructions, or if the <code>select</code> attribute is
        absent when the element has empty content.</p>

        <p>Note the restrictions described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a> for the position of a namespace
        node relative to other nodes in the node sequence returned
        by a sequence constructor.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e17221" id="d5e17221"></a>Example:
            Constructing a QName-Valued Attribute
          </div>

          <p>This literal result element:</p>

          <div class="exampleInner">
            <pre>
&lt;data xsi:type="xs:integer" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;
</pre>
          </div>

          <p>would typically cause the output document to contain
          the element:</p>

          <div class="exampleInner">
            <pre>
&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;
</pre>
          </div>

          <p>In this case, the element is constructed using a
          literal result element, and the namespace
          <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code>
          could therefore have been added to the <a title=
          "result tree" href="#dt-result-tree">result tree</a>
          simply by declaring it as one of the in-scope namespaces
          in the stylesheet. In practice, the <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction is more likely to be useful in situations
          where the element is constructed using an <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction, which does not copy all the in-scope
          namespaces from the stylesheet.</p>
        </div>

        <p><a name="err-XTDE0920" id="err-XTDE0920"><span class=
        "error">[ERR XTDE0920]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>name</code> attribute is neither a zero-length string
        nor an <a href=
        "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
        <small>Names</small></sup>, or if it is
        <code>xmlns</code>.</p>

        <p><a name="err-XTDE0925" id="err-XTDE0925"><span class=
        "error">[ERR XTDE0925]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a href=
        "#element-namespace"><code>xsl:namespace</code></a>
        instruction generates a namespace node whose name is
        <code>xml</code> and whose string value is not
        <code>http://www.w3.org/XML/1998/namespace</code>, or a
        namespace node whose string value is
        <code>http://www.w3.org/XML/1998/namespace</code> and whose
        name is not <code>xml</code>.</p>

        <p><a name="err-XTDE0930" id="err-XTDE0930"><span class=
        "error">[ERR XTDE0930]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if evaluating the <span><code>select</code>
        attribute or the contained <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a> of
        an <a href=
        "#element-namespace"><code>xsl:namespace</code></a>
        instruction</span> results in a zero-length string.</p>

        <p>For details of other error conditions that may arise,
        see <a href="#sequence-constructors"><i>5.7 Sequence
        Constructors</i></a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>It is rarely necessary to use <a href=
          "#element-namespace"><code>xsl:namespace</code></a> to
          create a namespace node in the <a title="result tree"
          href="#dt-result-tree">result tree</a>; in most
          circumstances, the required namespace nodes will be
          created automatically, as a side-effect of writing
          elements or attributes that use the namespace. An example
          where <a href=
          "#element-namespace"><code>xsl:namespace</code></a> is
          needed is a situation where the required namespace is
          used only within attribute values in the result document,
          not in element or attribute names; especially where the
          required namespace prefix or namespace URI is computed at
          run-time and is not present in either the source document
          or the stylesheet.</p>

          <p>Adding a namespace node to the <a title="result tree"
          href="#dt-result-tree">result tree</a> will never change
          the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of any element or
          attribute node in the result tree: that is, it will never
          change the namespace URI of an element or attribute. It
          <span>might</span>, however, constrain the choice of
          prefixes when namespace fixup is performed.</p>

          <p>Namespace prefixes for element and attribute names are
          effectively established by the namespace fixup process
          described in <a href="#namespace-fixup"><i>5.7.3
          Namespace Fixup</i></a>. The fixup process ensures that
          an element has in-scope namespace nodes for the namespace
          URIs used in the element name and in its attribute names,
          and the serializer will typically use these namespace
          nodes to determine the prefix to use in the serialized
          output. The fixup process cannot generate namespace nodes
          that are inconsistent with those already present in the
          tree. This means that it is not possible for the
          processor to decide the prefix to use for an element or
          for any of its attributes until all the namespace nodes
          for the element have been added.</p>

          <p>If a namespace prefix is mapped to a particular
          namespace URI using the <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction, or by using <a href=
          "#element-copy"><code>xsl:copy</code></a> or <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a> to copy a
          namespace node, this prevents the namespace fixup process
          (and hence the serializer) from using the same prefix for
          a different namespace URI on the same element.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e17356" id="d5e17356"></a>Example:
            Conflicting Namespace Prefixes
          </div>

          <p>Given the instruction:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:element name="p:item" xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;
</pre>
          </div>

          <p>a possible serialization of the <a title="result tree"
          href="#dt-result-tree">result tree</a> is:</p>

          <div class="exampleInner">
            <pre>
&lt;ns0:item xmlns:ns0="http://www.example.com/p" xmlns:p="http://www.example.com/q"/&gt;
</pre>
          </div>

          <p>The processor must invent a namespace prefix for the
          URI <code>p.uri</code>; it cannot use the prefix
          <code>p</code> because that prefix has been explicitly
          associated with a different URI.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction cannot be used to generate a <b>namespace
          undeclaration</b> of the form <code>xmlns=""</code> (nor
          the new forms of namespace undeclaration permitted in
          <a href="#xml-names11">[Namespaces in XML 1.1]</a>).
          Namespace undeclarations are generated automatically by
          the serializer if
          <span><code>undeclare-prefixes="yes"</code></span> is
          specified on <a href=
          "#element-output"><code>xsl:output</code></a>, whenever a
          parent element has a namespace node for the default
          namespace prefix, and a child element has no namespace
          node for that prefix.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-comments" id=
        "creating-comments"></a>11.8 Creating Comments</h3>

        <p class="element-syntax"><a name="element-comment" id=
        "element-comment"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:comment<br />
        &#160;&#160;select? = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:comment&gt;</code></p>

        <p>The <a href=
        "#element-comment"><code>xsl:comment</code></a> element is
        evaluated to contruct a new comment node. Except in error
        cases, the result of evaluating the <a href=
        "#element-comment"><code>xsl:comment</code></a> instruction
        is a single node, the newly constructed comment node.</p>

        <p>The string value of the new comment node may be defined
        either by using the <code>select</code> attribute, or by
        the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> that
        forms the content of the <a href=
        "#element-comment"><code>xsl:comment</code></a> element.
        These are mutually exclusive. If neither is present, the
        value of the new comment node will be a zero-length string.
        The way in which the value is constructed is specified in
        <a href="#constructing-simple-content"><i>5.7.2
        Constructing Simple Content</i></a>.</p>

        <p><a name="err-XTSE0940" id="err-XTSE0940"><span class=
        "error">[ERR XTSE0940]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <code>select</code> attribute of the <a href=
        "#element-comment"><code>xsl:comment</code></a> element is
        present unless the element has empty content.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e17444" id="d5e17444"></a>Example:
            Generating a Comment Node
          </div>

          <p>For example, this</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;
</pre>
          </div>

          <p>would create the comment</p>

          <div class="exampleInner">
            <pre>
&lt;!--This file is automatically generated. Do not edit!--&gt;
</pre>
          </div>
        </div>

        <p>In the generated comment node, the processor
        <span class="verb">must</span> insert a space after any
        occurrence of <code>-</code> that is followed by another
        <code>-</code> or that ends the comment.</p>
      </div>

      <div class="div2">
        <h3><a name="copying" id="copying"></a>11.9 Copying
        Nodes</h3>

        <div class="div3">
          <h4><a name="shallow-copy" id="shallow-copy"></a>11.9.1
          Shallow Copy</h4>

          <p class="element-syntax"><a name="element-copy" id=
          "element-copy"></a><code>&lt;!-- Category: instruction
          --&gt;<br />
          &lt;xsl:copy<br />
          &#160;&#160;copy-namespaces? = "yes" | "no"<br />
          &#160;&#160;inherit-namespaces? = "yes" | "no"<br />
          &#160;&#160;use-attribute-sets? = <var>qnames</var><br />
          &#160;&#160;type? = <var>qname</var><br />
          &#160;&#160;validation? = "strict" | "lax" | "preserve" |
          "strip"&gt;<br />
          &#160;&#160;&lt;!-- Content:
          <var>sequence-constructor</var> --&gt;<br />
          &lt;/xsl:copy&gt;</code></p>

          <p>The <a href="#element-copy"><code>xsl:copy</code></a>
          instruction provides a way of copying the context item.
          If the <a title="context item" href=
          "#dt-context-item">context item</a> is a node, evaluating
          the <a href="#element-copy"><code>xsl:copy</code></a>
          instruction constructs a copy of the context node, and
          the result of the <a href=
          "#element-copy"><code>xsl:copy</code></a> instruction is
          this newly constructed node. <span>By default,</span> the
          namespace nodes of the context node are automatically
          copied as well, but the attributes and children of the
          node are not automatically copied.</p>

          <p>When the <a title="context item" href=
          "#dt-context-item">context item</a> is an atomic value,
          the <a href="#element-copy"><code>xsl:copy</code></a>
          instruction returns this value. <span>The <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, if
          present, is not evaluated.</span></p>

          <p>When the <a title="context item" href=
          "#dt-context-item">context item</a> is an attribute node,
          text node, comment node, processing instruction node, or
          namespace node, the <a href=
          "#element-copy"><code>xsl:copy</code></a> instruction
          returns a new node that is a copy of the context node.
          The new node will have the same node kind, name, and
          string value as the context node. <span>In the case of an
          attribute node, it will also have the same values for the
          <code>is-id</code> and <code>is-idrefs</code>
          properties.</span> The <a title="sequence constructor"
          href="#dt-sequence-constructor">sequence constructor</a>,
          if present, is not evaluated.</p>

          <p><span>When the context item is a document node or
          element node, the <a href=
          "#element-copy"><code>xsl:copy</code></a> instruction
          returns a new node that has the same node kind and name
          as the context node. The content of the new node is
          formed by evaluating the <a title="sequence constructor"
          href="#dt-sequence-constructor">sequence constructor</a>
          contained in the <a href=
          "#element-copy"><code>xsl:copy</code></a>
          instruction.</span> The sequence obtained by evaluating
          this sequence constructor is used (after prepending any
          attribute nodes or namespace nodes as described in the
          following paragraphs) to construct the content of the
          document or element node, as described in <a href=
          "#constructing-complex-content"><i>5.7.1 Constructing
          Complex Content</i></a>.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e17557" id="d5e17557"></a>Example:
              Identity Transformation
            </div>

            <p>The identity transformation can be written using
            <a href="#element-copy"><code>xsl:copy</code></a> as
            follows:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:template match="@*|node()"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:apply-templates select="@*|node()"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;
</pre>
            </div>

            <p>This template rule can be used to copy any node in a
            tree by applying template rules to its attributes and
            children. It can be combined with additional template
            rules that modify selected nodes, for example if all
            nodes are to be copied except <code>note</code>
            elements and their contents, this can be achieved by
            using the identity template rule together with the
            template rule:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:template match="note"/&gt;
</pre>
            </div>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The <a href=
            "#element-copy"><code>xsl:copy</code></a> instruction
            is most useful when copying element nodes. In other
            cases, the <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>
            instruction is more flexible, because it has a
            <code>select</code> attribute allowing selection of the
            nodes or values to be copied.</p>
          </div>

          <p>The <a href="#element-copy"><code>xsl:copy</code></a>
          instruction has an optional
          <code>use-attribute-sets</code> attribute, whose value is
          a <span>whitespace-separated</span> list of QNames that
          identify <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a>
          declarations. This attribute is used only when copying
          element nodes. This list is expanded as described in
          <a href="#attribute-sets"><i>10.2 Named Attribute
          Sets</i></a> to produce a sequence of attribute nodes.
          This sequence is prepended to the sequence produced as a
          result of evaluating the <a title="sequence constructor"
          href="#dt-sequence-constructor">sequence
          constructor</a>.</p>

          <p>The <a href="#element-copy"><code>xsl:copy</code></a>
          instruction has an optional <code>copy-namespaces</code>
          attribute, with the value <code>yes</code> or
          <code>no</code>. The default value is <code>yes</code>.
          The attribute is used only when copying element nodes. If
          the value is set to <code>yes</code>, or is omitted, then
          all the namespace nodes of the source element are copied
          as namespace nodes for the result element. These copied
          namespace nodes are prepended to the sequence produced as
          a result of evaluating the <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> (it
          is immaterial whether they come before or after any
          attribute nodes produced by expanding the
          <code>use-attribute-sets</code> attribute). If the value
          is set to <code>no</code>, then the namespace nodes are
          not copied. However, namespace nodes will still be added
          to the result element as <span class=
          "verb">required</span> by the namespace fixup process:
          see <a href="#namespace-fixup"><i>5.7.3 Namespace
          Fixup</i></a>.</p>

          <p>The <a href="#element-copy"><code>xsl:copy</code></a>
          instruction has an optional
          <code>inherit-namespaces</code> attribute, with the value
          <code>yes</code> or <code>no</code>. The default value is
          <code>yes</code>. The attribute is used only when copying
          element nodes. If the value is set to <code>yes</code>,
          or is omitted, then the namespace nodes created for the
          newly constructed element (whether these were copied from
          those of the source node, or generated as a result of
          namespace fixup) are copied to the children and
          descendants of the newly constructed element, as
          described in <a href=
          "#constructing-complex-content"><i>5.7.1 Constructing
          Complex Content</i></a>. If the value is set to
          <code>no</code>, then these namespace nodes are not
          automatically copied to the children. This may result in
          namespace undeclarations (such as <code>xmlns=""</code>
          or, in the case of XML Namespaces 1.1,
          <code>xmlns:p=""</code>) appearing on the child elements
          when a <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a> is
          serialized.</p>

          <p><a name="err-XTTE0950" id="err-XTTE0950"><span class=
          "error">[ERR XTTE0950]</span></a> It is a <a title=
          "type errors" href="#dt-type-error">type error</a> to use
          the <a href="#element-copy"><code>xsl:copy</code></a> or
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>
          instruction to copy a node that has namespace-sensitive
          content if the <code>copy-namespaces</code> attribute has
          the value <code>no</code> and its explicit or implicit
          <code>validation</code> attribute has the value
          <code>preserve</code>. It is also a type error if either
          of these instructions (with
          <code>validation="preserve"</code>) is used to copy an
          attribute having namespace-sensitive content, unless the
          parent element is also copied. A node has
          namespace-sensitive content if its typed value contains
          an item of type <code>xs:QName</code> or
          <code>xs:NOTATION</code> or a type derived therefrom. The
          reason this is an error is because the validity of the
          content depends on the namespace context being
          preserved.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>When attribute nodes are copied, whether with
            <a href="#element-copy"><code>xsl:copy</code></a> or
            with <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>, the
            processor does not automatically copy any associated
            namespace information. The namespace used in the
            attribute name itself will be declared by virtue of the
            namespace fixup process (see <a href=
            "#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>)
            when the attribute is added to an element in the
            <a title="result tree" href="#dt-result-tree">result
            tree</a>, but if namespace <span>prefixes</span> are
            used in the content of the attribute (for example, if
            the value of the attribute is an XPath expression) then
            it is the responsibility of the stylesheet author to
            ensure that suitable namespace nodes are added to the
            <a title="result tree" href="#dt-result-tree">result
            tree</a>. This can be achieved by copying the namespace
            nodes using <a href=
            "#element-copy"><code>xsl:copy</code></a>, or by
            generating them using <a href=
            "#element-namespace"><code>xsl:namespace</code></a>.</p>
          </div>

          <p>The optional attributes <code>type</code> and
          <code>validation</code> may be used on the <a href=
          "#element-copy"><code>xsl:copy</code></a> instruction to
          validate the contents of an element, attribute or
          document node against a type definition, element
          declaration, or attribute declaration in a schema, and
          thus to determine the <a title="type annotation" href=
          "#dt-annotation">type annotation</a> that the new copy of
          an element or attribute node will carry. These attributes
          are ignored when copying an item that is not an element,
          attribute or document node. When the node being copied is
          an element or document node, these attributes also affect
          the type annotation carried by any elements and
          attributes that have the copied element or document node
          as an ancestor. These two attributes are both optional,
          and if one is specified then the other <span class=
          "verb">must</span> be omitted. The permitted values of
          these attributes and their semantics are described in
          <a href="#validation"><i>19.2 Validation</i></a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The final <a title="type annotation" href=
            "#dt-annotation">type annotation</a> of the node in the
            <a title="result tree" href="#dt-result-tree">result
            tree</a> also depends on the <code>type</code> and
            <code>validation</code> attributes of the instructions
            used to create the ancestors of the node.</p>
          </div>

          <p>The base URI of a node is copied<span>, except in the
          case of an element node having an <code>xml:base</code>
          attribute, in which case the base URI of the new node is
          taken as the value of the <code>xml:base</code>
          attribute, resolved if it is relative against the base
          URI of the <a href=
          "#element-copy"><code>xsl:copy</code></a>
          instruction</span>. If the copied node is subsequently
          attached as a child to a new element <span>or document
          node</span>, the final copy of the node inherits its base
          URI from its parent node, unless this is overridden using
          an <code>xml:base</code> attribute.</p>

          <p>When an <code>xml:id</code> attribute is copied, using
          either the <a href=
          "#element-copy"><code>xsl:copy</code></a> or <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>
          instruction, it is <a title="implementation-defined"
          href="#dt-implementation-defined">implementation-defined</a>
          whether the value of the attribute is subjected to
          attribute value normalization (that is, effectively
          applying the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-normalize-space">
          <code>normalize-space</code></a><sup><small>FO</small></sup>
          function).</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>In most cases the value will already have been
            subjected to attribute value normalization on the
            source tree, but if this processing has not been
            performed on the source tree, it is not an error for it
            to be performed on the result tree.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="copy-of" id="copy-of"></a>11.9.2 Deep
          Copy</h4>

          <p class="element-syntax"><a name="element-copy-of" id=
          "element-copy-of"></a><code>&lt;!-- Category: instruction
          --&gt;<br />
          &lt;xsl:copy-of<br />
          &#160;&#160;<b>select</b> = <var>expression</var><br />
          &#160;&#160;copy-namespaces? = "yes" | "no"<br />
          &#160;&#160;type? = <var>qname</var><br />
          &#160;&#160;validation? = "strict" | "lax" | "preserve" |
          "strip"&#160;/&gt;</code></p>

          <p>The <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>
          instruction can be used to construct a copy of a sequence
          of nodes <span>and/or atomic values</span>, with each new
          node containing copies of all the children, attributes,
          and (by default) namespaces of the original node,
          recursively. The result of evaluating the instruction is
          a sequence of <span>items</span> corresponding one-to-one
          with the supplied sequence, and retaining its order.</p>

          <p>The <span class="verb">required</span>
          <code>select</code> attribute contains an <a title=
          "expression" href="#dt-expression">expression</a>,
          <span>whose value may be any sequence of nodes and atomic
          values</span>. The items in this sequence are processed
          as follows:</p>

          <ul>
            <li>
              <p>If the item is an element node, a new element is
              constructed and appended to the result sequence. The
              new element will have the same <a title=
              "expanded-QName" href=
              "#dt-expanded-qname">expanded-QName</a> as the
              original, and it will have <span>deep</span> copies
              of the attribute nodes and children of the element
              node.</p>

              <p>The new element will also have namespace nodes
              copied from the original element node, unless they
              are excluded by <span>specifying
              <code>copy-namespaces="no"</code>. If this attribute
              is omitted, or takes the value <code>yes</code>, then
              all the namespace nodes of the original element are
              copied to the new element. If it takes the value
              <code>no</code>, then none of the namespace nodes are
              copied: however, namespace nodes will still be
              created in the <a title="result tree" href=
              "#dt-result-tree">result tree</a> as <span class=
              "verb">required</span> by the namespace fixup
              process: see <a href="#namespace-fixup"><i>5.7.3
              Namespace Fixup</i></a>. This attribute affects all
              elements copied by this instruction: both elements
              selected directly by the <code>select</code>
              <a title="expression" href=
              "#dt-expression">expression</a>, and elements that
              are descendants of nodes selected by the
              <code>select</code> expression.</span></p>

              <p>The new element will have the same values of the
              <code>is-id</code>, <code>is-idrefs</code>, and
              <code>nilled</code> properties as the original
              element.</p>
            </li>

            <li>
              <p>If the item is a document node, the instruction
              adds a new document node to the result sequence; the
              children of this document node will be one-to-one
              copies of the children of the original document node
              (each copied according to the rules for its own node
              kind).</p>
            </li>

            <li>
              <p>If the item is an attribute or namespace node, or
              a text node, a comment, or a processing instruction,
              the same rules apply as with <a href=
              "#element-copy"><code>xsl:copy</code></a> (see
              <a href="#shallow-copy"><i>11.9.1 Shallow
              Copy</i></a>).</p>
            </li>

            <li>
              <p>If the item is an atomic value, the value is
              appended to the result sequence, as with <a href=
              "#element-sequence"><code>xsl:sequence</code></a>.</p>
            </li>
          </ul>

          <p>The optional attributes <code>type</code> and
          <code>validation</code> may be used on the <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>
          instruction to validate the contents of an element,
          attribute or document node against a type definition,
          element declaration, or attribute declaration in a schema
          and thus to determine the <a title="type annotation"
          href="#dt-annotation">type annotation</a> that the new
          copy of an element or attribute node will carry. These
          attributes are applied individually to each element,
          attribute, and document node that is selected by the
          expression in the <code>select</code> attribute. These
          attributes are ignored when copying an item that is not
          an element, attribute or document node.</p>

          <p>The specified <code>type</code> and
          <code>validation</code> apply directly only to elements,
          attributes and document nodes created as copies of nodes
          actually selected by the <code>select</code> expression,
          they do not apply to nodes that are implicitly copied
          because they have selected nodes as an ancestor. However,
          these attributes do indirectly affect the <a title=
          "type annotation" href="#dt-annotation">type
          annotation</a> carried by such implicitly copied nodes,
          as a consequence of the validation process.</p>

          <p>These two attributes are both optional, and if one is
          specified then the other <span class="verb">must</span>
          be omitted. The permitted values of these attributes and
          their semantics are described in <a href=
          "#validation"><i>19.2 Validation</i></a>.</p>

          <p>Errors may occur when copying namespace-sensitive
          elements or attributes using
          <code>validation="preserve"</code>. <span class=
          "error">[see <a href="#err-XTTE0950">ERR
          XTTE0950</a>]</span>.</p>

          <p>The base URI of a node is copied<span>, except in the
          case of an element node having an <code>xml:base</code>
          attribute, in which case the base URI of the new node is
          taken as the value of the <code>xml:base</code>
          attribute, resolved if it is relative against the base
          URI of the <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>
          instruction</span>. If the copied node is subsequently
          attached as a child to a new element <span>or document
          node</span>, the final copy of the node inherits its base
          URI from its parent node, unless this is overridden using
          an <code>xml:base</code> attribute.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="constructing-sequences" id=
        "constructing-sequences"></a>11.10 Constructing
        Sequences</h3>

        <p class="element-syntax"><a name="element-sequence" id=
        "element-sequence"></a><code>&lt;!-- Category: instruction
        --&gt;<br />
        &lt;xsl:sequence<br />
        &#160;&#160;<b>select</b> = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: <a href=
        "#element-fallback">xsl:fallback</a>* --&gt;<br />
        &lt;/xsl:sequence&gt;</code></p>

        <p>The <a href=
        "#element-sequence"><code>xsl:sequence</code></a>
        instruction may be used within a <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> to
        construct a sequence of nodes and/or atomic values. This
        sequence is returned as the result of the instruction.
        Unlike most other instructions, <a href=
        "#element-sequence"><code>xsl:sequence</code></a> can
        return a sequence containing existing nodes, rather than
        constructing new nodes. When <a href=
        "#element-sequence"><code>xsl:sequence</code></a> is used
        to add atomic values to a sequence, the effect is very
        similar to the <a href=
        "#element-copy-of"><code>xsl:copy-of</code></a>
        instruction.</p>

        <p>The items comprising the result sequence are selected
        using the <code>select</code> attribute.</p>

        <p>Any contained <a href=
        "#element-fallback"><code>xsl:fallback</code></a>
        instructions are ignored by an XSLT 2.0 processor, but can
        be used to define fallback behavior for an XSLT 1.0
        processor running in forwards compatibility mode.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18039" id="d5e18039"></a>Example:
            Constructing a Sequence of Integers
          </div>

          <p>For example, the following code:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;
</pre>
          </div>

          <p>produces the output: <code>37</code></p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18050" id="d5e18050"></a>Example: Using
            <code>xsl:for-each</code> to Construct a Sequence
          </div>

          <p>The following code constructs a sequence containing
          the value of the <code>@price</code> attribute for
          selected elements (which we assume to be typed as
          <code>xs:decimal</code>), or a computed price for those
          elements that have no <code>@price</code> attribute. It
          then returns the average price:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
  &lt;xsl:for-each select="//product"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="@price"&gt;
        &lt;xsl:sequence select="@price"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:sequence select="@cost * 1.5"/&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="avg($prices)"/&gt;
</pre>
          </div>

          <p>Note that the existing <code>@price</code> attributes
          could equally have been added to the <code>$prices</code>
          sequence using <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a> or
          <a href=
          "#element-value-of"><code>xsl:value-of</code></a>.
          However, <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a> would
          create a copy of the attribute node, which is not needed
          in this situation, while <a href=
          "#element-value-of"><code>xsl:value-of</code></a> would
          create a new text node, which then has to be converted to
          an <code>xs:decimal</code>. Using <a href=
          "#element-sequence"><code>xsl:sequence</code></a>, which
          in this case atomizes the existing attribute node and
          adds an <code>xs:decimal</code> atomic value to the
          result sequence, is a more direct way of achieving the
          same result.</p>

          <p>This example could alternatively be solved at the
          XPath level:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:value-of select="avg(//product/(+@price, @cost*1.5)[1])"/&gt;
</pre>
          </div>

          <p>(The apparently redundant <code>+</code> operator is
          there to atomize the attribute value: the expression on
          the right hand side of the <code>/</code> operator must
          not return a mixture of nodes and atomic values.)</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="number" id="number"></a>12 Numbering</h2>

      <p class="element-syntax"><a name="element-number" id=
      "element-number"></a><code>&lt;!-- Category: instruction
      --&gt;<br />
      &lt;xsl:number<br />
      &#160;&#160;value? = <var>expression</var><br />
      &#160;&#160;select? = <var>expression</var><br />
      &#160;&#160;level? = "single" | "multiple" | "any"<br />
      &#160;&#160;count? = <var>pattern</var><br />
      &#160;&#160;from? = <var>pattern</var><br />
      &#160;&#160;format? = { <var>string</var> }<br />
      &#160;&#160;lang? = { <var>nmtoken</var> }<br />
      &#160;&#160;letter-value? = { "alphabetic" | "traditional"
      }<br />
      &#160;&#160;ordinal? = { <var>string</var> }<br />
      &#160;&#160;grouping-separator? = { <var>char</var> }<br />
      &#160;&#160;grouping-size? = { <var>number</var>
      }&#160;/&gt;</code></p>

      <p>The <a href="#element-number"><code>xsl:number</code></a>
      instruction is used to create a formatted number. The result
      of the instruction is a newly constructed text node
      containing the formatted number as its <a title=
      "string value" href="#dt-string-value">string value</a>.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-place-marker" id="dt-place-marker" title=
      "place marker"></a>The <a href=
      "#element-number"><code>xsl:number</code></a> instruction
      performs two tasks: firstly, determining a <b>place
      marker</b> (this is a sequence of integers, to allow for
      hierarchic numbering schemes such as <code>1.12.2</code> or
      <code>3(c)ii</code>), and secondly, formatting the place
      marker for output as a text node in the result
      sequence.<span class="definition">]</span> The place marker
      to be formatted can either be supplied directly, in the
      <code>value</code> attribute, or it can be computed based on
      the position of <span>a selected node</span> within the tree
      that contains it.</p>

      <p><a name="err-XTSE0975" id="err-XTSE0975"><span class=
      "error">[ERR XTSE0975]</span></a> It is a <a title=
      "static error" href="#dt-static-error">static error</a> if
      the <code>value</code> attribute of <a href=
      "#element-number"><code>xsl:number</code></a> is present
      unless the <code>select</code>, <code>level</code>,
      <code>count</code>, and <code>from</code> attributes are all
      absent.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>The facilities described in this section are
        specifically designed to enable the calculation and
        formatting of section numbers, paragraph numbers, and the
        like. For formatting of other numeric quantities, the
        <a href=
        "#function-format-number"><code>format-number</code></a>
        function may be more suitable: see <a href=
        "#format-number"><i>16.4 Number Formatting</i></a>.</p>
      </div>

      <div class="div2">
        <h3><a name="formatting-supplied-number" id=
        "formatting-supplied-number"></a>12.1 Formatting a Supplied
        Number</h3>

        <p>The <a title="place marker" href=
        "#dt-place-marker">place marker</a> to be formatted may be
        specified by an expression. The <code>value</code>
        attribute contains the <a title="expression" href=
        "#dt-expression">expression</a>. The value of this
        expression is <a title="atomize" href=
        "#dt-atomization">atomized</a> using the procedure defined
        in <a href="#xpath20">[XPath 2.0]</a>, and each value
        <span><var>$V</var> in the atomized sequence is then
        converted to the integer value returned by the XPath
        expression
        <code>xs:integer(round(number($V)))</code>.</span> The
        resulting sequence of integers is used as the place marker
        to be formatted.</p>

        <p>If <a title="backwards compatible behavior" href=
        "#dt-backwards-compatible-behavior">backwards compatible
        behavior</a> is enabled for the instruction, then:</p>

        <ul>
          <li>
            <p>all items in the <a title="atomize" href=
            "#dt-atomization">atomized</a> sequence after the first
            are discarded;</p>
          </li>

          <li>
            <p>If the atomized sequence is empty, it is replaced by
            a sequence containing the <code>xs:double</code> value
            <code>NaN</code> as its only item;</p>
          </li>

          <li>
            <p>If any value in the sequence cannot be converted to
            an integer (this includes the case where the sequence
            contains a <code>NaN</code> value) then the string
            <code>NaN</code> is inserted into the formatted result
            string in its proper position. The error described in
            the following paragraph does not apply in this
            case.</p>
          </li>
        </ul>

        <p><a name="err-XTDE0980" id="err-XTDE0980"><span class=
        "error">[ERR XTDE0980]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if any undiscarded item in the atomized sequence
        supplied as the value of the <code>value</code> attribute
        of <a href="#element-number"><code>xsl:number</code></a>
        cannot be converted to an integer, or if the resulting
        integer is less than 0 (zero).</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The value zero does not arise when numbering nodes in
          a source document, but it can arise in other numbering
          sequences. It is permitted specifically because the rules
          of the <a href=
          "#element-number"><code>xsl:number</code></a> instruction
          are also invoked by functions such as <a href=
          "#function-format-time"><code>format-time</code></a>: the
          minutes and seconds component of a time value can
          legitimately be zero.</p>
        </div>

        <p>The resulting sequence is formatted as a string using
        the <a title="effective value" href=
        "#dt-effective-value">effective values</a> of the
        attributes specified in <a href="#convert"><i>12.3 Number
        to String Conversion Attributes</i></a>; each of these
        attributes is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>. After conversion, the <a href=
        "#element-number"><code>xsl:number</code></a> element
        constructs a new text node containing the resulting string,
        and returns this node.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18312" id="d5e18312"></a>Example: Numbering
            a Sorted List
          </div>

          <p>The following example numbers a sorted list:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="numbering-based-on-position" id=
        "numbering-based-on-position"></a>12.2 Numbering based on
        Position in a Document</h3>

        <p>If no <code>value</code> attribute is specified, then
        the <a href="#element-number"><code>xsl:number</code></a>
        instruction returns a new text node containing a formatted
        <a title="place marker" href="#dt-place-marker">place
        marker</a> that is based on the position of <span>a
        selected node within its containing document. If the
        <code>select</code> attribute is present, then the
        expression contained in the <code>select</code> attribute
        is evaluated to determine the selected node. If the
        <code>select</code> attribute is omitted, then the selected
        node is the <a title="context node" href=
        "#dt-context-node">context node</a>.</span></p>

        <p><a name="err-XTTE0990" id="err-XTTE0990"><span class=
        "error">[ERR XTTE0990]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        <a href="#element-number"><code>xsl:number</code></a>
        instruction is evaluated, with no <code>value</code> or
        <code>select</code> attribute, when the <a title=
        "context item" href="#dt-context-item">context item</a> is
        not a node.</p>

        <p><a name="err-XTTE1000" id="err-XTTE1000"><span class=
        "error">[ERR XTTE1000]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        result of evaluating the <code>select</code> attribute of
        the <a href="#element-number"><code>xsl:number</code></a>
        instruction is anything other than a single node.</p>

        <p>The following attributes control how the selected node
        is to be numbered:</p>

        <ul>
          <li>
            <p>The <code>level</code> attribute specifies rules for
            selecting the nodes that are taken into account in
            allocating a number; it has the values
            <code>single</code>, <code>multiple</code> or
            <code>any</code>. The default is
            <code>single</code>.</p>
          </li>

          <li>
            <p>The <code>count</code> attribute is a <a title=
            "pattern" href="#dt-pattern">pattern</a> that specifies
            which nodes are to be counted at those levels. If
            <code>count</code> attribute is not specified, then it
            defaults to the pattern that matches any node with the
            same node <span>kind</span> as the
            <span>selected</span> node and, if the
            <span>selected</span> node has an <a title=
            "expanded-QName" href=
            "#dt-expanded-qname">expanded-QName</a>, with the same
            <a title="expanded-QName" href=
            "#dt-expanded-qname">expanded-QName</a> as the
            <span>selected</span> node.</p>
          </li>

          <li>
            <p>The <code>from</code> attribute is a <a title=
            "pattern" href="#dt-pattern">pattern</a> that specifies
            where counting starts.</p>
          </li>
        </ul>

        <p>In addition, the attributes specified in <a href=
        "#convert"><i>12.3 Number to String Conversion
        Attributes</i></a> are used for number to string
        conversion, as in the case when the <code>value</code>
        attribute is specified.</p>

        <p>The <a href=
        "#element-number"><code>xsl:number</code></a> element first
        constructs a sequence of positive integers using the
        <code>level</code>, <code>count</code> and
        <code>from</code> attributes. Where <code>level</code> is
        <code>single</code> or <code>any</code>, this sequence will
        either be empty or contain a single number; where
        <code>level</code> is <code>multiple</code>, the sequence
        may be of any length. The sequence is constructed as
        follows:</p>

        <p>Let <code>matches-count($node)</code> be a function that
        returns true if and only if the given node
        <code>$node</code> matches the pattern given in the
        <code>count</code> attribute, or the implied pattern
        (according to the rules given above) if the
        <code>count</code> attribute is omitted.</p>

        <p>Let <code>matches-from($node)</code> be a function that
        returns true if and only if the given node
        <code>$node</code> matches the pattern given in the
        <code>from</code> attribute, <span>or if <code>$node</code>
        is the root node of a tree. If the <code>from</code>
        attribute is omitted, then the function returns true if and
        only if <code>$node</code> is the root node of a
        tree</span>.</p>

        <p>Let <code>$S</code> be the selected node.</p>

        <p>When <code>level="single"</code>:</p>

        <ul>
          <li>
            <p>Let <code>$A</code> be the node sequence selected by
            the following expression:</p>

            <p>
            <code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)][1]</code></p>

            <p>(this selects the innermost ancestor-or-self node
            that matches the <code>count</code> pattern)</p>
          </li>

          <li>
            <p>Let <code>$F</code> be the node sequence selected by
            the expression</p>

            <p>
            <code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>

            <p>(this selects the innermost ancestor-or-self node
            that matches the <code>from</code> pattern):</p>
          </li>

          <li>
            <p>Let <code>$AF</code> be the value of:</p>

            <p>
            <code>&#160;&#160;&#160;$A[ancestor-or-self::node()[.
            is $F]]</code></p>

            <p>(this selects $A if it is in the subtree rooted at
            $F, or the empty sequence otherwise)</p>
          </li>

          <li>
            <p>If <code>$AF</code> is empty, return the empty
            sequence, <code>()</code></p>
          </li>

          <li>
            <p>Otherwise return the value of:</p>

            <p><code>&#160;&#160;&#160;1 +
            count($AF/preceding-sibling::node()[matches-count(.)])</code></p>

            <p>(the number of preceding siblings of the counted
            node that match the <code>count</code> pattern, plus
            one).</p>
          </li>
        </ul>

        <p>When <code>level="multiple"</code>:</p>

        <ul>
          <li>
            <p>Let <code>$A</code> be the node sequence selected by
            the expression</p>

            <p>
            <code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-count(.)]</code></p>

            <p>(the set of ancestor-or-self nodes that match the
            <code>count</code> pattern)</p>
          </li>

          <li>
            <p>Let <code>$F</code> be the node sequence selected by
            the expression</p>

            <p>
            <code>&#160;&#160;&#160;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p>

            <p>(the innermost ancestor-or-self node that matches
            the <code>from</code> pattern)</p>
          </li>

          <li>
            <p>Let <code>$AF</code> be the value of</p>

            <p>
            <code>&#160;&#160;&#160;$A[ancestor-or-self::node()[.
            is $F]]</code></p>

            <p>(the nodes selected in the first step that are in
            the subtree rooted at the node selected in the second
            step)</p>
          </li>

          <li>
            <p>Return the result of the expression</p>

            <p><code>&#160;&#160;&#160;for $af in $AF return
            1+count($af/preceding-sibling::node()[matches-count(.)])</code></p>

            <p>(a sequence of integers containing, for each of
            these nodes, one plus the number of preceding siblings
            that match the <code>count</code> pattern)</p>
          </li>
        </ul>

        <p>When <code>level="any"</code>:</p>

        <ul>
          <li>
            <p>Let <code>$A</code> be the node sequence selected by
            the expression</p>

            <p>
            <code>&#160;&#160;&#160;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code></p>

            <p>(the set of nodes consisting of the selected node
            together with all nodes, other than attributes and
            namespaces, that precede the selected node in document
            order, provided that they match the <code>count</code>
            pattern)</p>
          </li>

          <li>
            <p>Let <code>$F</code> be the node sequence selected by
            the expression</p>

            <p>
            <code>&#160;&#160;&#160;$S/(preceding::node()|ancestor::node())[matches-from(.)][last()]</code></p>

            <p>(the last node in document order that matches the
            <code>from</code> pattern and that precedes the
            selected node, using the same definition)</p>
          </li>

          <li>
            <p>Let <code>$AF</code> be the node sequence <code>$A[.
            is $F or . &gt;&gt; $F]</code>.</p>

            <p>(the nodes selected in the first step, excluding
            those that precede the node selected in the second
            step)</p>
          </li>

          <li>
            <p>If <code>$AF</code> is empty, return the empty
            sequence, <code>()</code></p>
          </li>

          <li>
            <p>Otherwise return the value of the expression
            <code>count($AF)</code></p>
          </li>
        </ul>

        <p>The sequence of numbers (the <a title="place marker"
        href="#dt-place-marker">place marker</a>) is then converted
        into a string using the <a title="effective value" href=
        "#dt-effective-value">effective values</a> of the
        attributes specified in <a href="#convert"><i>12.3 Number
        to String Conversion Attributes</i></a>; each of these
        attributes is interpreted as an <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        template</a>. After conversion, the resulting string is
        <span>used to create a text node, which forms the result of
        the <a href="#element-number"><code>xsl:number</code></a>
        instruction</span>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18740" id="d5e18740"></a>Example: Numbering
            the Items in an Ordered List
          </div>

          <p>The following will number the items in an ordered
          list:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18747" id="d5e18747"></a>Example:
            Multi-Level Numbering
          </div>

          <p>The following two rules will number <code>title</code>
          elements. This is intended for a document that contains a
          sequence of chapters followed by a sequence of
          appendices, where both chapters and appendices contain
          sections, which in turn contain subsections. Chapters are
          numbered 1, 2, 3; appendices are numbered A, B, C;
          sections in chapters are numbered 1.1, 1.2, 1.3; sections
          in appendices are numbered A.1, A.2, A.3.
          <span>Subsections within a chapter are numbered 1.1.1,
          1.1.2, 1.1.3; subsections within an appendix are numbered
          A.1.1, A.1.2, A.1.3.</span></p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18759" id="d5e18759"></a>Example: Numbering
            Notes within a Chapter
          </div>

          <p>This example numbers notes sequentially within a
          chapter:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="convert" id="convert"></a>12.3 Number to
        String Conversion Attributes</h3>

        <p>The following attributes are used to control conversion
        of a sequence of numbers into a string. The numbers are
        integers greater than <span>or equal to</span> 0 (zero).
        The attributes are all optional.</p>

        <p>The main attribute is <code>format</code>. The default
        value for the <code>format</code> attribute is
        <code>1</code>. The <code>format</code> attribute is split
        into a sequence of tokens where each token is a maximal
        sequence of alphanumeric characters or a maximal sequence
        of non-alphanumeric characters. <em>Alphanumeric</em> means
        any character that has a Unicode category of Nd, Nl, No,
        Lu, Ll, Lt, Lm or Lo. The alphanumeric tokens (<em>format
        tokens</em>) indicate the format to be used for each number
        in the sequence; in most cases the format token is the same
        as the required representation of the number 1 (one).</p>

        <p>Each non-alphanumeric token is either a prefix, a
        separator, or a suffix. <span>If there is a
        non-alphanumeric token but no format token, then the single
        non-alphanumeric token is used as both the prefix and the
        suffix.</span> The prefix, if it exists, is the
        non-alphanumeric token that precedes the first format
        token: the prefix always appears exactly once in the
        constructed string, at the start. The suffix, if it exists,
        is the non-alphanumeric token that follows the last format
        token: the suffix always appears exactly once in the
        constructed string, at the end. All other non-alphanumeric
        tokens (those that occur between two format tokens) are
        <em>separator tokens</em> and are used to separate numbers
        in the sequence.</p>

        <p>The <var>n</var>th format token is used to format the
        <var>n</var>th number in the sequence. If there are more
        numbers than format tokens, then the last format token is
        used to format remaining numbers. If there are no format
        tokens, then a format token of <code>1</code> is used to
        format all numbers. Each number after the first is
        separated from the preceding number by the separator token
        preceding the format token used to format that number, or,
        if <span>that is the first format token</span>, then by
        <code>.</code> (dot).</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e18820" id="d5e18820"></a>Example:
            Formatting a List of Numbers
          </div>

          <p>Given the sequence of numbers <code>5, 13, 7</code>
          and the format token <code>A-001(i)</code>, the output
          will be the string <code>E-013(vii)</code></p>
        </div>

        <p>Format tokens are interpreted as follows:</p>

        <ul>
          <li>
            <p>Any token where the last character has a decimal
            digit value of 1 (as specified in the Unicode character
            property database), and the Unicode value of preceding
            characters is one less than the Unicode value of the
            last character generates a decimal representation of
            the number where each number is at least as long as the
            format token. <span>The digits used in the decimal
            representation are the set of digits containing the
            digit character used in the format token.</span> Thus,
            a format token <code>1</code> generates the sequence
            <code>0 1 2 ... 10 11 12 ...</code>, and a format token
            <code>01</code> generates the sequence <code>00 01 02
            ... 09 10 11 12 ... 99 100 101</code>. <span>A format
            token of <code>&amp;#x661;</code> (Arabic-Indic digit
            one) generates the sequence <code>١</code> then
            <code>٢</code> then <code>٣</code> ...</span></p>
          </li>

          <li>
            <p>A format token <code>A</code> generates the sequence
            <code>A B C ... Z AA AB AC...</code>.</p>
          </li>

          <li>
            <p>A format token <code>a</code> generates the sequence
            <code>a b c ... z aa ab ac...</code>.</p>
          </li>

          <li>
            <p>A format token <code>i</code> generates the sequence
            <code>i ii iii iv v vi vii viii ix x ...</code>.</p>
          </li>

          <li>
            <p>A format token <code>I</code> generates the sequence
            <code>I II III IV V VI VII VIII IX X ...</code>.</p>
          </li>

          <li>
            <p>A format token <code>w</code> generates numbers
            written as lower-case words, for example in English,
            <code>one two three four ...</code></p>
          </li>

          <li>
            <p>A format token <code>W</code> generates numbers
            written as upper-case words, for example in English,
            <code>ONE TWO THREE FOUR ...</code></p>
          </li>

          <li>
            <p>A format token <code>Ww</code> generates numbers
            written as title-case words, for example in English,
            <code>One Two Three Four ...</code></p>
          </li>

          <li>
            <p>Any other format token indicates a numbering
            sequence <span>in which that token represents the
            number 1 (one)</span> (but see the note below). It is
            <a title="implementation-defined" href=
            "#dt-implementation-defined">implementation-defined</a>
            which numbering sequences, additional to those listed
            above, are supported. If an implementation does not
            support a numbering sequence represented by the given
            token, it <span class="verb">must</span> use a format
            token of <code>1</code>.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>In some traditional numbering sequences additional
              signs are added to denote that the letters should be
              interpreted as numbers; these are not included in the
              format token. An example, see also the example below,
              is classical Greek where a <em>dexia keraia</em> and
              sometimes an <em>aristeri keraia</em> is added.</p>
            </div>
          </li>
        </ul>

        <p>For all format tokens other than the first kind above
        (one that consists of decimal digits), there <span class=
        "verb">may</span> be <a title="implementation-defined"
        href="#dt-implementation-defined">implementation-defined</a>
        <span>lower and</span> upper bounds on the range of numbers
        that can be formatted using this format token; indeed, for
        some numbering sequences there may be intrinsic limits.
        <span>For example, the formatting token
        <code>&amp;#x2460;</code> (circled digit one) has a range
        of 1 to 20 imposed by the Unicode character
        repertoire.</span> For the numbering sequences described
        above <span>any upper bound imposed by the implementation
        <span class="verb">must not</span> be less than 1000 (one
        thousand) and any lower bound must not be greater than 1.
        Numbers that fall outside this range <span class=
        "verb">must</span> be formatted using the format token
        <code>1</code>. The numbering sequence associated with the
        format token <code>1</code> has a lower bound of 0
        (zero)</span>.</p>

        <p>The above expansions of numbering sequences for format
        tokens such as <code>a</code> and <code>i</code> are
        indicative but not prescriptive. There are various
        conventions in use for how alphabetic sequences continue
        when the alphabet is exhausted, and differing conventions
        for how roman numerals are written (for example,
        <code>IV</code> versus <code>IIII</code> as the
        representation of the number 4). Sometimes alphabetic
        sequences are used that omit letters such as <code>i</code>
        and <code>o</code>. This specification does not prescribe
        the detail of any sequence other than those sequences
        consisting entirely of decimal digits.</p>

        <p>Many numbering sequences are language-sensitive. This
        applies especially to the sequence selected by the tokens
        <code>w</code>, <code>W</code> and <code>Ww</code>. It also
        applies to other sequences, for example different languages
        using the Cyrillic alphabet use different sequences of
        characters, each starting with the letter #x410 (Cyrillic
        capital letter A). In such cases, the <code>lang</code>
        attribute specifies which language's conventions are to be
        used; it has the same range of values as
        <code>xml:lang</code> (see <a href="#REC-xml">[XML
        1.0]</a>). If no <code>lang</code> value is specified, the
        language that is used is <a title="implementation-defined"
        href=
        "#dt-implementation-defined">implementation-defined</a>.
        The set of languages for which numbering is supported is
        <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>. If
        a language is requested that is not supported, the
        processor uses the language that it would use if the
        <code>lang</code> attribute were omitted.</p>

        <p>If the optional <code>ordinal</code> attribute is
        present, and if its value is not a zero-length string, this
        indicates a request to output ordinal numbers rather than
        cardinal numbers. For example, in English, the value
        <code>ordinal="yes"</code> when used with the format token
        <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th
        ...</code>, and when used with the format token
        <code>w</code> outputs the sequence <code>first second
        third fourth ...</code>. In some languages, ordinal numbers
        vary depending on the grammatical context, for example they
        may have different genders and may decline with the noun
        that they qualify. In such cases the value of the
        <code>ordinal</code> attribute may be used to indicate the
        variation of the ordinal number required. The way in which
        the variation is indicated will depend on the conventions
        of the language. For inflected languages that vary the
        ending of the word, the preferred approach is to indicate
        the required ending, preceded by a hyphen: for example in
        German, appropriate values are <code>-e, -er, -es,
        -en</code>. <span>It is <a title="implementation-defined"
        href=
        "#dt-implementation-defined">implementation-defined</a>
        what combinations of values of the format token, the
        language, and the <code>ordinal</code> attribute are
        supported.</span> If ordinal numbering is not supported for
        the combination of the format token, the language, and the
        actual value of the <code>ordinal</code> attribute, the
        request is ignored and cardinal numbers are generated
        instead.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e19098" id="d5e19098"></a>Example: Ordinal
            Numbering in Italian
          </div>

          <p>The specification <code>format="1" ordinal="-º"
          lang="it"</code>, if supported, should produce the
          sequence:</p>

          <div class="exampleInner">
            <pre>
1º 2º 3º 4º ...
</pre>
          </div>

          <p>The specification <code>format="Ww" ordinal="-o"
          lang="it"</code>, if supported, should produce the
          sequence:</p>

          <div class="exampleInner">
            <pre>
Primo Secondo Terzo Quarto Quinto ...
</pre>
          </div>
        </div>

        <p>The <code>letter-value</code> attribute disambiguates
        between numbering sequences that use letters. In many
        languages there are two commonly used numbering sequences
        that use letters. One numbering sequence assigns numeric
        values to letters in alphabetic sequence, and the other
        assigns numeric values to each letter in some other manner
        traditional in that language. In English, these would
        correspond to the numbering sequences specified by the
        format tokens <code>a</code> and <code>i</code>. In some
        languages, the first member of each sequence is the same,
        and so the format token alone would be ambiguous. A value
        of <code>alphabetic</code> specifies the alphabetic
        sequence; a value of <code>traditional</code> specifies the
        other sequence. If the <code>letter-value</code> attribute
        is not specified, then it is <a title=
        "implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>
        how any ambiguity is resolved.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Implementations may use <span><a title=
          "extension attribute" href=
          "#dt-extension-attribute">extension attributes</a></span>
          on <a href="#element-number"><code>xsl:number</code></a>
          to provide additional control over the way in which
          numbers are formatted.</p>
        </div>

        <p>The <code>grouping-separator</code> attribute gives the
        separator used as a grouping (for example, thousands)
        separator in decimal numbering sequences, and the optional
        <code>grouping-size</code> specifies the size (normally 3)
        of the grouping. For example,
        <code>grouping-separator=","</code> and
        <code>grouping-size="3"</code> would produce numbers of the
        form <code>1,000,000</code> while
        <code>grouping-separator="."</code> and
        <code>grouping-size="2"</code> would produce numbers of the
        form <code>1.00.00.00</code>. If only one of the
        <code>grouping-separator</code> and
        <code>grouping-size</code> attributes is specified, then it
        is ignored.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e19182" id="d5e19182"></a>Example: Format
            Tokens and the Resulting Sequences
          </div>

          <p>These examples use non-Latin characters which might
          not display correctly in all browsers, depending on the
          system configuration.</p>

          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th align="left">Description</th>

                <th align="left">Format Token</th>

                <th align="left">Sequence</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>French cardinal words</td>

                <td><code>format="Ww" lang="fr"</code></td>

                <td>Un, Deux, Trois, Quatre</td>
              </tr>

              <tr>
                <td>German ordinal words</td>

                <td><code>format="w" ordinal="-e"
                lang="de"</code></td>

                <td>erste, zweite, dritte, vierte</td>
              </tr>

              <tr>
                <td>Katakana numbering</td>

                <td><code>format="&amp;#x30A2;"</code></td>

                <td>ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ, ス, セ, ソ, タ,
                チ, ツ, テ, ト, ナ, ニ, ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム,
                メ, モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ, ヰ, ヱ, ヲ, ン</td>
              </tr>

              <tr>
                <td>Katakana numbering in iroha order</td>

                <td><code>format="&amp;#x30A4;"</code></td>

                <td>イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ, ワ, カ, ヨ, タ,
                レ, ソ, ツ, ネ, ナ, ラ, ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ,
                エ, テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ, モ, セ, ス</td>
              </tr>

              <tr>
                <td>Thai numbering</td>

                <td><code>format="&amp;#x0E51;"</code></td>

                <td>๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑, ๑๒, ๑๓, ๑๔,
                ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐</td>
              </tr>

              <tr>
                <td>Traditional Hebrew numbering</td>

                <td><code>format="&amp;#x05D0;"
                letter-value="traditional"</code></td>

                <td>א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב, יג, יד,
                טו, טז, יז, יח, יט, כ</td>
              </tr>

              <tr>
                <td>Traditional Georgian numbering</td>

                <td><code>format="&amp;#x10D0;"
                letter-value="traditional"</code></td>

                <td>ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ, იგ, იდ,
                იე, ივ, იზ, იჱ, ით, კ</td>
              </tr>

              <tr>
                <td>Classical Greek numbering (see note)</td>

                <td><code>format="&amp;#x03B1;"
                letter-value="traditional"</code></td>

                <td>αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ, ιʹ, ιαʹ,
                ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ, κʹ</td>
              </tr>

              <tr>
                <td>Old Slavic numbering</td>

                <td><code>format="&amp;#x0430;"
                letter-value="traditional"</code></td>

                <td>А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ, ГӀ, ДӀ,
                ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К</td>
              </tr>
            </tbody>
          </table>

          <p>Note that Glassical Greek is an example where the
          format token is not the same as the representation of the
          number 1.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="sorting" id="sorting"></a>13 Sorting</h2>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-sort-key-specification" id="dt-sort-key-specification"
      title="sort key specification"></a>A <b>sort key
      specification</b> is a sequence of one or more adjacent
      <a href="#element-sort"><code>xsl:sort</code></a> elements
      which together define rules for sorting the items in an input
      sequence to form a sorted sequence.<span class=
      "definition">]</span></p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-sort-key-component" id="dt-sort-key-component" title=
      "sort key component"></a>Within a <a title=
      "sort key specification" href=
      "#dt-sort-key-specification">sort key specification</a>, each
      <a href="#element-sort"><code>xsl:sort</code></a> element
      defines one <b>sort key component</b>.<span class=
      "definition">]</span> The first <a href=
      "#element-sort"><code>xsl:sort</code></a> element specifies
      the primary component of the sort key specification, the
      second <a href="#element-sort"><code>xsl:sort</code></a>
      element specifies the secondary component of the sort key
      specification and so on.</p>

      <p>A sort key specification may occur immediately within an
      <a href=
      "#element-apply-templates"><code>xsl:apply-templates</code></a>,
      <a href="#element-for-each"><code>xsl:for-each</code></a>,
      <a href=
      "#element-perform-sort"><code>xsl:perform-sort</code></a>, or
      <a href=
      "#element-for-each-group"><code>xsl:for-each-group</code></a>
      element.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>When used within <a href=
        "#element-for-each"><code>xsl:for-each</code></a>, <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>,
        or <a href=
        "#element-perform-sort"><code>xsl:perform-sort</code></a>,
        <a href="#element-sort"><code>xsl:sort</code></a> elements
        must occur before any other children.</p>
      </div>

      <div class="div2">
        <h3><a name="xsl-sort" id="xsl-sort"></a>13.1 The <a href=
        "#element-sort"><code>xsl:sort</code></a> Element</h3>

        <p class="element-syntax"><a name="element-sort" id=
        "element-sort"></a><code>&lt;xsl:sort<br />
        &#160;&#160;select? = <var>expression</var><br />
        &#160;&#160;lang? = { <var>nmtoken</var> }<br />
        &#160;&#160;order? = { "ascending" | "descending" }<br />
        &#160;&#160;collation? = { <var>uri</var> }<br />
        &#160;&#160;stable? = { "yes" | "no" }<br />
        &#160;&#160;case-order? = { "upper-first" | "lower-first"
        }<br />
        &#160;&#160;data-type? = { "text" | "number" |
        <var>qname-but-not-ncname</var> }&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:sort&gt;</code></p>

        <p>The <a href="#element-sort"><code>xsl:sort</code></a>
        element defines a <a title="sort key component" href=
        "#dt-sort-key-component">sort key component</a>. A sort key
        component specifies how a <a title="sort key value" href=
        "#dt-sort-key-value">sort key value</a> is to be computed
        for each item in the sequence being sorted, and also how
        two sort key values are to be compared.</p>

        <p>The value of a <a title="sort key component" href=
        "#dt-sort-key-component">sort key component</a> is
        determined either by its <code>select</code> attribute, or
        by the contained <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>. If
        neither is present, the default is <code>select="."</code>,
        which has the effect of sorting on the actual value of the
        item if it is an atomic value, or on the typed-value of the
        item if it is a node. If a <code>select</code> attribute is
        present, its value <span class="verb">must</span> be an
        XPath <a title="expression" href=
        "#dt-expression">expression</a>.</p>

        <p><a name="err-XTSE1015" id="err-XTSE1015"><span class=
        "error">[ERR XTSE1015]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an <a href="#element-sort"><code>xsl:sort</code></a>
        element with a <code>select</code> attribute has non-empty
        content.</p>

        <p>Those attributes of the <a href=
        "#element-sort"><code>xsl:sort</code></a> elements whose
        values are <a title="attribute value template" href=
        "#dt-attribute-value-template">attribute value
        templates</a> are evaluated using the same <a title="focus"
        href="#dt-focus">focus</a> as is used to evaluate the
        <code>select</code> attribute of the containing instruction
        (specifically, <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        <a href="#element-for-each"><code>xsl:for-each</code></a>,
        <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>,
        or <a href=
        "#element-perform-sort"><code>xsl:perform-sort</code></a>).</p>

        <p>The <code>stable</code> attribute is permitted only on
        the first <a href="#element-sort"><code>xsl:sort</code></a>
        element within a <a title="sort key specification" href=
        "#dt-sort-key-specification">sort key specification</a></p>

        <p><a name="err-XTSE1017" id="err-XTSE1017"><span class=
        "error">[ERR XTSE1017]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an <a href="#element-sort"><code>xsl:sort</code></a>
        element other than the first in a sequence of sibling
        <a href="#element-sort"><code>xsl:sort</code></a> elements
        has a <code>stable</code> attribute.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-stable"
        id="dt-stable" title="stable"></a>A <a title=
        "sort key specification" href=
        "#dt-sort-key-specification">sort key specification</a> is
        said to be <b>stable</b> if its first <a href=
        "#element-sort"><code>xsl:sort</code></a> element has no
        <code>stable</code> attribute, or has a <code>stable</code>
        attribute whose <a title="effective value" href=
        "#dt-effective-value">effective value</a> is
        <code>yes</code>.<span class="definition">]</span></p>

        <div class="div3">
          <h4><a name="sorting-process" id=
          "sorting-process"></a>13.1.1 The Sorting Process</h4>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-initial-sequence" id="dt-initial-sequence" title=
          "initial sequence"></a>The sequence to be sorted is
          referred to as the <b>initial sequence</b>.<span class=
          "definition">]</span></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-sorted-sequence" id="dt-sorted-sequence" title=
          "sorted sequence"></a>The sequence after sorting as
          defined by the <a href=
          "#element-sort"><code>xsl:sort</code></a> elements is
          referred to as the <b>sorted sequence</b>.<span class=
          "definition">]</span></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-sort-key-value" id="dt-sort-key-value" title=
          "sort key value"></a> For each item in the <a title=
          "initial sequence" href="#dt-initial-sequence">initial
          sequence</a>, a value is computed for each <a title=
          "sort key component" href="#dt-sort-key-component">sort
          key component</a> within the <a title=
          "sort key specification" href=
          "#dt-sort-key-specification">sort key specification</a>.
          The value computed for an item by using the
          <var>N</var>th sort key component is referred to as the
          <var>N</var>th <b>sort key value</b> of that
          item.<span class="definition">]</span></p>

          <p>The items in the <a title="initial sequence" href=
          "#dt-initial-sequence">initial sequence</a> are ordered
          into a <a title="sorted sequence" href=
          "#dt-sorted-sequence">sorted sequence</a> by comparing
          their <a title="sort key value" href=
          "#dt-sort-key-value">sort key values</a>. The relative
          position of two items <var>A</var> and <var>B</var> in
          the sorted sequence is determined as follows. The first
          sort key value of <var>A</var> is compared with the first
          sort key value of <var>B</var>, according to the rules of
          the first <a title="sort key component" href=
          "#dt-sort-key-component">sort key component</a>. If,
          under these rules, <var>A</var> is less than
          <var>B</var>, then <var>A</var> will precede <var>B</var>
          in the sorted sequence, unless the <code>order</code>
          attribute of this <a title="sort key component" href=
          "#dt-sort-key-component">sort key component</a> specifies
          <code>descending</code>, in which case <var>B</var> will
          precede <var>A</var> in the sorted sequence. If, however,
          the relevant sort key values compare equal, then the
          second sort key value of <var>A</var> is compared with
          the second sort key value of <var>B</var>, according to
          the rules of the second <a title="sort key component"
          href="#dt-sort-key-component">sort key component</a>.
          This continues until two sort key values are found that
          compare unequal. If all the sort key values compare
          equal, <span>and the <a title="sort key specification"
          href="#dt-sort-key-specification">sort key
          specification</a> is <a title="stable" href=
          "#dt-stable">stable</a>,</span> then <var>A</var> will
          precede <var>B</var> in the <a title="sorted sequence"
          href="#dt-sorted-sequence">sorted sequence</a> if and
          only if <var>A</var> preceded <var>B</var> in the
          <a title="initial sequence" href=
          "#dt-initial-sequence">initial sequence</a>. <span>If all
          the sort key values compare equal, and the <a title=
          "sort key specification" href=
          "#dt-sort-key-specification">sort key specification</a>
          is not <a title="stable" href="#dt-stable">stable</a>,
          then the relative order of <var>A</var> and <var>B</var>
          in the <a title="sorted sequence" href=
          "#dt-sorted-sequence">sorted sequence</a> is <a title=
          "implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>.</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>If two items have equal <a title="sort key value"
            href="#dt-sort-key-value">sort key values</a>,
            <span>and the sort is <a title="stable" href=
            "#dt-stable">stable</a>,</span> then their order in the
            <a title="sorted sequence" href=
            "#dt-sorted-sequence">sorted sequence</a> will be the
            same as their order in the <a title="initial sequence"
            href="#dt-initial-sequence">initial sequence</a>,
            regardless of whether <code>order="descending"</code>
            was specified on any or all of the <a title=
            "sort key component" href="#dt-sort-key-component">sort
            key components</a>.</p>
          </div>

          <p>The <var>N</var>th sort key value is computed by
          evaluating either the <code>select</code> attribute or
          the contained <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> of
          the <var>N</var>th <a href=
          "#element-sort"><code>xsl:sort</code></a> element, or the
          expression <code>.</code> (dot) if neither is present.
          This evaluation is done with the <a title="focus" href=
          "#dt-focus">focus</a> set as follows:</p>

          <ul>
            <li>
              <p>The <a title="context item" href=
              "#dt-context-item">context item</a> is the item in
              the <a title="initial sequence" href=
              "#dt-initial-sequence">initial sequence</a> whose
              <a title="sort key value" href=
              "#dt-sort-key-value">sort key value</a> is being
              computed.</p>
            </li>

            <li>
              <p>The <a title="context position" href=
              "#dt-context-position">context position</a> is the
              position of that item in the initial sequence.</p>
            </li>

            <li>
              <p>The <a title="context size" href=
              "#dt-context-size">context size</a> is the size of
              the initial sequence.</p>
            </li>
          </ul>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>As in any other XPath expression, the <a href=
            "#function-current"><code>current</code></a> function
            may be used within the <code>select</code> expression
            of <a href="#element-sort"><code>xsl:sort</code></a> to
            refer to the item that is the context item for the
            expression as a whole; that is, the item whose
            <a title="sort key value" href=
            "#dt-sort-key-value">sort key value</a> is being
            computed.</p>
          </div>

          <p>The <a title="sort key value" href=
          "#dt-sort-key-value">sort key values</a> are <a title=
          "atomize" href="#dt-atomization">atomized</a>, and are
          then compared. The way they are compared depends on their
          data type, as described in the next section.</p>
        </div>

        <div class="div3">
          <h4><a name="comparing-sort-keys" id=
          "comparing-sort-keys"></a>13.1.2 Comparing Sort Key
          Values</h4>

          <p>It is possible to force the system to compare
          <a title="sort key value" href="#dt-sort-key-value">sort
          key values</a> using the rules for a particular data type
          by including a cast as part of the <a title=
          "sort key component" href="#dt-sort-key-component">sort
          key component</a>. For example, <code>&lt;xsl:sort
          select="xs:date(@dob)"/&gt;</code> will force the
          attributes to be compared as dates. In the absence of
          such a cast, the sort key values are compared using the
          rules appropriate to their data type. Any values of type
          <span><code>xs:untypedAtomic</code></span> are cast to
          <code>xs:string</code>.</p>

          <p>For backwards compatibility with XSLT 1.0, the
          <code>data-type</code> attribute <span>remains available.
          If this has the <a title="effective value" href=
          "#dt-effective-value">effective value</a>
          <code>text</code>, the atomized <a title="sort key value"
          href="#dt-sort-key-value">sort key values</a> are
          converted to strings before being compared. If it has the
          effective value <code>number</code>, the atomized sort
          key values are converted to doubles before being
          compared. The conversion is done by using the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-string"><code>
          string</code></a><sup><small>FO</small></sup> or <a href=
          "http://www.w3.org/TR/xpath-functions/#func-number"><code>
          number</code></a><sup><small>FO</small></sup> function as
          appropriate.</span> If the <code>data-type</code>
          attribute has any other <a title="effective value" href=
          "#dt-effective-value">effective value</a>, then the value
          <span class="verb">must</span> be a <span><a title=
          "lexical QName" href="#dt-lexical-qname">lexical
          QName</a> with a non-empty prefix</span>, and the effect
          of the attribute is <a title="implementation-defined"
          href=
          "#dt-implementation-defined">implementation-defined</a>.</p>

          <p><a name="err-XTTE1020" id="err-XTTE1020"><span class=
          "error">[ERR XTTE1020]</span></a> If any <a title=
          "sort key value" href="#dt-sort-key-value">sort key
          value</a>, after <a title="atomize" href=
          "#dt-atomization">atomization</a> and any type conversion
          <span class="verb">required</span> by the
          <code>data-type</code> attribute, is a sequence
          containing more than one item, then the effect depends on
          whether the <a href=
          "#element-sort"><code>xsl:sort</code></a> element is
          evaluated with <a title="backwards compatible behavior"
          href="#dt-backwards-compatible-behavior">backwards
          compatible behavior</a>. With backwards compatible
          behavior, the effective sort key value is the first item
          in the sequence. In other cases, this is a <a title=
          "type errors" href="#dt-type-error">type error</a>.</p>

          <p>The set of <a title="sort key value" href=
          "#dt-sort-key-value">sort key values</a> (after any
          conversion) is first divided into <span>two categories:
          empty values, and ordinary values.</span> The empty sort
          key values represent those items where the sort key value
          is an empty sequence. These values are considered for
          sorting purposes to be equal to each other, but less than
          any other value. The remaining values are classified as
          ordinary values.</p>

          <p><a name="err-XTDE1030" id="err-XTDE1030"><span class=
          "error">[ERR XTDE1030]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if, for any <a title="sort key component" href=
          "#dt-sort-key-component">sort key component</a>, the set
          of <a title="sort key value" href=
          "#dt-sort-key-value">sort key values</a> evaluated for
          all the items in the <a title="initial sequence" href=
          "#dt-initial-sequence">initial sequence</a>, after any
          type conversion requested, contains a pair of ordinary
          values for which the result of the XPath <code>lt</code>
          operator is an error.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The above error condition may occur if the values to
            be sorted are of a type that does not support ordering
            (for example, <code>xs:QName</code>) or if the sequence
            is heterogeneous (for example, if it contains both
            strings and numbers). The error can generally be
            prevented by invoking a cast or constructor function
            within the sort key component.</p>

            <p>The error condition is subject to the usual caveat
            that a processor is not required to evaluate any
            expression solely in order to determine whether it
            raises an error. For example, if there are several sort
            key components, then a processor is not required to
            evaluate or compare minor sort key values unless the
            corresponding major sort key values are equal.</p>
          </div>

          <p>In general, comparison of two ordinary values is
          performed according to the rules of the XPath
          <code>lt</code> operator. <span>To ensure a total
          ordering, the same implementation of the <code>lt</code>
          operator <span class="verb">must</span> be used for all
          the comparisons: the one that is chosen is the one
          appropriate to the most specific type to which all the
          values can be converted by subtype substitution and/or
          type promotion. For example, if the sequence contains
          both <code>xs:decimal</code> and <code>xs:double</code>
          values, then the values are compared using
          <code>xs:double</code> comparison, even when comparing
          two <code>xs:decimal</code> values.</span> NaN values,
          for sorting purposes, are considered to be equal to each
          other, and less than any other numeric value. Special
          rules also apply to the <code>xs:string</code> <span>and
          <code>xs:anyURI</code> types, and types derived by
          restriction therefrom,</span>, as described in the next
          section.</p>
        </div>

        <div class="div3">
          <h4><a name="collating-sequences" id=
          "collating-sequences"></a>13.1.3 Sorting Using
          Collations</h4>

          <p>The rules given in this section apply when comparing
          values whose type is <code>xs:string</code> or a type
          derived by restriction from <code>xs:string</code><span>,
          or whose type is <code>xs:anyURI</code> or a type derived
          by restriction from <code>xs:anyURI</code></span>.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-collation" id="dt-collation" title=
          "collation"></a>Facilities in XSLT 2.0 and XPath 2.0 that
          require strings to be ordered rely on the concept of a
          named <b>collation</b>. A collation is a set of rules
          that determine whether two strings are equal, and if not,
          which of them is to be sorted before the
          other.<span class="definition">]</span> A collation is
          identified by a URI, but the manner in which this URI is
          associated with an actual rule or algorithm is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.</p>

          <p>The one collation URI that must be recognized by every
          implementation is
          <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>,
          which provides the ability to compare strings based on
          the Unicode codepoint values of the characters in the
          string.</p>

          <p>For more information about collations, see <a href=
          "http://www.w3.org/TR/xpath-functions/#string-compare">Section
          7.3 Equality and Comparison of
          Strings</a><sup><small>FO</small></sup> in <a href=
          "#xpath-functions">[Functions and Operators]</a>. Some
          specifications, for example <a href=
          "#UNICODE-TR10">[UNICODE TR10]</a>, use the term
          "collation" to describe rules that can be tailored or
          parameterized for various purposes. In this
          specification, a collation URI refers to a collation in
          which all such parameters have already been fixed.
          Therefore, if a collation URI is specified, other
          attributes such as <code>case-order</code> and
          <code>lang</code> are ignored.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The reason XSLT does not provide detailed mechanisms
            for defining collating sequences is that many
            implementations will re-use collating mechanisms
            available from the underlying implementation platform
            (for example, from the operating system or from the
            run-time library of a chosen programming language).
            These will inevitably differ from one XSLT
            implementation to another.</p>
          </div>

          <p>If the <a href=
          "#element-sort"><code>xsl:sort</code></a> element has a
          <code>collation</code> attribute, then the strings are
          compared according to the rules for the named <a title=
          "collation" href="#dt-collation">collation</a>: that is,
          they are compared using the XPath function call
          <code>compare($a, $b, $collation)</code>.</p>

          <p>If the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>collation</code> attribute of <a href=
          "#element-sort"><code>xsl:sort</code></a> is a relative
          URI, then it is resolved against the base URI of the
          <a href="#element-sort"><code>xsl:sort</code></a>
          element.</p>

          <p><a name="err-XTDE1035" id="err-XTDE1035"><span class=
          "error">[ERR XTDE1035]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <code>collation</code> attribute of
          <a href="#element-sort"><code>xsl:sort</code></a> (after
          resolving against the base URI) is not a URI that is
          recognized by the implementation as referring to a
          collation.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It is entirely for the implementation to determine
            whether it recognizes a particular collation URI. For
            example, if the implementation allows collation URIs to
            contain parameters in the query part of the URI, it is
            the implementation that determines whether a URI
            containing an unknown or invalid parameter is or is not
            a recognized collation URI. <span>The fact that this
            error is described as non-recoverable thus does not
            prevent an implementation applying a fallback collation
            if it chooses to do so.</span></p>
          </div>

          <p>The <code>lang</code> and <code>case-order</code>
          attributes are ignored if a <code>collation</code>
          attribute is present. But in the absence of a
          <code>collation</code> attribute, these attributes
          provide input to an <a title="implementation-defined"
          href=
          "#dt-implementation-defined">implementation-defined</a>
          algorithm to <span>locate</span> a suitable
          collation:</p>

          <ul>
            <li>
              <p>The <code>lang</code> attribute indicates that a
              collation suitable for a particular natural language
              <span class="verb">should</span> be used. The
              <a title="effective value" href=
              "#dt-effective-value">effective value</a> of the
              attribute <span class="verb">must</span> be a value
              that would be valid for the <code>xml:lang</code>
              attribute (see <a href="#REC-xml">[XML 1.0]</a>).</p>
            </li>

            <li>
              <p>The <code>case-order</code> attribute indicates
              whether the desired collation <span class=
              "verb">should</span> sort upper-case letters before
              lower-case or vice versa. The <a title=
              "effective value" href=
              "#dt-effective-value">effective value</a> of the
              attribute <span class="verb">must</span> be either
              <code>lower-first</code> (indicating that lower-case
              letters precede upper-case letters in the collating
              sequence) or <code>upper-first</code> (indicating
              that upper-case letters precede lower-case).</p>
            </li>
          </ul>

          <p>If none of the <code>collation</code>,
          <code>lang</code> or <code>case-order</code> attributes
          is present, the collation is chosen in an <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          way. It is not <span class="verb">required</span> that
          the default collation for sorting should be the same as
          the <a title="default collation" href=
          "#dt-default-collation">default collation</a> used when
          evaluating XPath expressions, as described in <a href=
          "#static-context"><i>5.4.1 Initializing the Static
          Context</i></a> and <a href=
          "#default-collation-attribute"><i>3.6.1 The
          default-collation attribute</i></a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>It is usually appropriate, when sorting, to use a
            strong collation, that is, one that takes account of
            secondary differences (accents) and tertiary
            differences (case) between strings that are otherwise
            equal. A weak collation, which ignores such
            differences, may be more suitable when comparing
            strings for equality.</p>

            <p>Useful background information on international
            sorting is provided in <a href="#UNICODE-TR10">[UNICODE
            TR10]</a>. The <code>case-order</code> attribute may be
            interpreted as described in section 6.6 of <a href=
            "#UNICODE-TR10">[UNICODE TR10]</a>.</p>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="creating-sorted-sequence" id=
        "creating-sorted-sequence"></a>13.2 Creating a Sorted
        Sequence</h3>

        <p class="element-syntax"><a name="element-perform-sort"
        id="element-perform-sort"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:perform-sort<br />
        &#160;&#160;select? = <var>expression</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-sort">xsl:sort</a>+,
        <var>sequence-constructor</var>) --&gt;<br />
        &lt;/xsl:perform-sort&gt;</code></p>

        <p>The <a href=
        "#element-perform-sort"><code>xsl:perform-sort</code></a>
        instruction is used to return a <a title="sorted sequence"
        href="#dt-sorted-sequence">sorted sequence</a>.</p>

        <p>The <a title="initial sequence" href=
        "#dt-initial-sequence">initial sequence</a> is obtained
        either by evaluating the <code>select</code> attribute or
        by evaluating the contained sequence constructor (but not
        both). If there is no <code>select</code> attribute and no
        sequence constructor then the <a title="initial sequence"
        href="#dt-initial-sequence">initial sequence</a> (and
        therefore, the <a title="sorted sequence" href=
        "#dt-sorted-sequence">sorted sequence</a>) is an empty
        sequence.</p>

        <p><a name="err-XTSE1040" id="err-XTSE1040"><span class=
        "error">[ERR XTSE1040]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        an <a href=
        "#element-perform-sort"><code>xsl:perform-sort</code></a>
        instruction with a <code>select</code> attribute has any
        content other than <a href=
        "#element-sort"><code>xsl:sort</code></a> and <a href=
        "#element-fallback"><code>xsl:fallback</code></a>
        instructions.</p>

        <p>The result of the <a href=
        "#element-perform-sort"><code>xsl:perform-sort</code></a>
        instruction is the result of sorting its <a title=
        "initial sequence" href="#dt-initial-sequence">initial
        sequence</a> using its contained <a title=
        "sort key specification" href=
        "#dt-sort-key-specification">sort key
        specification</a>.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e20205" id="d5e20205"></a>Example: Sorting a
            Sequence of Atomic Values
          </div>

          <p>The following stylesheet function sorts a sequence of
          atomic values using the value itself as the sort key.</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:function name="local:sort" as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e20212" id="d5e20212"></a>Example: Writing a
            Function to Perform a Sort
          </div>

          <p>The following example defines a function that sorts
          books by price, and uses this function to output the five
          books that have the lowest prices:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:function name="bib:books-by-price" as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)[position() = 1 to 5]"/&gt;

 
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="sorted-iteration" id=
        "sorted-iteration"></a>13.3 Processing a Sequence in Sorted
        Order</h3>

        <p>When used within <a href=
        "#element-for-each"><code>xsl:for-each</code></a> or
        <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        a <a title="sort key specification" href=
        "#dt-sort-key-specification">sort key specification</a>
        indicates that the sequence of items selected by that
        instruction is to be processed in sorted order, not in the
        order of the supplied sequence.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e20233" id="d5e20233"></a>Example:
            Processing Elements in Sorted Order
          </div>

          <p>For example, suppose an employee database has the
          form</p>

          <div class="exampleInner">
            <pre>
&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;
</pre>
          </div>

          <p>Then a list of employees sorted by name could be
          generated using:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>When used within <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>,
        a <a title="sort key specification" href=
        "#dt-sort-key-specification">sort key specification</a>
        indicates the order in which the groups are to be
        processed. For the effect of <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>,
        see <a href="#grouping"><i>14 Grouping</i></a>.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="grouping" id="grouping"></a>14 Grouping</h2>

      <p>The facilities described in this section are designed to
      allow items in a sequence to be grouped based on common
      values; for example it allows grouping of elements having the
      same value for a particular attribute, or elements with the
      same name, or elements with common values for any other
      <a title="expression" href="#dt-expression">expression</a>.
      Since grouping identifies items with duplicate values, the
      same facilities also allow selection of the distinct values
      in a sequence of items, that is, the elimination of
      duplicates.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>Simple elimination of duplicates can also be achieved
        using the function <a href=
        "http://www.w3.org/TR/xpath-functions/#func-distinct-values">
        <code>distinct-values</code></a><sup><small>FO</small></sup>
        in the <a title="core function" href=
        "#dt-core-function">core function</a> library: see <a href=
        "#xpath-functions">[Functions and Operators]</a>.</p>
      </div>

      <p>In addition these facilities allow grouping based on
      sequential position, for example selecting groups of adjacent
      <code>para</code> elements. The facilities also provide an
      easy way to do fixed-size grouping, for example identifying
      groups of three adjacent nodes, which is useful when
      arranging data in multiple columns.</p>

      <p>For each group of items identified, it is possible to
      evaluate a <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> for the
      group. Grouping is nestable to multiple levels so that groups
      of distinct items can be identified, then from among the
      distinct groups selected, further sub-grouping of distinct
      items in the current group can be done.</p>

      <p>It is also possible for one item to participate in more
      than one group.</p>

      <div class="div2">
        <h3><a name="current-group" id="current-group"></a>14.1 The
        Current Group</h3><a name="function-current-group" id=
        "function-current-group"></a>

        <div class="proto">
          <code class="function">current-group</code>()<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">item()*</code>
        </div>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-current-group" id="dt-current-group" title=
        "current group"></a>The evaluation context for XPath
        <a title="expression" href="#dt-expression">expressions</a>
        includes a <span>component</span> called the <b>current
        group</b>, which is a sequence. The current group is the
        collection of related items that are processed collectively
        in one iteration of the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element.<span class="definition">]</span></p>

        <p>While an <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction is being evaluated, the <a title=
        "current group" href="#dt-current-group">current group</a>
        will be non-empty. At other times, it will be an empty
        sequence.</p>

        <p>The function <a href=
        "#function-current-group"><code>current-group</code></a>
        returns the current group.</p>

        <p>The function takes no arguments.</p>

        <p><a name="err-XTSE1060" id="err-XTSE1060"><span class=
        "error">[ERR XTSE1060]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a href=
        "#function-current-group"><code>current-group</code></a>
        function is used within a <a title="pattern" href=
        "#dt-pattern">pattern</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="current-grouping-key" id=
        "current-grouping-key"></a>14.2 The Current Grouping
        Key</h3><a name="function-current-grouping-key" id=
        "function-current-grouping-key"></a>

        <div class="proto">
          <code class=
          "function">current-grouping-key</code>()<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:anyAtomicType?</code>
        </div>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-current-grouping-key" id="dt-current-grouping-key"
        title="current grouping key"></a>The evaluation context for
        XPath <a title="expression" href=
        "#dt-expression">expressions</a> includes a component
        called the <b>current grouping key</b>, which is an atomic
        value. The current grouping key is <span>the <a title=
        "grouping key" href="#dt-grouping-key">grouping
        key</a></span> shared in common by all the items within the
        <a title="current group" href="#dt-current-group">current
        group</a>.<span class="definition">]</span></p>

        <p>While an <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction with a <code>group-by</code> or
        <code>group-adjacent</code> attribute is being evaluated,
        the <a title="current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a> will be
        <span>a single atomic value</span>. At other times, it will
        be the empty sequence.</p>

        <p>The function <a href=
        "#function-current-grouping-key"><code>current-grouping-key</code></a>
        returns the <a title="current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a>.</p>

        <p>Although the <a title="grouping key" href=
        "#dt-grouping-key">grouping keys</a> of all items in a
        group are by definition equal, they are not necessarily
        identical. For example, one might be an
        <code>xs:float</code> while another is an
        <code>xs:decimal</code>. The <a href=
        "#function-current-grouping-key"><code>current-grouping-key</code></a>
        function is defined to return the grouping key of the
        <a title="initial item" href="#dt-initial-item">initial
        item</a> in the group, after atomization and casting of
        <code>xs:untypedAtomic</code> to
        <code>xs:string</code>.</p>

        <p>The function takes no arguments.</p>

        <p><a name="err-XTSE1070" id="err-XTSE1070"><span class=
        "error">[ERR XTSE1070]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a href=
        "#function-current-grouping-key"><code>current-grouping-key</code></a>
        function is used within a <a title="pattern" href=
        "#dt-pattern">pattern</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="xsl-for-each-group" id=
        "xsl-for-each-group"></a>14.3 The
        <code>xsl:for-each-group</code> Element</h3>

        <p class="element-syntax"><a name="element-for-each-group"
        id="element-for-each-group"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:for-each-group<br />
        &#160;&#160;<b>select</b> = <var>expression</var><br />
        &#160;&#160;group-by? = <var>expression</var><br />
        &#160;&#160;group-adjacent? = <var>expression</var><br />
        &#160;&#160;group-starting-with? = <var>pattern</var><br />
        &#160;&#160;group-ending-with? = <var>pattern</var><br />
        &#160;&#160;collation? = { <var>uri</var> }&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-sort">xsl:sort</a>*,
        <var>sequence-constructor</var>) --&gt;<br />
        &lt;/xsl:for-each-group&gt;</code></p>

        <p>This element is an <a title="instruction" href=
        "#dt-instruction">instruction</a> that may be used anywhere
        within a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name="dt-group"
        id="dt-group" title="group"></a>The <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction <span>allocates the items in an input
        sequence</span> into <b>groups</b> of items (that is, it
        establishes a collection of sequences) based either on
        common values of a grouping key, or on a <a title="pattern"
        href="#dt-pattern">pattern</a> that the initial or final
        node in a group must match.<span class=
        "definition">]</span> The <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>
        that forms the content of the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction is evaluated once for each of these groups.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-population" id="dt-population" title=
        "population"></a>The sequence of items to be grouped, which
        is referred to as the <b>population</b>, is determined by
        evaluating the XPath <a title="expression" href=
        "#dt-expression">expression</a> contained in the
        <code>select</code> attribute.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-population-order" id="dt-population-order" title=
        "population order"></a>The population is treated as a
        sequence; the order of items in this sequence is referred
        to as <b>population order</b><span class=
        "definition">]</span>.</p>

        <p>A group is never empty. If the population is empty, the
        number of groups will be zero. The assignment of items to
        groups depends on the <code>group-by</code>,
        <code>group-adjacent</code>,
        <code>group-starting-with</code>, and
        <code>group-ending-with</code> attributes.</p>

        <p><a name="err-XTSE1080" id="err-XTSE1080"><span class=
        "error">[ERR XTSE1080]</span></a> These four attributes are
        mutually exclusive: it is a <a title="static error" href=
        "#dt-static-error">static error</a> if none of these four
        attributes is present, or if more than one of them is
        present.</p>

        <p><a name="err-XTSE1090" id="err-XTSE1090"><span class=
        "error">[ERR XTSE1090]</span></a> It is an error to specify
        the <code>collation</code> attribute if neither the
        <code>group-by</code> attribute nor
        <code>group-adjacent</code> attribute is specified.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-grouping-key" id="dt-grouping-key" title=
        "grouping key"></a>If either of the <code>group-by</code>
        attribute or <code>group-adjacent</code> attributes is
        present, then <b>grouping keys</b> are calculated for each
        item in the <a title="population" href=
        "#dt-population">population</a>. <span>The grouping keys
        are the items in the sequence obtained by evaluating the
        expression contained in the <code>group-by</code> attribute
        or <code>group-adjacent</code> attribute, atomizing the
        result, and then casting an <code>xs:untypedAtomic</code>
        value to <code>xs:string</code>.</span><span class=
        "definition">]</span></p>

        <p><span>When calculating grouping keys for an item in the
        population,</span> the <a title="expression" href=
        "#dt-expression">expression</a> contained in the
        <code>group-by</code> or <code>group-adjacent</code>
        attribute is evaluated with that item as the <a title=
        "context item" href="#dt-context-item">context item</a>,
        with its position in <a title="population order" href=
        "#dt-population-order">population order</a> as the
        <a title="context position" href=
        "#dt-context-position">context position</a>, and with the
        size of the population as the <a title="context size" href=
        "#dt-context-size">context size</a>. The resulting sequence
        is <a title="atomize" href="#dt-atomization">atomized</a>,
        and each atomic value in the atomized sequence acts as a
        <a title="grouping key" href="#dt-grouping-key">grouping
        key</a> for that item in the population.</p>

        <p>If the <code>group-by</code> attribute is present, then
        an item in the population may have multiple grouping keys:
        that is, the <code>group-by</code> expression evaluates to
        a sequence. The item is included in as many groups as there
        are distinct grouping keys (which may be zero). If the
        <code>group-adjacent</code> attribute is used, then each
        item in the population <span class="verb">must</span> have
        exactly one grouping key value.</p>

        <p><a name="err-XTTE1100" id="err-XTTE1100"><span class=
        "error">[ERR XTTE1100]</span></a> It is a <a title=
        "type errors" href="#dt-type-error">type error</a> if the
        <span>grouping key evaluated using</span> the
        <code>group-adjacent</code> attribute is an empty sequence,
        or a sequence containing more than one item.</p>

        <p><a title="grouping key" href="#dt-grouping-key">Grouping
        keys</a> are compared using the rules for the
        <code>eq</code> operator appropriate to their dynamic type.
        <span>Values of type</span> <code>xs:untypedAtomic</code>
        are cast to <code>xs:string</code> before the comparison.
        Two items that are not comparable using the <code>eq</code>
        operator are considered to be not equal, that is, they are
        allocated to different groups. If the values are strings,
        or untyped atomic values, <span>then if there is a
        <code>collation</code> attribute the values are compared
        using the collation specified as the <a title=
        "effective value" href="#dt-effective-value">effective
        value</a> of the <code>collation</code> attribute, resolved
        if relative against the base URI of the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element. If there is no <code>collation</code> attribute
        then the <a title="default collation" href=
        "#dt-default-collation">default collation</a> is
        used.</span></p>

        <p>For the purposes of grouping, the value <code>NaN</code>
        is considered equal to itself.</p>

        <p><a name="err-XTDE1110" id="err-XTDE1110"><span class=
        "error">[ERR XTDE1110]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the collation URI specified to <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        <span>(after resolving against the base URI)</span> is a
        collation that is not recognized by the implementation.
        (For notes, <span class="error">[see <a href=
        "#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>

        <p>For more information on collations, see <a href=
        "#collating-sequences"><i>13.1.3 Sorting Using
        Collations</i></a>.</p>

        <p><a name="err-XTTE1120" id="err-XTTE1120"><span class=
        "error">[ERR XTTE1120]</span></a> When the
        <code>group-starting-with</code> or
        <code>group-ending-with</code> attribute is used, it is a
        <a title="type errors" href="#dt-type-error">type error</a>
        if the result of evaluating the <code>select</code>
        expression contains an item that is not a node.</p>

        <ul>
          <li>
            <p>If the <code>group-by</code> attribute is present,
            the items in the <a title="population" href=
            "#dt-population">population</a> are examined, in
            population order. For each item <var>J</var>, the
            expression in the <code>group-by</code> attribute is
            evaluated to produce a sequence of zero or more
            <a title="grouping key" href=
            "#dt-grouping-key">grouping key</a> values. For each
            one of these <a title="grouping key" href=
            "#dt-grouping-key">grouping keys</a>, if there is
            already a group created to hold items having that
            grouping key value, <var>J</var> is added to that
            group; otherwise a new group is created for items with
            that grouping key value, and <var>J</var> becomes its
            first member.</p>

            <p>An item in the population may thus be assigned to
            zero, one, or many groups. An item will never be
            assigned more than once to the same group; if two or
            more grouping keys for the same item are equal, then
            the duplicates are ignored. An <em>item</em> here means
            the item at a particular position within the
            population—if the population contains the same node at
            several different positions in the sequence then a
            group may indeed contain duplicate nodes.</p>

            <p>The number of groups will be the same as the number
            of distinct grouping key values present in the
            <a title="population" href=
            "#dt-population">population</a>.</p>
          </li>

          <li>
            <p>If the <code>group-adjacent</code> attribute is
            present, the items in the <a title="population" href=
            "#dt-population">population</a> are examined, in
            population order. If an item has the same value for the
            <a title="grouping key" href=
            "#dt-grouping-key">grouping key</a> as its preceding
            item within the <a title="population" href=
            "#dt-population">population</a> (in <a title=
            "population order" href=
            "#dt-population-order">population order</a>), then it
            is assigned to the same group as its preceding item;
            otherwise a new group is created and the item becomes
            its first member.</p>
          </li>

          <li>
            <p>If the <code>group-starting-with</code> attribute is
            present, then its value <span class="verb">must</span>
            be a <a href="#NT-Pattern">pattern</a>. In this case,
            the items in the population <span class=
            "verb">must</span> all be nodes.</p>

            <p>The nodes in the <a title="population" href=
            "#dt-population">population</a> are examined in
            <a title="population order" href=
            "#dt-population-order">population order</a>. If a node
            matches the pattern, or is the first node in the
            population, then a new group is created and the node
            becomes its first member. Otherwise, the node is
            assigned to the same group as its preceding node within
            the population.</p>
          </li>

          <li>
            <p>If the <code>group-ending-with</code> attribute is
            present, then its value <span class="verb">must</span>
            be a <a href="#NT-Pattern">pattern</a>. In this case,
            the items in the population <span class=
            "verb">must</span> all be nodes.</p>

            <p>The nodes in the <a title="population" href=
            "#dt-population">population</a> are examined in
            <a title="population order" href=
            "#dt-population-order">population order</a>. If a node
            is the first node in the population, or if the previous
            node in the population matches the pattern, then a new
            group is created and the node becomes its first member.
            Otherwise, the node is assigned to the same group as
            its preceding node within the population.</p>
          </li>
        </ul>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-initial-item" id="dt-initial-item" title=
        "initial item"></a>For each <a title="group" href=
        "#dt-group">group</a>, the item within the group that is
        first in <a title="population order" href=
        "#dt-population-order">population order</a> is known as the
        <b>initial item</b> of the group.<span class=
        "definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-first-appearance" id="dt-first-appearance" title=
        "order of first appearance"></a>There is an ordering among
        <a title="group" href="#dt-group">groups</a> referred to as
        the <b>order of first appearance</b>. A group <var>G</var>
        is defined to precede a group <var>H</var> in order of
        first appearance if the <a title="initial item" href=
        "#dt-initial-item">initial item</a> of <var>G</var>
        precedes the initial item of <var>H</var> in population
        order. <span>If two groups <var>G</var> and <var>H</var>
        have the same initial item (because the item is in both
        groups) then <var>G</var> precedes <var>H</var> if the
        <a title="grouping key" href="#dt-grouping-key">grouping
        key</a> of <var>G</var> precedes the grouping key of
        <var>H</var> in the sequence that results from evaluating
        the <code>group-by</code> expression of this initial
        item.</span><span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-processing-order" id="dt-processing-order" title=
        "processing order"></a>There is another ordering among
        groups referred to as <b>processing order</b>. <span>If
        group <var>R</var> precedes group <var>S</var> in
        processing order, then in the result sequence returned by
        the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction the items generated by processing group
        <var>R</var> will precede the items generated by processing
        group <var>S</var>.</span><span class=
        "definition">]</span></p>

        <p>If there are no <a href=
        "#element-sort"><code>xsl:sort</code></a> elements
        immediately within the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element, the <a title="processing order" href=
        "#dt-processing-order">processing order</a> of the
        <a title="group" href="#dt-group">groups</a> is the
        <a title="order of first appearance" href=
        "#dt-first-appearance">order of first appearance</a>.</p>

        <p>Otherwise, the <a href=
        "#element-sort"><code>xsl:sort</code></a> elements
        immediately within the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element define the processing order of the <a title="group"
        href="#dt-group">groups</a> (see <a href="#sorting"><i>13
        Sorting</i></a>). They do not affect the order of items
        within each group. Multiple <a title="sort key component"
        href="#dt-sort-key-component">sort key components</a> are
        allowed, and are evaluated in major-to-minor order. If two
        groups have the same values for all their sort key
        components, they are processed in order of first
        appearance.</p>

        <p>The <code>select</code> <a title="expression" href=
        "#dt-expression">expression</a> of an <a href=
        "#element-sort"><code>xsl:sort</code></a> element is
        evaluated once for each <a title="group" href=
        "#dt-group">group</a>. During this evaluation, the
        <a title="context item" href="#dt-context-item">context
        item</a> is the <a title="initial item" href=
        "#dt-initial-item">initial item</a> of the group, the
        <a title="context position" href=
        "#dt-context-position">context position</a> is the position
        of this item within the set of initial items (that is, one
        item for each group in the <a title="population" href=
        "#dt-population">population</a>) in <a title=
        "population order" href="#dt-population-order">population
        order</a>, the <a title="context size" href=
        "#dt-context-size">context size</a> is the number of
        groups, the <a title="current group" href=
        "#dt-current-group">current group</a> is the group whose
        <a title="sort key value" href="#dt-sort-key-value">sort
        key value</a> is being determined, <span>and the <a title=
        "current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a> is the
        grouping key for that group. If the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction uses the <code>group-starting-with</code> or
        <code>group-ending-with</code> attributes, then the current
        grouping key is the empty sequence.</span></p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21018" id="d5e21018"></a>Example: Sorting
            Groups
          </div>

          <p>For example, this means that if the <a title=
          "grouping key" href="#dt-grouping-key">grouping key</a>
          is <code>@category</code>, you can sort the groups in
          order of their grouping key by writing <code>&lt;xsl:sort
          select="current-grouping-key()"/&gt;</code>; or you can
          sort the groups in order of size by writing
          <code>&lt;xsl:sort
          select="count(current-group())"/&gt;</code></p>
        </div>

        <p>The <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>
        contained in the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element is evaluated once for each of the <a title="group"
        href="#dt-group">groups</a>, in <a title="processing order"
        href="#dt-processing-order">processing order</a>. The
        sequences that result are concatenated, in <a title=
        "processing order" href="#dt-processing-order">processing
        order</a>, to form the result of the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        element. Within the <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a>, the
        <a title="context item" href="#dt-context-item">context
        item</a> is the <a title="initial item" href=
        "#dt-initial-item">initial item</a> of the relevant group,
        the <a title="context position" href=
        "#dt-context-position">context position</a> is the position
        of this item among the sequence of initial items (one item
        for each group) arranged in <a title="processing order"
        href="#dt-processing-order">processing order</a> of the
        groups, the <a title="context size" href=
        "#dt-context-size">context size</a> is the number of
        groups, the <a title="current group" href=
        "#dt-current-group">current group</a> is the <a title=
        "group" href="#dt-group">group</a> being processed,
        <span>and the <a title="current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a> is the
        grouping key for that group. If the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction uses the <code>group-starting-with</code> or
        <code>group-ending-with</code> attributes, then the current
        grouping key is the empty sequence.</span> This has the
        effect that within the <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>, a
        call on <code>position()</code> takes successive values
        <code>1, 2, ... last()</code>.</p>

        <p>During the evaluation of a <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a>, the
        <a title="current group" href="#dt-current-group">current
        group</a> and <a title="current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a> are set
        to the empty sequence, and revert to their previous values
        on completion of evaluation of the stylesheet function.</p>

        <p>On completion of the evaluation of the <a href=
        "#element-for-each-group"><code>xsl:for-each-group</code></a>
        instruction, the <a title="current group" href=
        "#dt-current-group">current group</a> <span>and <a title=
        "current grouping key" href=
        "#dt-current-grouping-key">current grouping key</a></span>
        revert to their previous value.</p>
      </div>

      <div class="div2">
        <h3><a name="grouping-examples" id=
        "grouping-examples"></a>14.4 Examples of Grouping</h3>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21133" id="d5e21133"></a>Example: Grouping
            Nodes based on Common Values
          </div>

          <p>The following example groups a list of nodes based on
          common values. The resulting groups are numbered but
          unsorted, and a total is calculated for each group.</p>

          <p>Source XML document:</p>

          <div class="exampleInner">
            <pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;
</pre>
          </div>

          <p>More specifically, the aim is to produce a four-column
          table, containing one row for each distinct country. The
          four columns are to contain first, a sequence number
          giving the number of the row; second, the name of the
          country, third, a comma-separated alphabetical list of
          the city names within that country, and fourth, the sum
          of the <code>pop</code> attribute for the cities in that
          country.</p>

          <p>Desired output:</p>

          <div class="exampleInner">
            <pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;
</pre>
          </div>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;table xsl:version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;xsl:value-of select="position()"/&gt;&lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="@country"/&gt;&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:value-of select="current-group()/@name" separator=", "/&gt;
      &lt;/td&gt;
      &lt;td&gt;&lt;xsl:value-of select="sum(current-group()/@pop)"/&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21156" id="d5e21156"></a>Example: A
            Composite Grouping Key
          </div>

          <p>Sometimes it is necessary to use a composite grouping
          key: for example, suppose the source document is similar
          to the one used in the previous examples, but allows
          multiple entries for the same country and city, such
          as:</p>

          <div class="exampleInner">
            <pre>
&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;
</pre>
          </div>

          <p>Now suppose we want to list the average value of
          <code>@pop</code> for each (country, name) combination.
          One way to handle this is to concatenate the parts of the
          key, for example <code>&lt;xsl:for-each-group
          select="concat(@country, '/', @name)"&gt;</code>. A more
          flexible solution is to nest one <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          element directly inside another:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
  &lt;xsl:for-each-group select="current-group()" group-by="@name"&gt;
    &lt;p&gt;&lt;xsl:value-of select="@name"/&gt;, &lt;xsl:value-of select="@country"/&gt;:
        &lt;xsl:value-of select="avg(current-group()/@pop)"/&gt;&lt;/p&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:for-each-group&gt;
</pre>
          </div>

          <p>The two approaches are not precisely equivalent. If
          the code were changed to output the value of
          <code>position()</code> alongside <code>@name</code> then
          the first approach (a single <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          element with a compound key) would number the groups (1,
          2, 3), while the second approach (two nested <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          elements) would number them (1, 2, 1).</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21190" id="d5e21190"></a>Example:
            Identifying a Group by its Initial Element
          </div>

          <p>The next example identifies a group not by the
          presence of a common value, but rather by adjacency in
          document order. A group consists of an <code>h2</code>
          element, followed by all the <code>p</code> elements up
          to the next <code>h2</code> element.</p>

          <p>Source XML document:</p>

          <div class="exampleInner">
            <pre>
&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;
</pre>
          </div>

          <p>Desired output:</p>

          <div class="exampleInner">
            <pre>
&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is an XML document used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;
</pre>
          </div>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
        &lt;xsl:for-each-group select="*" group-starting-with="h2"      &gt;
          &lt;section title="{self::h2}"&gt;
            &lt;xsl:for-each select="current-group()[self::p]"&gt;
              &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
            &lt;/xsl:for-each&gt; 
          &lt;/section&gt;
        &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;
</pre>
          </div>

          <p>The use of <code>title="{self::h2}"</code> rather than
          <code>title="{.}"</code> is to handle the case where the
          first element is not an <code>h2</code> element.</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21227" id="d5e21227"></a>Example:
            Identifying a Group by its Final Element
          </div>

          <p>The next example illustrates how a group of related
          elements can be identified by the last element in the
          group, rather than the first. Here the absence of the
          attribute <code>continued="yes"</code> indicates the end
          of the group.</p>

          <p>Source XML document:</p>

          <div class="exampleInner">
            <pre>
&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;
</pre>
          </div>

          <p>Desired output:</p>

          <div class="exampleInner">
            <pre>
&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;
</pre>
          </div>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21247" id="d5e21247"></a>Example: Adding an
            Element to Several Groups
          </div>

          <p>The next example shows how an item can be added to
          multiple groups. Book titles will be added to one group
          for each indexing term marked up within the title.</p>

          <p>Source XML document:</p>

          <div class="exampleInner">
            <pre>
&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;
</pre>
          </div>

          <p>Desired output:</p>

          <div class="exampleInner">
            <pre>
&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
</pre>
          </div>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21264" id="d5e21264"></a>Example: Grouping
            Alternating Sequences of Elements
          </div>

          <p>In the final example, the membership of a node within
          a group is based both on adjacency of the nodes in
          document order, and on common values. In this case, the
          grouping key is a boolean condition, true or false, so
          the effect is that a grouping establishes a maximal
          sequence of nodes for which the condition is true,
          followed by a maximal sequence for which it is false, and
          so on.</p>

          <p>Source XML document:</p>

          <div class="exampleInner">
            <pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;
</pre>
          </div>

          <p>Desired output:</p>

          <div class="exampleInner">
            <pre>
&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;
</pre>
          </div>

          <p>Solution:</p>

          <p>This requires creating a <code>p</code> element around
          the maximal sequence of sibling nodes that does not
          include a <code>ul</code> or <code>ol</code> element.</p>

          <p>This can be done by using <code>group-adjacent</code>,
          with a grouping key that is true if the element is a
          <code>ul</code> or <code>ol</code> element, and false
          otherwise:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="regular-expressions" id=
      "regular-expressions"></a>15 Regular Expressions</h2>

      <p>The <a title="core function" href="#dt-core-function">core
      function</a> library for XPath 2.0 defines three functions
      that make use of regular expressions:</p>

      <ul>
        <li>
          <p><a href=
          "http://www.w3.org/TR/xpath-functions/#func-matches"><code>
          matches</code></a><sup><small>FO</small></sup> returns a
          boolean result that indicates whether or not a string
          matches a given regular expression.</p>
        </li>

        <li>
          <p><a href=
          "http://www.w3.org/TR/xpath-functions/#func-replace"><code>
          replace</code></a><sup><small>FO</small></sup> takes a
          string as input and returns a string obtained by
          replacing all substrings that match a given regular
          expression with a replacement string.</p>
        </li>

        <li>
          <p><a href=
          "http://www.w3.org/TR/xpath-functions/#func-tokenize"><code>
          tokenize</code></a><sup><small>FO</small></sup> returns a
          sequence of strings formed by breaking a supplied input
          string at any separator that matches a given regular
          expression.</p>
        </li>
      </ul>

      <p>These functions are described in <a href=
      "#xpath-functions">[Functions and Operators]</a>.</p>

      <p>For more complex string processing than is possible using
      these functions, XSLT provides an instruction <a href=
      "#element-analyze-string"><code>xsl:analyze-string</code></a>,
      which is defined in this section.</p>

      <p>The regular expressions used by this instruction, and the
      flags that control the interpretation of these regular
      expressions, <span class="verb">must</span> conform to the
      syntax defined in <a href="#xpath-functions">[Functions and
      Operators]</a> (see <a href=
      "http://www.w3.org/TR/xpath-functions/#regex-syntax">Section
      7.6.1 Regular Expression
      Syntax</a><sup><small>FO</small></sup>), which is itself
      based on the syntax defined in <a href="#xmlschema-2">[XML
      Schema Part 2]</a>.</p>

      <div class="div2">
        <h3><a name="analyze-string" id="analyze-string"></a>15.1
        The <code>xsl:analyze-string</code> instruction</h3>

        <p class="element-syntax"><a name="element-analyze-string"
        id="element-analyze-string"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:analyze-string<br />
        &#160;&#160;<b>select</b> = <var>expression</var><br />
        &#160;&#160;<b>regex</b> = { <var>string</var> }<br />
        &#160;&#160;flags? = { <var>string</var> }&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-matching-substring">xsl:matching-substring</a>?,
        <a href=
        "#element-non-matching-substring">xsl:non-matching-substring</a>?,
        <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br />
        &lt;/xsl:analyze-string&gt;</code></p>

        <p class="element-syntax"><a name=
        "element-matching-substring" id=
        "element-matching-substring"></a><code>&lt;xsl:matching-substring&gt;<br />

        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:matching-substring&gt;</code></p>

        <p class="element-syntax"><a name=
        "element-non-matching-substring" id=
        "element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring&gt;<br />

        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:non-matching-substring&gt;</code></p>

        <p>The <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction takes as input a string (the result of
        evaluating the expression in the <code>select</code>
        attribute) and a regular expression (the effective value of
        the <code>regex</code> attribute).</p>

        <p>If the result of evaluating the <code>select</code>
        expression is not a string, it is converted to a string by
        applying the <a title="function conversion rules" href=
        "#dt-function-conversion-rules">function conversion
        rules</a>.</p>

        <p>The <code>flags</code> attribute may be used to control
        the interpretation of the regular expression. If the
        attribute is omitted, the effect is the same as supplying a
        zero-length string. This is interpreted in the same way as
        the <code>$flags</code> attribute of the functions <a href=
        "http://www.w3.org/TR/xpath-functions/#func-matches"><code>matches</code></a><sup>
        <small>FO</small></sup>, <a href=
        "http://www.w3.org/TR/xpath-functions/#func-replace"><code>replace</code></a><sup>
        <small>FO</small></sup>, and <a href=
        "http://www.w3.org/TR/xpath-functions/#func-tokenize"><code>
        tokenize</code></a><sup><small>FO</small></sup>.
        <span>Specifically, if it contains the letter
        <code>m</code>, the match operates in multiline mode. If it
        contains the letter <code>s</code>, it operates in dot-all
        mode. If it contains the letter <code>i</code>, it operates
        in case-insensitive mode. If it contains the letter
        <code>x</code>, then whitespace within the regular
        expression is ignored. For more detailed specifications of
        these modes, see <a href="#xpath-functions">[Functions and
        Operators]</a> (<a href=
        "http://www.w3.org/TR/xpath-functions/#flags">Section
        7.6.1.1 Flags</a><sup><small>FO</small></sup>).</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Because the <code>regex</code> attribute is an
          attribute value template, curly brackets within the
          regular expression must be doubled. For example, to match
          a sequence of one to five characters, write
          <code>regex=".{{1,5}}"</code>. <span>For regular
          expressions containing many curly brackets it may be more
          convenient to use a notation such as
          <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
          to use a variable.</span></p>
        </div>

        <p>The content of the <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction must take one of the following forms:</p>

        <ol class="enumar">
          <li>
            <p>A single <a href=
            "#element-matching-substring"><code>xsl:matching-substring</code></a>
            instruction, followed by zero or more <a href=
            "#element-fallback"><code>xsl:fallback</code></a>
            instructions</p>
          </li>

          <li>
            <p>A single <a href=
            "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
            instruction, followed by zero or more <a href=
            "#element-fallback"><code>xsl:fallback</code></a>
            instructions</p>
          </li>

          <li>
            <p>A single <a href=
            "#element-matching-substring"><code>xsl:matching-substring</code></a>
            instruction, followed by a single <a href=
            "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
            instruction, followed by zero or more <a href=
            "#element-fallback"><code>xsl:fallback</code></a>
            instructions</p>
          </li>
        </ol>

        <p><a name="err-XTSE1130" id="err-XTSE1130"><span class=
        "error">[ERR XTSE1130]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction contains neither an <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        nor an <a href=
        "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
        element.</p>

        <p><span>Any <a href=
        "#element-fallback"><code>xsl:fallback</code></a> elements
        among the children of the <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction</span> are ignored by an XSLT 2.0 processor,
        but allow fallback behavior to be defined when the
        stylesheet is used with an XSLT 1.0 processor operating in
        forwards-compatible mode.</p>

        <p>This instruction is designed to process all the
        non-overlapping substrings of the input string that match
        the regular expression supplied.</p>

        <p><a name="err-XTDE1140" id="err-XTDE1140"><span class=
        "error">[ERR XTDE1140]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>regex</code> attribute does not conform to the
        <span class="verb">required</span> syntax for regular
        expressions, as specified in <a href=
        "#xpath-functions">[Functions and Operators]</a>. If the
        regular expression is known statically (for example, if the
        attribute does not contain any <a title="expression" href=
        "#dt-expression">expressions</a> enclosed in curly
        brackets) then the processor <span class="verb">may</span>
        signal the error as a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <p><a name="err-XTDE1145" id="err-XTDE1145"><span class=
        "error">[ERR XTDE1145]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>flags</code> attribute has a value other than the
        values defined in <a href="#xpath-functions">[Functions and
        Operators]</a>. If the value of the attribute is known
        statically (for example, if the attribute does not contain
        any <a title="expression" href=
        "#dt-expression">expressions</a> enclosed in curly
        brackets) then the processor <span class="verb">may</span>
        signal the error as a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <p><a name="err-XTDE1150" id="err-XTDE1150"><span class=
        "error">[ERR XTDE1150]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>regex</code> attribute is a regular expression that
        matches a zero-length string: or more specifically, if the
        regular expression <code>$r</code> and flags
        <code>$f</code> are such that <code>matches("", $r,
        $f)</code> returns true. If the regular expression is known
        statically (for example, if the attribute does not contain
        any <a title="expression" href=
        "#dt-expression">expressions</a> enclosed in curly
        brackets) then the processor <span class="verb">may</span>
        signal the error as a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <p>The <a href=
        "#element-analyze-string"><code>xsl:analyze-string</code></a>
        instruction starts at the beginning of the input string and
        attempts to find the first substring that matches the
        regular expression. If there are several matches, the first
        match is defined to be the one whose starting position
        comes first in the string. If several alternatives within
        the regular expression both match at the same position in
        the input string, then the match that is chosen is the
        first alternative that matches. For example, if the input
        string is <code>The quick brown fox jumps</code> and the
        regular expression is <code>jump|jumps</code>, then the
        match that is chosen is <code>jump</code>.</p>

        <p>Having found the first match, the instruction proceeds
        to find the second and subsequent matches by repeating the
        search, starting at the first character that was not
        included in the previous match.</p>

        <p>The input string is thus partitioned into a sequence of
        substrings, some of which match the regular expression,
        others which do not match it. Each substring will contain
        at least one character. This sequence of substrings is
        processed using the <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        and <a href=
        "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
        child instructions. A matching substring is processed using
        the <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        element, a non-matching substring using the <a href=
        "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
        element. Each of these elements takes a sequence
        constructor as its content. If the element is absent, the
        effect is the same as if it were present with empty
        content. In processing each substring, the contents of the
        substring will be the <a title="context item" href=
        "#dt-context-item">context item</a> (as a value of type
        <code>xs:string</code>); the position of the substring
        within the sequence of matching and non-matching substrings
        will be the <a title="context position" href=
        "#dt-context-position">context position</a>; and the number
        of matching and non-matching substrings will be the
        <a title="context size" href="#dt-context-size">context
        size</a>.</p>

        <p>If the input is a zero-length string, the number of
        substrings will be zero, so neither the <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        nor <a href=
        "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
        elements will be evaluated.</p>
      </div>

      <div class="div2">
        <h3><a name="regex-group" id="regex-group"></a>15.2
        Captured Substrings</h3><a name="function-regex-group" id=
        "function-regex-group"></a>

        <div class="proto">
          <code class="function">regex-group</code>(<code class=
          "arg">$group-number</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:integer</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string</code>
        </div>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-current-captured-substrings" id=
        "dt-current-captured-substrings" title=
        "current captured substrings"></a>While the <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        instruction is active, a set of <b>current captured
        substrings</b> is available, corresponding to the
        parenthesized sub-expressions of the regular
        expression.<span class="definition">]</span> These captured
        substrings are accessible using the function <a href=
        "#function-regex-group"><code>regex-group</code></a>. This
        function takes an integer argument to identify the group,
        and returns a string representing the captured
        substring.</p>

        <p>The <var>N</var>th captured substring (where
        <var>N</var> &gt; 0) is the string matched by the
        subexpression contained by the <var>N</var>th left
        parenthesis in the regex. The zeroeth captured substring is
        the string that matches the entire regex. This means that
        the value of <code>regex-group(0)</code> is initially the
        same as the value of <code>.</code> (dot).</p>

        <p>The function returns the zero-length string if there is
        no captured substring with the relevant number. This can
        occur for a number of reasons:</p>

        <ol class="enumar">
          <li>
            <p>The number is negative.</p>
          </li>

          <li>
            <p>The regular expression does not contain a
            parenthesized sub-expression with the given number.</p>
          </li>

          <li>
            <p>The parenthesized sub-expression exists, and did not
            match any part of the input string.</p>
          </li>

          <li>
            <p>The parenthesized sub-expression exists, and matched
            a zero-length substring of the input string.</p>
          </li>
        </ol>

        <p>The set of captured substrings is a context variable
        with dynamic scope. It is initially an empty sequence.
        During the evaluation of an <a href=
        "#element-matching-substring"><code>xsl:matching-substring</code></a>
        instruction it is set to the sequence of matched substrings
        for that regex match. During the evaluation of an <a href=
        "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
        instruction or a <a title="pattern" href=
        "#dt-pattern">pattern</a> or a <a title=
        "stylesheet function" href=
        "#dt-stylesheet-function">stylesheet function</a> it is set
        to an empty sequence. On completion of an instruction that
        changes the value, the variable reverts to its previous
        value.</p>

        <p>The value of the <a title="current captured substrings"
        href="#dt-current-captured-substrings">current captured
        substrings</a> is unaffected through calls of <a href=
        "#element-apply-templates"><code>xsl:apply-templates</code></a>,
        <a href=
        "#element-call-template"><code>xsl:call-template</code></a>,
        <a href=
        "#element-apply-imports"><code>xsl:apply-imports</code></a>
        or <a href=
        "#element-next-match"><code>xsl:next-match</code></a>, or
        by expansion of named <a title="attribute set" href=
        "#dt-attribute-set">attribute sets</a>.</p>
      </div>

      <div class="div2">
        <h3><a name="regex-examples" id="regex-examples"></a>15.3
        Examples of Regular Expression Matching</h3>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21776" id="d5e21776"></a>Example: Replacing
            Characters by Elements
          </div>

          <p>Problem: replace all newline characters in the
          <code>abstract</code> element by empty <code>br</code>
          elements:</p>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;br/&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21791" id="d5e21791"></a>Example:
            Recognizing non-XML Markup Structure
          </div>

          <p>Problem: replace all occurrences of <code>[...]</code>
          in the <code>body</code> by <code>cite</code> elements,
          retaining the content between the square brackets as the
          content of the new element.</p>

          <p>Solution:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;&lt;xsl:value-of select="regex-group(1)"/&gt;&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;
    &lt;xsl:value-of select="."/&gt;
  &lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre>
          </div>

          <p>Note that this simple approach fails if the
          <code>body</code> element contains markup that needs to
          be retained. In this case it is necessary to apply the
          regular expression processing to each text node
          individually. If the <code>[...]</code> constructs span
          multiple text nodes (for example, because there are
          elements within the square brackets) then it probably
          becomes necessary to make two or more passes over the
          data.</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e21817" id="d5e21817"></a>Example: Parsing a
            Date
          </div>

          <p>Problem: the input string contains a date such as
          <code>23 March 2002</code>. Convert it to the form
          <code>2002-03-23</code>.</p>

          <p>Solution (with no error handling if the input format
          is incorrect):</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:variable name="months" select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;
</pre>
          </div>

          <p>Note the use of <code>normalize-space</code> to
          simplify the work done by the regular expression, and the
          use of doubled curly brackets because the
          <code>regex</code> attribute is an attribute value
          template.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="add-func" id="add-func"></a>16 Additional
      Functions</h2>

      <p>This section describes XSLT-specific additions to the
      <a title="core function" href="#dt-core-function">core
      function</a> library. Some of these additional functions also
      make use of information specified by <a title="declaration"
      href="#dt-declaration">declarations</a> in the stylesheet;
      this section also describes these declarations.</p>

      <div class="div2">
        <h3><a name="document" id="document"></a>16.1 Multiple
        Source Documents</h3><a name="function-document" id=
        "function-document"></a>

        <div class="proto">
          <code class="function">document</code>(<code class=
          "arg">$uri-sequence</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">item()*</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">node()*</code>
        </div>

        <div class="proto">
          <code class="function">document</code>(<code class=
          "arg">$uri-sequence</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">item()*</code>, <code class=
          "arg">$base-node</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">node()</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">node()*</code>
        </div>

        <p>The <a href=
        "#function-document"><code>document</code></a> function
        allows access to XML documents identified by a URI.</p>

        <p>The first argument contains a sequence of URI
        references. The second argument, if present, is a node
        whose base URI is used to resolve any relative URI
        references contained in the first argument.</p>

        <p>A sequence of absolute URI references is obtained as
        follows.</p>

        <ul>
          <li>
            <p>For an item in <code>$uri-sequence</code> that is an
            instance of <code>xs:string</code>,
            <code>xs:anyURI</code>, or
            <span><code>xs:untypedAtomic</code></span>, the value
            is cast to <code>xs:anyURI</code>. If the resulting URI
            reference is an absolute URI reference then it is used
            <em>as is</em>. If it is a relative URI reference, then
            it is resolved against the base URI of
            <code>$base-node</code> if supplied, or against the
            base URI from the static context otherwise (this will
            usually be the base URI of the stylesheet module). A
            relative URI is resolved against a base URI using the
            rules defined in <a href="#RFC3986">[RFC3986]</a>.</p>
          </li>

          <li>
            <p>For an item in <code>$uri-sequence</code> that is a
            node, the node is <a title="atomize" href=
            "#dt-atomization">atomized</a>. The result <span class=
            "verb">must</span> be a sequence whose items are all
            instances of <code>xs:string</code>,
            <code>xs:anyURI</code>, or
            <span><code>xs:untypedAtomic</code></span>. Each of
            these values is cast to <code>xs:anyURI</code>, and if
            the resulting URI reference is an absolute URI
            reference then it is used <em>as is</em>. If it is a
            relative URI reference, then it is resolved against the
            base URI of <code>$base-node</code> if supplied, or
            against the base URI of the node that contained it
            otherwise.</p>
          </li>
        </ul>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The XPath rules for function calling ensure that it is
          a type error if the supplied value of the second argument
          is anything other than a single node. If <a title=
          "XPath 1.0 compatibility mode" href=
          "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
          is enabled, then a sequence of nodes may be supplied, and
          the first node in the sequence will be used.</p>
        </div>

        <p>Each of these absolute URI references is then processed
        as follows. Any fragment identifier that is present in the
        URI reference is removed, and the resulting absolute URI is
        cast to a string and then passed to the <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup> function defined in <a href=
        "#xpath-functions">[Functions and Operators]</a>. This
        returns a document node. If an error occurs during
        evaluation of the <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup> function, the processor
        <span class="verb">may</span> either signal this error in
        the normal way, or <span class="verb">may</span> recover by
        ignoring the failure, in which case the failing URI will
        not contribute any nodes to the result of the <a href=
        "#function-document"><code>document</code></a>
        function.</p>

        <p>If the URI reference contained no fragment identifier,
        then this document node is included in the sequence of
        nodes returned by the <a href=
        "#function-document"><code>document</code></a>
        function.</p>

        <p>If the URI reference contained a fragment identifier,
        then the fragment identifier is interpreted according to
        the rules for the media type of the resource
        <span>representation</span> identified by the URI, and is
        used to select zero or more nodes that are
        descendant-or-self nodes of the returned document node. As
        described in <a href="#initiating"><i>2.3 Initiating a
        Transformation</i></a>, the media type is available as part
        of the evaluation context for a transformation.</p>

        <p><a name="err-XTRE1160" id="err-XTRE1160"><span class=
        "error">[ERR XTRE1160]</span></a> When a URI reference
        contains a fragment identifier, it is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> if
        the media type is not one that is recognized by the
        processor, or if the fragment identifier does not conform
        to the rules for fragment identifiers for that media type,
        or if the fragment identifier selects something other than
        a sequence of nodes (for example, if it selects a range of
        characters within a text node). The <a title=
        "optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is to ignore the fragment identifier and return the
        document node. The set of media types recognized by a
        processor is <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The recovery action here is different from XSLT
          1.0</p>
        </div>

        <p>The sequence of nodes returned by the function is in
        document order, with no duplicates. This order has no
        necessary relationship to the order in which URIs were
        supplied in the <code>$uri-sequence</code> argument.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>One effect of these rules is that unless XML entities
          or <code>xml:base</code> are used, and provided that the
          base URI of the stylesheet module is known,
          <code>document("")</code> refers to the document node of
          the containing stylesheet module (the definitive rules
          are in <span><a href="#RFC3986">[RFC3986]</a></span>).
          The XML resource containing the stylesheet module is
          processed exactly as if it were any other XML document,
          for example there is no special recognition of <a href=
          "#element-text"><code>xsl:text</code></a> elements, and
          no special treatment of comments and processing
          instructions.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="unparsed-text" id="unparsed-text"></a>16.2
        Reading Text Files</h3><a name="function-unparsed-text" id=
        "function-unparsed-text"></a>

        <div class="proto">
          <code class="function">unparsed-text</code>(<code class=
          "arg">$href</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string?</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string?</code>
        </div>

        <div class="proto">
          <code class="function">unparsed-text</code>(<code class=
          "arg">$href</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string?</code>, <code class=
          "arg">$encoding</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string?</code>
        </div>

        <p>The <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        function reads an external resource (for example, a file)
        and returns its contents as a string.</p>

        <p>The <code>$href</code> argument <span class=
        "verb">must</span> be <span>a string in the form of a
        URI</span>. The URI <span class="verb">must</span> contain
        no fragment identifier, and <span class="verb">must</span>
        identify a resource that can be read as text. If the URI is
        a relative URI, then it is resolved relative to the base
        URI from the static context.</p>

        <p>If the value of the <code>$href</code> argument is an
        empty sequence, the function returns an empty sequence.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>If a different base URI is appropriate (for example,
          when resolving a relative URI read from a source
          document) then the relative URI should be resolved using
          the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-resolve-uri"><code>
          resolve-uri</code></a><sup><small>FO</small></sup>
          function before passing it to the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function.</p>
        </div>

        <p>The <code>$encoding</code> argument, if present, is the
        name of an encoding. The values for this attribute follow
        the same rules as for the <code>encoding</code> attribute
        in an XML declaration. The only values which every
        <a title="implementation" href=
        "#dt-implementation">implementation</a> is <span class=
        "verb">required</span> to recognize are <code>utf-8</code>
        and <code>utf-16</code>.</p>

        <p>The encoding of the external resource is determined as
        follows:</p>

        <ol class="enumar">
          <li>
            <p>external encoding information is used if available,
            otherwise</p>
          </li>

          <li>
            <p>if the media type of the resource is
            <code>text/xml</code> or <code>application/xml</code>
            (see <a href="#RFC2376">[RFC2376]</a>), or if it
            matches the conventions <code>text/*+xml</code> or
            <code>application/*+xml</code> (see <a href=
            "#RFC3023">[RFC3023]</a> <span>and/or its
            successors</span>), then the encoding is recognized as
            specified in <a href="#REC-xml">[XML 1.0]</a>,
            otherwise</p>
          </li>

          <li>
            <p>the value of the <code>$encoding</code> argument is
            used if present, otherwise</p>
          </li>

          <li>
            <p>the processor <span class="verb">may</span> use
            <a title="implementation-defined" href=
            "#dt-implementation-defined">implementation-defined</a>
            heuristics to determine the likely encoding,
            otherwise</p>
          </li>

          <li>
            <p>UTF-8 is assumed.</p>
          </li>
        </ol>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The above rules are chosen for consistency with
          <a href="#xinclude">[XInclude]</a>. Files with an XML
          media type are treated specially because there are use
          cases for this function where the retrieved text is to be
          included as unparsed XML within a CDATA section of a
          containing document, and because processors are likely to
          be able to reuse the code that performs encoding
          detection for XML external entities.</p>
        </div>

        <p><a name="err-XTDE1170" id="err-XTDE1170"><span class=
        "error">[ERR XTDE1170]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if a URI <span>contains a fragment
        identifier,</span> or if it cannot be used to retrieve a
        resource containing text.</p>

        <p><a name="err-XTDE1190" id="err-XTDE1190"><span class=
        "error">[ERR XTDE1190]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if a resource contains octets that cannot be
        decoded into Unicode characters using the specified
        encoding, or if the resulting characters are not permitted
        XML characters. This includes the case where the <a title=
        "processor" href="#dt-processor">processor</a> does not
        support the requested encoding.</p>

        <p><a name="err-XTDE1200" id="err-XTDE1200"><span class=
        "error">[ERR XTDE1200]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the second argument of the <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        function is omitted and the <a title="processor" href=
        "#dt-processor">processor</a> cannot infer the encoding
        using external information and the encoding is not
        UTF-8.</p>

        <p>The result is a string containing the text of the
        resource retrieved using the URI.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>If the text file contains characters such as
          <code>&lt;</code> and <code>&amp;</code>, these will
          typically be output as <code>&amp;lt;</code> and
          <code>&amp;amp;</code> when the string is written to a
          <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a> and
          serialized as XML or HTML. If these characters actually
          represent markup (for example, if the text file contains
          HTML), then the stylesheet can attempt to write them as
          markup to the output file using the
          <code>disable-output-escaping</code> attribute of the
          <a href="#element-value-of"><code>xsl:value-of</code></a>
          instruction (see <a href=
          "#disable-output-escaping"><i>20.2 Disabling Output
          Escaping</i></a>). Note, however, that implementations
          are not required to support this feature.</p>
        </div>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e22242" id="d5e22242"></a>Example: Copying
            Unparsed HTML Boilerplate
          </div>

          <p>This example attempts to read an HTML file and copy
          it, as HTML, to the serialized output file:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:output method="html"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/&gt;
&lt;/xsl:template&gt;
</pre>
          </div>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e22249" id="d5e22249"></a>Example: Splitting
            an Input File into a Sequence of Lines
          </div>

          <p>Often it is necessary to split a text file into a
          sequence of lines, representing each line as a string.
          This can be achieved by using the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function in conjunction with the XPath <a href=
          "http://www.w3.org/TR/xpath-functions/#func-tokenize"><code>
          tokenize</code></a><sup><small>FO</small></sup> function.
          For example:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:for-each select="tokenize(unparsed-text($in), '\r?\n')"&gt;
 ...
&lt;/xsl:for-each&gt;
</pre>
          </div>

          <p>Note that the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function does not normalize line endings. This example
          has therefore been written to recognize both Unix and
          Windows conventions for end-of-line, namely a single
          newline (#x0A) character or a carriage return / line feed
          pair (#x0D #x0A).</p>
        </div>

        <p>Because errors in evaluating the <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        function are non-recoverable, two functions are provided to
        allow a stylesheet to determine whether a call with
        particular arguments would succeed:</p><a name=
        "function-unparsed-text-available" id=
        "function-unparsed-text-available"></a>

        <div class="proto">
          <code class=
          "function">unparsed-text-available</code>(<code class=
          "arg">$href</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string?</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:boolean</code>
        </div>

        <div class="proto">
          <table border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td valign="baseline" rowspan="2"><code class=
              "function">unparsed-text-available</code>(</td>

              <td valign="baseline"><code class=
              "arg">$href</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$encoding</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>)<code class=
              "as">&#160;as&#160;</code><code class=
              "return-type">xs:boolean</code></td>
            </tr>
          </table>
        </div>

        <p>The <a href=
        "#function-unparsed-text-available"><code>unparsed-text-available</code></a>
        function determines whether a call on the <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        function with identical arguments would <span>return a
        string</span>.</p>

        <p>If the first argument is an empty sequence, the function
        returns false. If the second argument is an empty sequence,
        the function behaves as if the second argument were
        omitted.</p>

        <p>In other cases, the function returns true if a call on
        <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        with the same arguments would succeed, and false if a call
        on <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        with the same arguments would fail with a non-recoverable
        dynamic error.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>This requires that the <a href=
          "#function-unparsed-text-available"><code>unparsed-text-available</code></a>
          function should actually attempt to read the resource
          identified by the URI, and check that it is correctly
          encoded and contains no characters that are invalid in
          XML. Implementations may avoid the cost of repeating
          these checks for example by caching the validated
          contents of the resource, to anticipate a subsequent call
          on the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function. Alternatively, implementations may be able to
          rewrite an expression such as <code>if
          (unparsed-text-available(A)) then unparsed-text(A) else
          ...</code> to generate a single call internally.</p>
        </div>

        <p>The functions <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        and <a href=
        "#function-unparsed-text-available"><code>unparsed-text-available</code></a>
        have the same requirement for stability as the functions
        <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
        <small>FO</small></sup> and <a href=
        "http://www.w3.org/TR/xpath-functions/#func-doc-available"><code>
        doc-available</code></a><sup><small>FO</small></sup>
        defined in <a href="#xpath-functions">[Functions and
        Operators]</a>. This means that unless the user has
        explicitly stated a requirement for a reduced level of
        stability, either of these functions if called twice with
        the same arguments during the course of a transformation
        <span class="verb">must</span> return the same results each
        time; moreover, the results of a call on <a href=
        "#function-unparsed-text-available"><code>unparsed-text-available</code></a>
        <span class="verb">must</span> be consistent with the
        results of a subsequent call on <a href=
        "#function-unparsed-text"><code>unparsed-text</code></a>
        with the same arguments.</p>
      </div>

      <div class="div2">
        <h3><a name="key" id="key"></a>16.3 Keys</h3>

        <p>Keys provide a way to work with documents that contain
        an implicit cross-reference structure. They make it easier
        to locate the nodes within a document that have a given
        value for a given attribute or child element, and they
        provide a hint to the implementation that certain access
        paths in the document need to be efficient.</p>

        <div class="div3">
          <h4><a name="xsl-key" id="xsl-key"></a>16.3.1 The
          <a href="#element-key"><code>xsl:key</code></a>
          Declaration</h4>

          <p class="element-syntax"><a name="element-key" id=
          "element-key"></a><code>&lt;!-- Category: declaration
          --&gt;<br />
          &lt;xsl:key<br />
          &#160;&#160;<b>name</b> = <var>qname</var><br />
          &#160;&#160;<b>match</b> = <var>pattern</var><br />
          &#160;&#160;use? = <var>expression</var><br />
          &#160;&#160;collation? = <var>uri</var>&gt;<br />
          &#160;&#160;&lt;!-- Content:
          <var>sequence-constructor</var> --&gt;<br />
          &lt;/xsl:key&gt;</code></p>

          <p>The <a href="#element-key"><code>xsl:key</code></a>
          <a title="declaration" href=
          "#dt-declaration">declaration</a> is used to declare
          <a title="key" href="#dt-key">keys</a>. The
          <code>name</code> attribute specifies the name of the
          key. The value of the <code>name</code> attribute is a
          <a title="QName" href="#dt-qname">QName</a>, which is
          expanded as described in <a href="#qname"><i>5.1
          Qualified Names</i></a>. The <code>match</code> attribute
          is a <a href="#NT-Pattern">Pattern</a>; an <a href=
          "#element-key"><code>xsl:key</code></a> element applies
          to all nodes that match the pattern specified in the
          <code>match</code> attribute.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name="dt-key"
          id="dt-key" title="key"></a>A <b>key</b> is defined as a
          set of <a href="#element-key"><code>xsl:key</code></a>
          declarations in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that share the same
          name.<span class="definition">]</span></p>

          <p>The value of the key may be specified either using the
          <code>use</code> attribute or by means of the contained
          <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>.</p>

          <p><a name="err-XTSE1205" id="err-XTSE1205"><span class=
          "error">[ERR XTSE1205]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if an <a href="#element-key"><code>xsl:key</code></a>
          declaration has a <code>use</code> attribute and has
          non-empty content, or if it has empty content and no
          <code>use</code> attribute.</p>

          <p>If the <code>use</code> attribute is present, its
          value is an <a title="expression" href=
          "#dt-expression">expression</a> specifying the values of
          the key. The expression will be evaluated with the node
          that matches the pattern as the context node. The result
          of evaluating the expression is <a title="atomize" href=
          "#dt-atomization">atomized</a>.</p>

          <p>Similarly, if a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> is
          present, it is used to determine the values of the key.
          The sequence constructor will be evaluated with the node
          that matches the pattern as the context node. <span>The
          result of evaluating the sequence constructor is
          <a title="atomize" href=
          "#dt-atomization">atomized</a>.</span></p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-key-specifier" id="dt-key-specifier" title=
          "key specifier"></a>The expression in the
          <code>use</code> attribute and the <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>
          within an <a href="#element-key"><code>xsl:key</code></a>
          declaration are referred to collectively as the <b>key
          specifier</b>. The key specifier determines the values
          that may be used to find a node using this <a title="key"
          href="#dt-key">key</a>.<span class=
          "definition">]</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>There is no requirement that all the values of a key
            should have the same type.</p>
          </div>

          <p>The presence of an <a href=
          "#element-key"><code>xsl:key</code></a> declaration makes
          it easy to find a node that matches the
          <code>match</code> pattern if any of the values of the
          <span><a title="key specifier" href=
          "#dt-key-specifier">key specifier</a></span> (when
          applied to that node) are known. It also provides a hint
          to the implementation that access to the nodes by means
          of these values needs to be efficient (many
          implementations are likely to construct an index or hash
          table to achieve this). Note that the <span><a title=
          "key specifier" href="#dt-key-specifier">key
          specifier</a></span> in general returns a sequence of
          values, and any one of these may be used to locate the
          node.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>An <a href="#element-key"><code>xsl:key</code></a>
            declaration is not bound to a specific source document.
            The source document to which it applies is determined
            only when the <a href=
            "#function-key"><code>key</code></a> function is used
            to locate nodes using the key. Keys can be used to
            locate nodes within any source document (including
            temporary trees), but each use of the <a href=
            "#function-key"><code>key</code></a> function searches
            one document only.</p>
          </div>

          <p>The optional <code>collation</code> attribute is used
          only when deciding whether two strings are equal for the
          purposes of key matching. Specifically, two values
          <code>$a</code> and <code>$b</code> are considered equal
          if the result of the function call <code>compare($a, $b,
          $collation)</code> is zero. The effective collation for
          an <a href="#element-key"><code>xsl:key</code></a>
          declaration is the collation specified in its
          <code>collation</code> attribute if present,
          <span>resolved against the base URI of the <a href=
          "#element-key"><code>xsl:key</code></a> element</span>,
          or the <a title="default collation" href=
          "#dt-default-collation">default collation</a> that is in
          scope for the <a href=
          "#element-key"><code>xsl:key</code></a> declaration
          otherwise; the effective collation must be the same for
          all the <a href="#element-key"><code>xsl:key</code></a>
          declarations making up a <a title="key" href=
          "#dt-key">key</a>.</p>

          <p><a name="err-XTSE1210" id="err-XTSE1210"><span class=
          "error">[ERR XTSE1210]</span></a> It is a static error if
          the <a href="#element-key"><code>xsl:key</code></a>
          declaration has a <code>collation</code> attribute whose
          value <span>(after resolving against the base URI)</span>
          is not a URI recognized by the implementation as
          referring to a collation.</p>

          <p><a name="err-XTSE1220" id="err-XTSE1220"><span class=
          "error">[ERR XTSE1220]</span></a> It is a static error if
          there are several <a href=
          "#element-key"><code>xsl:key</code></a> declarations in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> with the same key name
          and different effective collations. Two collations are
          the same if their URIs are equal under the rules for
          comparing <code>xs:anyURI</code> values, or if the
          implementation can determine that they are different URIs
          referring to the same collation.</p>

          <p>It is possible to have:</p>

          <ul>
            <li>
              <p>multiple <a href=
              "#element-key"><code>xsl:key</code></a> declarations
              with the same name;</p>
            </li>

            <li>
              <p>a node that matches the <code>match</code>
              patterns of several different <a href=
              "#element-key"><code>xsl:key</code></a>
              declarations<span>, whether these have the same key
              name or different key names;</span></p>
            </li>

            <li>
              <p>a node that returns more than one value from its
              <span><a title="key specifier" href=
              "#dt-key-specifier">key specifier</a></span>;</p>
            </li>

            <li>
              <p>a key value that identifies more than one node
              (the key values for different nodes do not need to be
              unique).</p>
            </li>
          </ul>

          <p>An <a href="#element-key"><code>xsl:key</code></a>
          declaration with higher <a title="import precedence"
          href="#dt-import-precedence">import precedence</a> does
          not override another of lower import precedence; all the
          <a href="#element-key"><code>xsl:key</code></a>
          declarations in the stylesheet are effective regardless
          of their import precedence.</p>
        </div>

        <div class="div3">
          <h4><a name="keys" id="keys"></a>16.3.2 The <a href=
          "#function-key"><code>key</code></a>
          Function</h4><a name="function-key" id=
          "function-key"></a>

          <div class="proto">
            <code class="function">key</code>(<code class=
            "arg">$key-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>, <code class=
            "arg">$key-value</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:anyAtomicType*</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">node()*</code>
          </div>

          <div class="proto">
            <table border="0" cellpadding="0" cellspacing="0">
              <tr>
                <td valign="baseline" rowspan="3"><code class=
                "function">key</code>(</td>

                <td valign="baseline"><code class=
                "arg">$key-name</code></td>

                <td valign="baseline"><code class=
                "as">&#160;as&#160;</code><code class=
                "type">xs:string</code>,</td>
              </tr>

              <tr>
                <td valign="baseline"><code class=
                "arg">$key-value</code></td>

                <td valign="baseline"><code class=
                "as">&#160;as&#160;</code><code class=
                "type">xs:anyAtomicType*</code>,</td>
              </tr>

              <tr>
                <td valign="baseline"><code class=
                "arg">$top</code></td>

                <td valign="baseline"><code class=
                "as">&#160;as&#160;</code><code class=
                "type">node()</code>)<code class=
                "as">&#160;as&#160;</code><code class=
                "return-type">node()*</code></td>
              </tr>
            </table>
          </div>

          <p>The <a href="#function-key"><code>key</code></a>
          function does for keys what the <a href=
          "http://www.w3.org/TR/xpath-functions/#func-id"><code>id</code></a><sup>
          <small>FO</small></sup> function does for IDs.</p>

          <p>The <code>$key-name</code> argument specifies the name
          of the <a title="key" href="#dt-key">key</a>. The value
          of the argument <span class="verb">must</span> be a
          <a title="lexical QName" href="#dt-lexical-qname">lexical
          QName</a>, which is expanded as described in <a href=
          "#qname"><i>5.1 Qualified Names</i></a>.</p>

          <p><a name="err-XTDE1260" id="err-XTDE1260"><span class=
          "error">[ERR XTDE1260]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the value is not a valid QName, or if there
          is no namespace declaration in scope for the prefix of
          the QName, or if the name obtained by expanding the QName
          is not the same as the expanded name of any <a href=
          "#element-key"><code>xsl:key</code></a> declaration in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>. If the processor is able
          to detect the error statically (for example, when the
          argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>

          <p>The <code>$key-value</code> argument to the <a href=
          "#function-key"><code>key</code></a> function is
          considered as a sequence. The set of requested key values
          is formed by atomizing the supplied value of the
          argument, using the standard <a title=
          "function conversion rules" href=
          "#dt-function-conversion-rules">function conversion
          rules</a>. Each of the resulting atomic values is
          considered as a requested key value. The result of the
          function is a sequence of nodes, in document order and
          with duplicates removed, comprising those nodes in the
          selected <span>subtree</span> (see below) that are
          matched by an <a href=
          "#element-key"><code>xsl:key</code></a> declaration whose
          name is the same as the supplied key name, where the
          result of evaluating the <a title="key specifier" href=
          "#dt-key-specifier">key specifier</a> contains a value
          that is equal to one of these requested key values, under
          the rules appropriate to the XPath <code>eq</code>
          operator for the two values in question, using the
          <code>collation</code> attributes of the <a href=
          "#element-key"><code>xsl:key</code></a> declaration when
          comparing strings. No error is reported if two values are
          encountered that are not comparable; they are regarded
          for the purposes of this function as being not equal.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Under the rules for the <code>eq</code> operator,
            untyped atomic values are converted to strings, not to
            the type of the other operand. This means, for example,
            that if the expression in the <code>use</code>
            attribute returns a date, supplying an untyped atomic
            value in the call to the <a href=
            "#function-key"><code>key</code></a> function will
            return an empty sequence.</p>
          </div>

          <p>If the second argument is an empty sequence, the
          result of the function will be an empty sequence.</p>

          <p>Different rules apply when <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards
          compatible</a> behavior is enabled. Specifically, if any
          of the <a href="#element-key"><code>xsl:key</code></a>
          elements in the definition of the <a title="key" href=
          "#dt-key">key</a> enables backwards compatible behavior,
          then the value of the <a title="key specifier" href=
          "#dt-key-specifier">key specifier</a> and the value of
          the second argument of the <a href=
          "#function-key"><code>key</code></a> function are both
          converted after atomization to a sequence of strings, by
          applying a cast to each item in the sequence, before
          performing the comparison.</p>

          <p>The third argument is used to identify the selected
          subtree. If the argument is present, the selected subtree
          is the set of nodes that have <var>$top</var> as an
          ancestor-or-self node. If the argument is omitted, the
          selected subtree is the document containing the context
          node. This means that the third argument effectively
          defaults to <code>/</code>.</p>

          <p><a name="err-XTDE1270" id="err-XTDE1270"><span class=
          "error">[ERR XTDE1270]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> to call the <a href=
          "#function-key"><code>key</code></a> function with two
          arguments if there is no <a title="context node" href=
          "#dt-context-node">context node</a>, <span>or if the root
          of the tree containing the context node is not a document
          node</span>; or to call the function with three arguments
          if the root of the tree containing the node supplied in
          the third argument is not a document node.</p>

          <p>The result of the <a href=
          "#function-key"><code>key</code></a> function can be
          described more specifically as follows. The result is a
          sequence containing every node <var>$N</var> that
          satisfies the following conditions:</p>

          <ul>
            <li>
              <p><code>$N/ancestor-or-self::node() intersect
              $top</code> is non-empty. (If the third argument is
              omitted, <code>$top</code> defaults to
              <code>/</code>)</p>
            </li>

            <li>
              <p><var>$N</var> matches the pattern specified in the
              <code>match</code> attribute of an <a href=
              "#element-key"><code>xsl:key</code></a> declaration
              whose <code>name</code> attribute matches the name
              specified in the <code>$key-name</code> argument.</p>
            </li>

            <li>
              <p>When the <a title="key specifier" href=
              "#dt-key-specifier">key specifier</a> of that
              <a href="#element-key"><code>xsl:key</code></a>
              declaration is evaluated with a <a title=
              "singleton focus" href=
              "#dt-singleton-focus">singleton focus</a> based on
              <var>$N</var>, the <a title="atomize" href=
              "#dt-atomization">atomized</a> value of the resulting
              sequence includes a value that compares equal to at
              least one item in the atomized value of the sequence
              supplied as <code>$key-value</code>, under the rules
              of the <code>eq</code> operator with the collation
              selected as described above.</p>
            </li>
          </ul>

          <p>The sequence returned by the <a href=
          "#function-key"><code>key</code></a> function will be in
          document order, with duplicates (that is, nodes having
          the same identity) removed.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e22835" id="d5e22835"></a>Example: Using a
              Key to Follow Cross-References
            </div>

            <p>For example, given a declaration</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:key name="idkey" match="div" use="@id"/&gt;
</pre>
            </div>

            <p>an expression <code>key("idkey",@ref)</code> will
            return the same nodes as <code>id(@ref)</code>,
            assuming that the only ID attribute declared in the XML
            source document is:</p>

            <div class="exampleInner">
              <pre>
&lt;!ATTLIST div id ID #IMPLIED&gt;
</pre>
            </div>

            <p>and that the <code>ref</code> attribute of the
            context node contains no whitespace.</p>

            <p>Suppose a document describing a function library
            uses a <code>prototype</code> element to define
            functions</p>

            <div class="exampleInner">
              <pre>
&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;
</pre>
            </div>

            <p>and a <code>function</code> element to refer to
            function names</p>

            <div class="exampleInner">
              <pre>
&lt;function&gt;sqrt&lt;/function&gt;
</pre>
            </div>

            <p>Then the stylesheet could generate hyperlinks
            between the references and definitions as follows:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;
</pre>
            </div>
          </div>

          <p>When called with two arguments, the <a href=
          "#function-key"><code>key</code></a> function always
          returns nodes that are in the same document as the
          context node. To retrieve a node from any other document,
          it is necessary either to change the context node, or to
          supply a third argument.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e22881" id="d5e22881"></a>Example: Using
              Keys to Reference other Documents
            </div>

            <p>For example, suppose a document contains
            bibliographic references in the form
            <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and
            there is a separate XML document <code>bib.xml</code>
            containing a bibliographic database with entries in the
            form:</p>

            <div class="exampleInner">
              <pre>
&lt;entry name="XSLT"&gt;...&lt;/entry&gt;
</pre>
            </div>

            <p>Then the stylesheet could use the following to
            transform the <code>bibref</code> elements:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib',$name)"/&gt;
&lt;/xsl:template&gt;
</pre>
            </div>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>This relies on the ability in XPath 2.0 to have a
              function call on the right-hand side of the
              <code>/</code> operator in a path expression.</p>
            </div>

            <p>The following code would also work:</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;
</pre>
            </div>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="format-number" id="format-number"></a>16.4
        Number Formatting</h3><a name="function-format-number" id=
        "function-format-number"></a>

        <div class="proto">
          <code class="function">format-number</code>(<code class=
          "arg">$value</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">numeric?</code>, <code class=
          "arg">$picture</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string</code>
        </div>

        <div class="proto">
          <table border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td valign="baseline" rowspan="3"><code class=
              "function">format-number</code>(</td>

              <td valign="baseline"><code class=
              "arg">$value</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">numeric?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$picture</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$decimal-format-name</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string</code>)<code class=
              "as">&#160;as&#160;</code><code class=
              "return-type">xs:string</code></td>
            </tr>
          </table>
        </div>

        <p>The <a href=
        "#function-format-number"><code>format-number</code></a>
        function formats <code>$value</code> as a string using the
        <a title="picture string" href="#dt-picture-string">picture
        string</a> specified by the <code>$picture</code> argument
        and the decimal-format named by the
        <code>$decimal-format-name</code> argument, or the default
        decimal-format, if there is no
        <code>$decimal-format-name</code> argument. <span>The
        syntax of the picture string is described in <a href=
        "#processing-picture-string"><i>16.4.2 Processing the
        Picture String</i></a>.</span></p>

        <p>The <code>$value</code> argument may be of any numeric
        data type (<code>xs:double</code>, <code>xs:float</code>,
        <code>xs:decimal</code>, or their subtypes including
        <code>xs:integer</code>). Note that if an
        <code>xs:decimal</code> is supplied, it is not
        automatically promoted to an <code>xs:double</code>, as
        such promotion can involve a loss of precision.</p>

        <p>If the supplied value of the <code>$value</code>
        argument is an empty sequence, the function behaves as if
        the supplied value were the <code>xs:double</code> value
        <code>NaN</code>.</p>

        <p>The value of <code>$decimal-format-name</code>
        <span class="verb">must</span> be a <a title=
        "lexical QName" href="#dt-lexical-qname">lexical QName</a>,
        which is expanded as described in <a href="#qname"><i>5.1
        Qualified Names</i></a>. The result of the function is the
        formatted string representation of the supplied number.</p>

        <p><a name="err-XTDE1280" id="err-XTDE1280"><span class=
        "error">[ERR XTDE1280]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the name specified as the
        <code>$decimal-format-name</code> argument <span>is not a
        valid <a title="QName" href="#dt-qname">QName</a>, or if
        its prefix has not been declared in an in-scope namespace
        declaration</span>, or if the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> does not contain a
        declaration of a decimal-format with a matching <a title=
        "expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a>. If the processor
        is able to detect the error statically (for example, when
        the argument is supplied as a string literal), then the
        processor <span class="verb">may</span> optionally signal
        this as a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <div class="div3">
          <h4><a name="defining-decimal-format" id=
          "defining-decimal-format"></a>16.4.1 Defining a Decimal
          Format</h4>

          <p class="element-syntax"><a name=
          "element-decimal-format" id=
          "element-decimal-format"></a><code>&lt;!-- Category:
          declaration --&gt;<br />
          &lt;xsl:decimal-format<br />
          &#160;&#160;name? = <var>qname</var><br />
          &#160;&#160;decimal-separator? = <var>char</var><br />
          &#160;&#160;grouping-separator? = <var>char</var><br />
          &#160;&#160;infinity? = <var>string</var><br />
          &#160;&#160;minus-sign? = <var>char</var><br />
          &#160;&#160;NaN? = <var>string</var><br />
          &#160;&#160;percent? = <var>char</var><br />
          &#160;&#160;per-mille? = <var>char</var><br />
          &#160;&#160;zero-digit? = <var>char</var><br />
          &#160;&#160;digit? = <var>char</var><br />
          &#160;&#160;pattern-separator? =
          <var>char</var>&#160;/&gt;</code></p>

          <p>The <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          element controls the interpretation of a <a title=
          "picture string" href="#dt-picture-string">picture
          string</a> used by the <a href=
          "#function-format-number"><code>format-number</code></a>
          function.</p>

          <p>A <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> may contain multiple
          <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations and may include or import <a title=
          "stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a> that also
          contain <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations. The name of an <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration is the value of its <code>name</code>
          attribute, if any.</p>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-decimal-format" id="dt-decimal-format" title=
          "decimal format"></a>All the <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations in a stylesheet that share the same name are
          grouped into a named <b>decimal format</b>; those that
          have no name are grouped into a single unnamed decimal
          format.<span class="definition">]</span></p>

          <p>If a <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> does not contain a
          declaration of the unnamed decimal format, a declaration
          equivalent to an <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          element with no attributes is implied.</p>

          <p>The attributes of the <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration establish values for a number of variables
          used as input to the algorithm followed by the <a href=
          "#function-format-number"><code>format-number</code></a>
          function. An outline of the purpose of each attribute is
          given below; however, the definitive explanations are
          given later, as part of the description of this
          algorithm.</p>

          <p>For any named <a title="decimal format" href=
          "#dt-decimal-format">decimal format</a>, the effective
          value of each attribute is taken from an <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration that has that name, and that specifies an
          explicit value for the required attribute. If there is no
          such declaration, the default value of the attribute is
          used. If there is more than one such declaration, the one
          with highest <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a> is
          used.</p>

          <p>For any unnamed <a title="decimal format" href=
          "#dt-decimal-format">decimal format</a>, the effective
          value of each attribute is taken from an <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration that is unnamed, and that specifies an
          explicit value for the required attribute. If there is no
          such declaration, the default value of the attribute is
          used. If there is more than one such declaration, the one
          with highest <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a> is
          used.</p>

          <p><a name="err-XTSE1290" id="err-XTSE1290"><span class=
          "error">[ERR XTSE1290]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if a named or unnamed <a title="decimal format" href=
          "#dt-decimal-format">decimal format</a> contains two
          conflicting values for the same attribute in different
          <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations having the same <a title="import precedence"
          href="#dt-import-precedence">import precedence</a>,
          unless there is another definition of the same attribute
          with higher import precedence.</p>

          <p>The following attributes control the interpretation of
          characters in the <a title="picture string" href=
          "#dt-picture-string">picture string</a> supplied to the
          <a href=
          "#function-format-number"><code>format-number</code></a>
          function, and also specify characters that may appear in
          the result of formatting the number. In each case the
          value <span class="verb">must</span> be a single
          character <span><span class="error">[see <a href=
          "#err-XTSE0020">ERR XTSE0020</a>]</span></span>.</p>

          <ul>
            <li>
              <p><code>decimal-separator</code> specifies the
              character used for the
              <var>decimal-separator-sign</var>; the default value
              is the period character (<code>.</code>)</p>
            </li>

            <li>
              <p><code>grouping-separator</code> specifies the
              character used for the <var>grouping-sign</var>,
              which is typically used as a thousands separator; the
              default value is the comma character
              (<code>,</code>)</p>
            </li>

            <li>
              <p><code>percent</code> specifies the character used
              for the <var>percent-sign</var>; the default value is
              the percent character (<code>%</code>)</p>
            </li>

            <li>
              <p><code>per-mille</code> specifies the character
              used for the <var>per-mille-sign</var>; the default
              value is the Unicode per-mille character (#x2030)</p>
            </li>

            <li>
              <p><code>zero-digit</code> specifies the character
              used for the <var>digit-zero-sign</var>; the default
              value is the digit zero (<code>0</code>). This
              character <span class="verb">must</span> be a digit
              (category Nd in the Unicode property database), and
              it <span class="verb">must</span> have the numeric
              value zero. <span>This attribute implicitly defines
              the Unicode character that is used to represent each
              of the values 0 to 9 in the final result string:
              Unicode is organized so that each set of decimal
              digits forms a contiguous block of characters in
              numerical sequence.</span></p>
            </li>
          </ul>

          <p><a name="err-XTSE1295" id="err-XTSE1295"><span class=
          "error">[ERR XTSE1295]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the character specified in the <code>zero-digit</code>
          attribute is not a digit or is a digit that does not have
          the numeric value zero.</p>

          <p>The following attributes control the interpretation of
          characters in the <a title="picture string" href=
          "#dt-picture-string">picture string</a> supplied to the
          <a href=
          "#function-format-number"><code>format-number</code></a>
          function. In each case the value <span class=
          "verb">must</span> be a single character
          <span><span class="error">[see <a href=
          "#err-XTSE0020">ERR XTSE0020</a>]</span></span>.</p>

          <ul>
            <li>
              <p><code>digit</code> specifies the character used
              for the <var>digit-sign</var> in the <a title=
              "picture string" href="#dt-picture-string">picture
              string</a>; the default value is the number sign
              character (<code>#</code>)</p>
            </li>

            <li>
              <p><code>pattern-separator</code> specifies the
              character used for the
              <var>pattern-separator-sign</var>, which separates
              positive and negative sub-pictures in a <a title=
              "picture string" href="#dt-picture-string">picture
              string</a>; the default value is the semi-colon
              character (<code>;</code>)</p>
            </li>
          </ul>

          <p>The following attributes specify characters or strings
          that may appear in the result of formatting the
          number:</p>

          <ul>
            <li>
              <p><code>infinity</code> specifies the string used
              for the <var>infinity-symbol</var>; the default value
              is the string <code>Infinity</code></p>
            </li>

            <li>
              <p><code>NaN</code> specifies the string used for the
              <var>NaN-symbol</var>, which is used to represent the
              value NaN (not-a-number); the default value is the
              string <code>NaN</code></p>
            </li>

            <li>
              <p><code>minus-sign</code> specifies the character
              used for the <var>minus-symbol</var>; the default
              value is the hyphen-minus character (<code>-</code>,
              #x2D). The value <span class="verb">must</span> be a
              single character.</p>
            </li>
          </ul>

          <p><a name="err-XTSE1300" id="err-XTSE1300"><span class=
          "error">[ERR XTSE1300]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if, for any named or unnamed decimal format, the
          variables representing characters used in a <a title=
          "picture string" href="#dt-picture-string">picture
          string</a> do not each have distinct values. These
          variables are <var>decimal-separator-sign</var>,
          <var>grouping-sign</var>, <var>percent-sign</var>,
          <var>per-mille-sign</var>, <var>digit-zero-sign</var>,
          <var>digit-sign</var>, and
          <var>pattern-separator-sign</var>.</p>
        </div>

        <div class="div3">
          <h4><a name="processing-picture-string" id=
          "processing-picture-string"></a>16.4.2 Processing the
          Picture String</h4>

          <p><span class=
          "definition">[Definition:&#160;</span><a name=
          "dt-picture-string" id="dt-picture-string" title=
          "picture string"></a>The formatting of a number is
          controlled by a <b>picture string</b>. The picture string
          is a sequence of characters, in which the characters
          assigned to the variables
          <var>decimal-separator-sign</var>,
          <var>grouping-sign</var>, <var>zero-digit-sign</var>,
          <var>digit-sign</var> and
          <var>pattern-separator-sign</var> are classified as
          active characters, and all other characters (including
          the <var>percent-sign</var> and
          <var>per-mille-sign</var>) are classified as passive
          characters.<span class="definition">]</span></p>

          <p>The <var>integer part</var> of the sub-picture is
          defined as the part that appears to the left of the
          <var>decimal-separator-sign</var> if there is one, or the
          entire sub-picture otherwise. The <var>fractional
          part</var> of the sub-picture is defined as the part that
          appears to the right of the
          <var>decimal-separator-sign</var> if there is one; it is
          a zero-length string otherwise.</p>

          <p><a name="err-XTDE1310" id="err-XTDE1310"><span class=
          "error">[ERR XTDE1310]</span></a> The <a title=
          "picture string" href="#dt-picture-string">picture
          string</a> <span class="verb">must</span> conform to the
          following rules. It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the picture string does not satisfy these
          rules.</p>

          <p>Note that in these rules the words "preceded" and
          "followed" refer to characters anywhere in the string,
          they are not to be read as "immediately preceded" and
          "immediately followed".</p>

          <ul>
            <li>
              <p>A picture-string consists either of a sub-picture,
              or of two sub-pictures separated by a
              <var>pattern-separator-sign</var>. A picture-string
              <span class="verb">must not</span> contain more than
              one <var>pattern-separator-sign</var>. If the
              picture-string contains two sub-pictures, the first
              is used for positive values and the second for
              negative values.</p>
            </li>

            <li>
              <p>A sub-picture <span class="verb">must not</span>
              contain more than one
              <var>decimal-separator-sign</var>.</p>
            </li>

            <li>
              <p>A sub-picture <span class="verb">must not</span>
              contain more than one <var>percent-sign</var> or
              <var>per-mille-sign</var>, and it <span class=
              "verb">must not</span> contain one of each.</p>
            </li>

            <li>
              <p>A sub-picture <span class="verb">must</span>
              contain at least one <var>digit-sign</var> or
              <var>zero-digit-sign</var>.</p>
            </li>

            <li>
              <p>A sub-picture <span class="verb">must not</span>
              contain a passive character that is preceded by an
              active character and that is followed by another
              active character.</p>
            </li>

            <li>
              <p>A sub-picture <span class="verb">must not</span>
              contain a <var>grouping-separator-sign</var> adjacent
              to a <var>decimal-separator-sign</var>.</p>
            </li>

            <li>
              <p>The integer part of a sub-picture <span class=
              "verb">must not</span> contain a
              <var>zero-digit-sign</var> that is followed by a
              <var>digit-sign</var>. The fractional part of a
              sub-picture <span class="verb">must not</span>
              contain a <var>digit-sign</var> that is followed by a
              <var>zero-digit-sign</var>.</p>
            </li>
          </ul>

          <p>The evaluation of the <a href=
          "#function-format-number"><code>format-number</code></a>
          function is described below in two phases, an analysis
          phase and a formatting phase. The analysis phase takes as
          its inputs the <a title="picture string" href=
          "#dt-picture-string">picture string</a> and the variables
          derived from the relevant <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration, and produces as its output a number of
          variables with defined values. The formatting phase takes
          as its inputs the number to be formatted and the
          variables produced by the analysis phase, and produces as
          its output a string containing a formatted representation
          of the number.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Numbers will always be formatted with the most
            significant digit on the left.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="analysing-picture-string" id=
          "analysing-picture-string"></a>16.4.3 Analysing the
          Picture String</h4>

          <p>This phase of the algorithm analyses the <a title=
          "picture string" href="#dt-picture-string">picture
          string</a> and the attribute settings of the <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration, and has the effect of setting the values of
          various variables, which are used in the subsequent
          formatting phase. These variables are listed below. Each
          is shown with its initial setting and its data type.</p>

          <p>Several variables are associated with each
          sub-picture. If there are two sub-pictures, then these
          rules are applied to one sub-picture to obtain the values
          that apply to positive numbers, and to the other to
          obtain the values that apply to negative numbers. If
          there is only one sub-picture, then the values for both
          cases are derived from this sub-picture.</p>

          <p>The variables are as follows:</p>

          <ul>
            <li>
              <p>The <var>integer-part-grouping-positions</var> is
              a sequence of integers representing the positions of
              grouping separators within the integer part of the
              sub-picture. For each
              <var>grouping-separator-sign</var> that appears
              within the integer part of the sub-picture, this
              sequence contains an integer that is equal to the
              total number of <var>digit-sign</var> and
              <var>zero-digit-sign</var> characters that appear
              within the integer part of the sub-picture and to the
              right of the <var>grouping-separator-sign</var>. In
              addition, if these
              <var>integer-part-grouping-positions</var> are at
              regular intervals (that is, if they <span>form a
              sequence <var>N</var>, <var>2N</var>, <var>3N</var>,
              ... for some integer value <var>N</var>,</span>
              including the case where there is only one number in
              the list), then the sequence contains all integer
              multiples of <var>N</var> as far as necessary to
              accommodate the largest possible number.</p>
            </li>

            <li>
              <p>The <var>minimum-integer-part-size</var> is an
              integer indicating the minimum number of digits that
              will appear to the left of the
              <var>decimal-separator-sign</var>. It is normally set
              to the number of <var>zero-digit-sign</var>
              characters found in the integer part of the
              sub-picture. But if the sub-picture contains no
              <var>zero-digit-sign</var> and no
              <var>decimal-separator-sign</var>, it is set to
              one.</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>There is no maximum integer part size. All
                significant digits in the integer part of the
                number will be displayed, even if this exceeds the
                number of <var>digit-sign</var> and
                <var>zero-digit-sign</var> characters in the
                subpicture.</p>
              </div>
            </li>

            <li>
              <p>The <var>prefix</var> is set to contain all
              passive characters in the sub-picture to the left of
              the leftmost active character. <span>If the picture
              string contains only one sub-picture</span>, the
              <var>prefix</var> for the negative sub-picture is set
              by concatenating the <var>minus-sign</var> character
              and the <var>prefix</var> for the positive
              sub-picture (if any), in that order.</p>
            </li>

            <li>
              <p>The <var>fractional-part-grouping-positions</var>
              is a sequence of integers representing the positions
              of grouping separators within the fractional part of
              the sub-picture. For each
              <var>grouping-separator-sign</var> that appears
              within the fractional part of the sub-picture, this
              sequence contains an integer that is equal to the
              total number of <var>digit-sign</var> and
              <var>zero-digit-sign</var> characters that appear
              within the fractional part of the sub-picture and to
              the left of the
              <var>grouping-separator-sign</var>.</p>
            </li>

            <li>
              <p>The <var>minimum-fractional-part-size</var> is set
              to the number of <var>zero-digit-sign</var>
              characters found in the fractional part of the
              sub-picture.</p>
            </li>

            <li>
              <p>The <var>maximum-fractional-part-size</var> is set
              to the total number of <var>digit-sign</var> and
              <var>zero-digit-sign</var> characters found in the
              fractional part of the sub-picture.</p>
            </li>

            <li>
              <p>The <var>suffix</var> is set to contain all
              passive characters to the right of the rightmost
              active character in the fractional part of the
              sub-picture.</p>
            </li>
          </ul>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>If there is only one sub-picture, then all variables
            for positive numbers and negative numbers will be the
            same, except for <var>prefix</var>: the prefix for
            negative numbers will <span>be preceded by the
            <var>minus-sign</var> character</span>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="formatting-the-number" id=
          "formatting-the-number"></a>16.4.4 Formatting the
          Number</h4>

          <p>This section describes the second phase of processing
          of the <a href=
          "#function-format-number"><code>format-number</code></a>
          function. This phase takes as input a number to be
          formatted (referred to as the <em>input number</em>), and
          the variables set up by analysing the <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declaration and the <a title="picture string" href=
          "#dt-picture-string">picture string</a>, as described
          above. The result of this phase is a string, which forms
          the return value of the <a href=
          "#function-format-number"><code>format-number</code></a>
          function.</p>

          <p>The algorithm for this second stage of processing is
          as follows:</p>

          <ol class="enumar">
            <li>
              <p>If the input number is NaN (not a number), the
              result is the specified <var>NaN-symbol</var> (with
              no <var>prefix</var> or <var>suffix</var>).</p>
            </li>

            <li>
              <p>In the rules below, the positive sub-picture and
              its associated variables are used if the input number
              is positive, and the negative sub-picture and its
              associated variables are used otherwise. Negative
              zero is taken as negative, positive zero as
              positive.</p>
            </li>

            <li>
              <p>If the input number is positive or negative
              infinity, the result is the concatenation of the
              appropriate <var>prefix</var>, the
              <var>infinity-symbol</var>, and the appropriate
              <var>suffix</var>.</p>
            </li>

            <li>
              <p>If the sub-picture contains a
              <var>percent-sign</var>, the number is multiplied by
              100. If the sub-picture contains a
              <var>per-mille-sign</var>, the number is multiplied
              by 1000. The resulting number is referred to below as
              the <var>adjusted number</var>.</p>
            </li>

            <li>
              <p>The <var>adjusted number</var> is converted (if
              necessary) to an <code>xs:decimal</code> value, using
              an implementation of <code>xs:decimal</code> that
              imposes no limits on the <code>totalDigits</code> or
              <code>fractionDigits</code> facets. If there are
              several such values that are numerically equal to the
              <var>adjusted number</var> (bearing in mind that if
              the <var>adjusted number</var> is an
              <code>xs:double</code> or <code>xs:float</code>, the
              comparison will be done by converting the decimal
              value back to an <code>xs:double</code> or
              <code>xs:float</code>), the one that is chosen
              <span class="verb">should</span> be one with the
              smallest possible number of digits not counting
              leading or trailing zeroes <span>(whether significant
              or insignificant)</span>. For example, 1.0 is
              preferred to 0.9999999999, and 100000000 is preferred
              to 100000001. This value is then rounded so that it
              uses no more than
              <code>maximum-fractional-part-size</code> digits in
              its fractional part. The <var>rounded number</var> is
              defined to be the result of converting the
              <var>adjusted number</var> to an
              <code>xs:decimal</code> value, as described above,
              and then calling the function <a href=
              "http://www.w3.org/TR/xpath-functions/#func-round-half-to-even">
              <code>round-half-to-even</code></a><sup><small>FO</small></sup>
              with this converted number as the first argument and
              the <code>maximum-fractional-part-size</code> as the
              second argument, again with no limits on the
              <code>totalDigits</code> or
              <code>fractionDigits</code> in the result.</p>
            </li>

            <li>
              <p>The absolute value of the <var>rounded
              number</var> is converted to a string in decimal
              notation, with no insignificant leading or trailing
              zeroes, using the characters implied by the choice of
              <var>zero-digit-sign</var> to represent the ten
              decimal digits, and the
              <var>decimal-separator-sign</var> to separate the
              integer part and the fractional part. (The value zero
              will at this stage be represented by a
              <var>decimal-separator-sign</var> on its own.)</p>
            </li>

            <li>
              <p>If the number of digits to the left of the
              <var>decimal-separator-sign</var> is less than
              <var>minimum-integer-part-size</var>, leading
              <var>zero-digit-sign</var> characters are added to
              pad out to that size.</p>
            </li>

            <li>
              <p>If the number of digits to the right of the
              <var>decimal-separator-sign</var> is less than
              <var>minimum-fractional-part-size</var>, trailing
              <var>zero-digit-sign</var> characters are added to
              pad out to that size.</p>
            </li>

            <li>
              <p>For each integer <var>N</var> in the
              <var>integer-part-grouping-positions</var> list, a
              <var>grouping-separator-sign</var> character is
              inserted into the string immediately after that digit
              that appears in the integer part of the number and
              has <var>N</var> digits between it and the
              <var>decimal-separator-sign</var>, if there is such a
              digit.</p>
            </li>

            <li>
              <p>For each integer <var>N</var> in the
              <var>fractional-part-grouping-positions</var> list, a
              <var>grouping-separator-sign</var> character is
              inserted into the string immediately before that
              digit that appears in the fractional part of the
              number and has <var>N</var> digits between it and the
              <var>decimal-separator-sign</var>, if there is such a
              digit.</p>
            </li>

            <li>
              <p>If there is no <var>decimal-separator-sign</var>
              in the sub-picture, <span>or if there are no digits
              to the right of the <var>decimal-separator-sign</var>
              character in the string, then</span> the
              <var>decimal-separator-sign</var> character is
              removed from the string (it will be the rightmost
              character in the string).</p>
            </li>

            <li>
              <p>The result of the function is the concatenation of
              the appropriate <var>prefix</var>, the string
              conversion of the number as obtained above, and the
              appropriate <var>suffix</var>.</p>
            </li>
          </ol>
        </div>
      </div>

      <div class="div2">
        <h3><a name="format-date" id="format-date"></a>16.5
        Formatting Dates and Times</h3>

        <p>Three functions are provided to represent dates and
        times as a string, using the conventions of a selected
        calendar, language, and country. Each has two
        variants.</p><a name="function-format-dateTime" id=
        "function-format-dateTime"></a>

        <div class="proto">
          <table border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td valign="baseline" rowspan="5"><code class=
              "function">format-dateTime</code>(</td>

              <td valign="baseline"><code class=
              "arg">$value</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:dateTime?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$picture</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$language</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$calendar</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$country</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>)<code class=
              "as">&#160;as&#160;</code><code class=
              "return-type">xs:string?</code></td>
            </tr>
          </table>
        </div>

        <div class="proto">
          <code class=
          "function">format-dateTime</code>(<code class="arg">$value</code><code class="as">
          &#160;as&#160;</code><code class=
          "type">xs:dateTime?</code>, <code class=
          "arg">$picture</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string?</code>
        </div><a name="function-format-date" id=
        "function-format-date"></a>

        <div class="proto">
          <table border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td valign="baseline" rowspan="5"><code class=
              "function">format-date</code>(</td>

              <td valign="baseline"><code class=
              "arg">$value</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:date?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$picture</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$language</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$calendar</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$country</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>)<code class=
              "as">&#160;as&#160;</code><code class=
              "return-type">xs:string?</code></td>
            </tr>
          </table>
        </div>

        <div class="proto">
          <code class="function">format-date</code>(<code class=
          "arg">$value</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:date?</code>, <code class=
          "arg">$picture</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string?</code>
        </div><a name="function-format-time" id=
        "function-format-time"></a>

        <div class="proto">
          <table border="0" cellpadding="0" cellspacing="0">
            <tr>
              <td valign="baseline" rowspan="5"><code class=
              "function">format-time</code>(</td>

              <td valign="baseline"><code class=
              "arg">$value</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:time?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$picture</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$language</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$calendar</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>,</td>
            </tr>

            <tr>
              <td valign="baseline"><code class=
              "arg">$country</code></td>

              <td valign="baseline"><code class=
              "as">&#160;as&#160;</code><code class=
              "type">xs:string?</code>)<code class=
              "as">&#160;as&#160;</code><code class=
              "return-type">xs:string?</code></td>
            </tr>
          </table>
        </div>

        <div class="proto">
          <code class="function">format-time</code>(<code class=
          "arg">$value</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:time?</code>, <code class=
          "arg">$picture</code><code class=
          "as">&#160;as&#160;</code><code class=
          "type">xs:string</code>)<code class=
          "as">&#160;as&#160;</code><code class=
          "return-type">xs:string?</code>
        </div>

        <p>The <a href=
        "#function-format-dateTime"><code>format-dateTime</code></a>,
        <a href=
        "#function-format-date"><code>format-date</code></a>, and
        <a href=
        "#function-format-time"><code>format-time</code></a>
        functions format <code>$value</code> as a string using the
        picture string specified by the <code>$picture</code>
        argument, the calendar specified by the
        <code>$calendar</code> argument, the language specified by
        the <code>$language</code> argument, and the country
        specified by the <code>$country</code> argument. The result
        of the function is the formatted string representation of
        the supplied <code>dateTime</code>, <code>date</code>, or
        <code>time</code> value.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-date-formatting-function" id=
        "dt-date-formatting-function" title=
        "date formatting function"></a>The three functions <a href=
        "#function-format-date"><code>format-date</code></a>,
        <a href=
        "#function-format-time"><code>format-time</code></a>, and
        <a href=
        "#function-format-dateTime"><code>format-dateTime</code></a>
        are referred to collectively as the <b>date formatting
        functions</b>.<span class="definition">]</span></p>

        <p>If <code>$value</code> is the empty sequence, the empty
        sequence is returned.</p>

        <p>Calling the two-argument form of each of the three
        functions is equivalent to calling the five-argument form
        with each of the last three arguments set to an empty
        sequence.</p>

        <p>For details of the <code>language</code>,
        <code>calendar</code>, and <code>country</code> arguments,
        see <a href="#lang-cal-country"><i>16.5.2 The Language,
        Calendar, and Country Arguments</i></a>.</p>

        <p>In general, the use of an invalid <code>picture</code>,
        <code>language</code>, <code>calendar</code>, or
        <code>country</code> argument is classified as a
        <span><a title="non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a>. By contrast,</span> use of an option in any of
        these arguments that is valid but not supported by the
        implementation is not an error, and in these cases the
        implementation is required to output the value in a
        fallback representation.</p>

        <div class="div3">
          <h4><a name="date-picture-string" id=
          "date-picture-string"></a>16.5.1 The Picture String</h4>

          <p>The picture consists of a sequence of variable markers
          and literal substrings. A substring enclosed in square
          brackets is interpreted as a variable marker; substrings
          not enclosed in square brackets are taken as literal
          substrings. The literal substrings are optional and if
          present are rendered unchanged, including any whitespace.
          If an opening or closing square bracket is required
          within a literal substring, it <span class=
          "verb">must</span> be doubled. The variable markers are
          replaced in the result by strings representing aspects of
          the date and/or time to be formatted. These are described
          in detail below.</p>

          <p>A variable marker consists of a component specifier
          followed optionally by one or two presentation modifiers
          and/or optionally by a width modifier. Whitespace within
          a variable marker is ignored.</p>

          <p>The <em>component specifier</em> indicates the
          component of the date or time that is required, and takes
          the following values:</p>

          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th align="left">Specifier</th>

                <th align="left">Meaning</th>

                <th align="left">Default Presentation Modifier</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td valign="top">Y</td>

                <td>year <span>(absolute value)</span></td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">M</td>

                <td>month in year</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">D</td>

                <td>day in month</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">d</td>

                <td>day in year</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">F</td>

                <td>day of week</td>

                <td valign="top">n</td>
              </tr>

              <tr>
                <td valign="top">W</td>

                <td>week in year</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">w</td>

                <td>week in month</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">H</td>

                <td>hour in day (24 hours)</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">h</td>

                <td>hour in half-day (12 hours)</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">P</td>

                <td>am/pm marker</td>

                <td valign="top">n</td>
              </tr>

              <tr>
                <td valign="top">m</td>

                <td>minute in hour</td>

                <td valign="top"><span>01</span></td>
              </tr>

              <tr>
                <td valign="top">s</td>

                <td>second in minute</td>

                <td valign="top"><span>01</span></td>
              </tr>

              <tr>
                <td valign="top">f</td>

                <td>fractional seconds</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">Z</td>

                <td>timezone as a time offset from UTC, or if an
                alphabetic modifier is present the conventional
                name of a timezone (such as PST)</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">z</td>

                <td>timezone as a time offset using GMT, for
                example GMT+1</td>

                <td valign="top">1</td>
              </tr>

              <tr>
                <td valign="top">C</td>

                <td>calendar: the name or abbreviation of a
                calendar name</td>

                <td valign="top">n</td>
              </tr>

              <tr>
                <td valign="top">E</td>

                <td>era: the name of a baseline for the numbering
                of years, for example the reign of a monarch</td>

                <td valign="top">n</td>
              </tr>
            </tbody>
          </table>

          <p><a name="err-XTDE1340" id="err-XTDE1340"><span class=
          "error">[ERR XTDE1340]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the syntax of the picture is incorrect.</p>

          <p><a name="err-XTDE1350" id="err-XTDE1350"><span class=
          "error">[ERR XTDE1350]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if a component specifier within the picture
          refers to components that are not available in the given
          type of <code>$value</code>, for example if the picture
          supplied to the <a href=
          "#function-format-time"><code>format-time</code></a>
          refers to the year, month, or day component.</p>

          <p>It is not an error to include a timezone component
          when the supplied value has no timezone. In these
          circumstances the timezone component will be ignored.</p>

          <p>The first <em>presentation modifier</em> indicates the
          style in which the value of a component is to be
          represented. Its value may be either:</p>

          <ul>
            <li>
              <p>any format token permitted in the
              <code>format</code> string of the <a href=
              "#element-number"><code>xsl:number</code></a>
              instruction (see <a href="#number"><i>12
              Numbering</i></a>), indicating that the value of the
              component is to be output numerically using the
              specified number format (for example, <code>1</code>,
              <code>01</code>, <code>i</code>, <code>I</code>,
              <code>w</code>, <code>W</code>, or <code>Ww</code>)
              or</p>
            </li>

            <li>
              <p>the format token <code>n</code>, <code>N</code>,
              or <code>Nn</code>, indicating that the value of the
              component is to be output by name, in lower-case,
              upper-case, or title-case respectively. Components
              that can be output by name include (but are not
              limited to) months, days of the week, timezones, and
              eras. If the processor cannot output these components
              by name for the chosen calendar and language then it
              must use an implementation-defined fallback
              representation.</p>
            </li>
          </ul>

          <p>If the implementation does not support the use of the
          requested format token, it <span class="verb">must</span>
          use the default presentation modifier for that
          component.</p>

          <p>If the first presentation modifier is present, then it
          may optionally be followed by a second presentation
          modifier as follows:</p>

          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th align="left">Modifier</th>

                <th align="left">Meaning</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td valign="top">t</td>

                <td valign="top">traditional numbering. This has
                the same meaning as
                <code>letter-value="traditional"</code> in <a href=
                "#element-number"><code>xsl:number</code></a>.</td>
              </tr>

              <tr>
                <td valign="top">o</td>

                <td valign="top">ordinal form of a number, for
                example <code>8th</code> or <code>8º</code>. The
                actual representation of the ordinal form of a
                number may depend not only on the language, but
                also on the grammatical context (for example, in
                some languages it must agree in gender).</td>
              </tr>
            </tbody>
          </table>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Although the formatting rules are expressed in terms
            of the rules for format tokens in <a href=
            "#element-number"><code>xsl:number</code></a>, the
            formats actually used may be specialized to the
            numbering of date components where appropriate. For
            example, in Italian, it is conventional to use an
            ordinal number (<code>primo</code>) for the first day
            of the month, and cardinal numbers (<code>due, tre,
            quattro ...</code>) for the remaining days. A processor
            may therefore use this convention to number days of the
            month, ignoring the presence or absence of the ordinal
            presentation modifier.</p>
          </div>

          <p>Whether or not a presentation modifier is included, a
          width modifier may be supplied. This indicates the number
          of characters or digits to be included in the
          representation of the value.</p>

          <p>The width modifier, if present, is introduced by a
          comma. It takes the form:</p>

          <p><code>&#160;&#160;&#160;,&#160;&#160;min-width ("-"
          max-width)?</code></p>

          <p>where <code>min-width</code> is either an unsigned
          integer indicating the minimum number of characters to be
          output, or <code>*</code> indicating that there is no
          explicit minimum, and <code>max-width</code> is either an
          unsigned integer indicating the maximum number of
          characters to be output, or <code>*</code> indicating
          that there is no explicit maximum; if
          <code>max-width</code> is omitted then <code>*</code> is
          assumed. Both integers, if present, <span class=
          "verb">must</span> be greater than zero.</p>

          <p>A format token containing leading zeroes, such as
          <code>001</code>, sets the minimum and maximum width to
          the number of digits appearing in the format token; if a
          width modifier is also present, then the width modifier
          takes precedence.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>A format token consisting of a one-digit on its own,
            such as <code>1</code>, does not constrain the number
            of digits in the output. In the case of fractional
            seconds in particular, <code>[f001]</code> requests
            three decimal digits, <code>[f01]</code> requests two
            digits, but <code>[f1]</code> will produce an
            implementation-defined number of digits. If exactly one
            digit is required, this can be achieved using the
            component specifier <code>[f1,1-1]</code>.</p>
          </div>

          <p>If the minumum and maximum width are unspecified, then
          the output uses as many characters as are required to
          represent the value of the component without truncation
          and without padding: this is referred to below as the
          <em>full representation</em> of the value.</p>

          <p>If the full representation of the value exceeds the
          specified maximum width, then the processor <span class=
          "verb">should</span> attempt to use an alternative
          shorter representation that fits within the maximum
          width. Where the presentation modifier is <code>N</code>,
          <code>n</code>, or <code>Nn</code>, this is done by
          abbreviating the name, using either conventional
          abbreviations if available, or crude right-truncation if
          not. For example, setting <code>max-width</code> to
          <code>4</code> indicates that four-letter abbreviations
          <span class="verb">should</span> be used, though it would
          be acceptable to use a three-letter abbreviation if this
          is in conventional use. (For example, "Tuesday" might be
          abbreviated to "Tues", and "Friday" to "Fri".) In the
          case of the year component, setting
          <code>max-width</code> requests omission of high-order
          digits from the year, for example, if
          <code>max-width</code> is set to <code>2</code> then the
          year 2003 will be output as <code>03</code>. <span>In the
          case of the fractional seconds component, the value is
          rounded to the specified size as if by applying the
          function <code>round-half-to-even(fractional-seconds,
          max-width)</code>.</span> If no mechanism is available
          for fitting the value within the specified maximum width
          (for example, when roman numerals are used), then the
          value <span class="verb">should</span> be output in its
          full representation.</p>

          <p>If the full representation of the value is shorter
          than the specified minimum width, then the processor
          <span class="verb">should</span> pad the value to the
          specified width. For decimal representations of numbers,
          this <span class="verb">should</span> be done by
          prepending zero digits from the appropriate set of digit
          characters, or appending zero digits in the case of the
          fractional seconds component. In other cases, it
          <span class="verb">should</span> be done by appending
          spaces.</p>
        </div>

        <div class="div3">
          <h4><a name="lang-cal-country" id=
          "lang-cal-country"></a>16.5.2 The Language, Calendar, and
          Country Arguments</h4>

          <p>The set of languages, calendars, and countries that
          are supported in the <a title="date formatting function"
          href="#dt-date-formatting-function">date formatting
          functions</a> is <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          When any of these arguments is omitted or is an empty
          sequence, an <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          default value is used.</p>

          <p>If the fallback representation uses a different
          calendar from that requested, the output string
          <span class="verb">must</span> be prefixed with
          <code>[Calendar: X]</code> where <code>X</code>
          identifies the calendar actually used. The string
          <code>Calendar</code> <span class="verb">should</span> be
          localized using the requested language if available. If
          the fallback representation uses a different language
          from that requested, the output string should be prefixed
          with <code>[Language: Y]</code> where <code>Y</code>
          identifies the language actually used. The string
          <code>Language</code> <span class="verb">may</span> be
          localized in an <a title="implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>
          way. If a particular component of the value cannot be
          output in the requested format, it <span class=
          "verb">should</span> be output in the default format for
          that component.</p>

          <p>The <code>language</code> argument specifies the
          language to be used for the result string of the
          function. The value of the argument <span class=
          "verb">must</span> be either the empty sequence or a
          value that would be valid for the <code>xml:lang</code>
          attribute (see [XML]). Note that this permits the
          identification of sublanguages based on country codes
          (from <a href="#ISO3166">[ISO 3166-1]</a>) as well as
          identification of dialects and of regions within a
          country.</p>

          <p>If the <code>language</code> argument is omitted or is
          set to an empty sequence, or if it is set to an invalid
          value or a value that the implementation does not
          recognize, then the processor uses an <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          language.</p>

          <p>The language is used to select the appropriate
          language-dependent forms of:</p>

          <blockquote>
            <p>names (for example, of months)<br />
            numbers expressed as words or as ordinals
            (<code>twenty, 20th, twentieth</code>)<br />
            hour convention (0-23 vs 1-24, 0-11 vs 1-12)<br />
            first day of week, first week of year</p>
          </blockquote>

          <p>Where appropriate this choice may also take into
          account the value of the <code>country</code> argument,
          though this <span class="verb">should</span> not be used
          to override the language or any sublanguage that is
          specified as part of the <code>language</code>
          argument.</p>

          <p>The choice of the names and abbreviations used in any
          given language is <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          For example, one implementation might abbreviate July as
          <code>Jul</code> while another uses <code>Jly</code>. In
          German, one implementation might represent Saturday as
          <code>Samstag</code> while another uses
          <code>Sonnabend</code>. Implementations <span class=
          "verb">may</span> provide mechanisms allowing users to
          control such choices.</p>

          <p>Where ordinal numbers are used, the selection of the
          correct representation of the ordinal (for example, the
          linguistic gender) <span class="verb">may</span> depend
          on the component being formatted and on its textual
          context in the picture string.</p>

          <p>The <code>calendar</code> attribute specifies that the
          <code>dateTime</code>, <code>date</code>, or
          <code>time</code> supplied in the <code>$value</code>
          argument <span class="verb">must</span> be converted to a
          value in the specified calendar and then converted to a
          string using the conventions of that calendar.</p>

          <p>A calendar value <span class="verb">must</span> be a
          valid <a title="QName" href="#dt-qname">QName</a>. If the
          QName does not have a prefix, then it identifies a
          calendar with the designator specified below. If the
          QName has a prefix, then the QName is expanded into an
          expanded-QName as described in <a href="#qname"><i>5.1
          Qualified Names</i></a>; the expanded-QName identifies
          the calendar; the behavior in this case is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.</p>

          <p>If the calendar attribute is omitted an <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          value is used.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The calendars listed below were known to be in use
            during the last hundred years. Many other calendars
            have been used in the past.</p>

            <p>This specification does not define any of these
            calendars, nor the way that they map to the value space
            of the <code>xs:date</code> data type in <a href=
            "#xmlschema-2">[XML Schema Part 2]</a>. There may be
            ambiguities when dates are recorded using different
            calendars. For example, the start of a new day is not
            simultaneous in different calendars, and may also vary
            geographically (for example, based on the time of
            sunrise or sunset). Translation of dates is therefore
            more reliable when the time of day is also known, and
            when the geographic location is known. When translating
            dates between one calendar and another, the processor
            may take account of the values of the
            <code>country</code> and/or <code>language</code>
            arguments, with the <code>country</code> argument
            taking precedence.</p>

            <p>Information about some of these calendars, and
            algorithms for converting between them, may be found in
            <a href="#CALCALC">[Calendrical Calculations]</a>.</p>
          </div>

          <table border="1" cellpadding="5">
            <thead>
              <tr>
                <th valign="top" align="left">Designator</th>

                <th valign="top" align="left">Calendar</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td>AD</td>

                <td>Anno Domini (Christian Era)</td>
              </tr>

              <tr>
                <td>AH</td>

                <td>Anno Hegirae (Muhammedan Era)</td>
              </tr>

              <tr>
                <td>AME</td>

                <td>Mauludi Era (solar years since Mohammed's
                birth)</td>
              </tr>

              <tr>
                <td>AM</td>

                <td>Anno Mundi (Jewish Calendar)</td>
              </tr>

              <tr>
                <td>AP</td>

                <td>Anno Persici</td>
              </tr>

              <tr>
                <td>AS</td>

                <td>Aji Saka Era (Java)</td>
              </tr>

              <tr>
                <td>BE</td>

                <td>Buddhist Era</td>
              </tr>

              <tr>
                <td>CB</td>

                <td>Cooch Behar Era</td>
              </tr>

              <tr>
                <td>CE</td>

                <td>Common Era</td>
              </tr>

              <tr>
                <td>CL</td>

                <td>Chinese Lunar Era</td>
              </tr>

              <tr>
                <td>CS</td>

                <td>Chula Sakarat Era</td>
              </tr>

              <tr>
                <td>EE</td>

                <td>Ethiopian Era</td>
              </tr>

              <tr>
                <td>FE</td>

                <td>Fasli Era</td>
              </tr>

              <tr>
                <td>ISO</td>

                <td>ISO 8601 calendar</td>
              </tr>

              <tr>
                <td>JE</td>

                <td>Japanese Calendar</td>
              </tr>

              <tr>
                <td>KE</td>

                <td>Khalsa Era (Sikh calendar)</td>
              </tr>

              <tr>
                <td>KY</td>

                <td>Kali Yuga</td>
              </tr>

              <tr>
                <td>ME</td>

                <td>Malabar Era</td>
              </tr>

              <tr>
                <td>MS</td>

                <td>Monarchic Solar Era</td>
              </tr>

              <tr>
                <td>NS</td>

                <td>Nepal Samwat Era</td>
              </tr>

              <tr>
                <td>OS</td>

                <td>Old Style (Julian Calendar)</td>
              </tr>

              <tr>
                <td>RS</td>

                <td>Rattanakosin (Bangkok) Era</td>
              </tr>

              <tr>
                <td>SE</td>

                <td>Saka Era</td>
              </tr>

              <tr>
                <td>SH</td>

                <td>Mohammedan Solar Era (Iran)</td>
              </tr>

              <tr>
                <td>SS</td>

                <td>Saka Samvat</td>
              </tr>

              <tr>
                <td>TE</td>

                <td>Tripurabda Era</td>
              </tr>

              <tr>
                <td>VE</td>

                <td>Vikrama Era</td>
              </tr>

              <tr>
                <td>VS</td>

                <td>Vikrama Samvat Era</td>
              </tr>
            </tbody>
          </table>

          <p>At least one of the above calendars <span class=
          "verb">must</span> be supported. It is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          which calendars are supported.</p>

          <p>The ISO 8601 calendar (<a href="#ISO8601">[ISO
          8601]</a>), which is included in the above list and
          designated <code>ISO</code>, is very similar to the
          Gregorian calendar designated <code>AD</code>, but it
          differs in several ways. The ISO calendar is intended to
          ensure that date and time formats can be read easily by
          other software, as well as being legible for human users.
          The ISO calendar prescribes the use of particular
          numbering conventions as defined in ISO 8601, rather than
          allowing these to be localized on a per-language basis.
          In particular it provides a numeric 'week date' format
          which identifies dates by year, week of the year, and day
          in the week; in the ISO calendar the days of the week are
          numbered from 1 (Monday) to 7 (Sunday), and week 1 in any
          calendar year is the week (from Monday to Sunday) that
          includes the first Thursday of that year. The numeric
          values of the components year, month, day, hour, minute,
          and second are the same in the ISO calendar as the values
          used in the lexical representation of the date and time
          as defined in <a href="#xmlschema-2">[XML Schema Part
          2]</a>. The era ("E" component) with this calendar is
          either a minus sign (for negative years) or a zero-length
          string (for positive years). For dates before 1 January,
          AD 1, year numbers in the ISO and AD calendars are off by
          one from each other: ISO year 0000 is 1 BC, -0001 is 2
          BC, etc.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The value space of the date and time data types, as
            defined in XML Schema, is based on absolute points in
            time. The lexical space of these data types defines a
            representation of these absolute points in time using
            the proleptic Gregorian calendar, that is, the modern
            Western calendar extrapolated into the past and the
            future; but the value space is calendar-neutral. The
            <a title="date formatting function" href=
            "#dt-date-formatting-function">date formatting
            functions</a> produce a representation of this absolute
            point in time, but denoted in a possibly different
            calendar. So, for example, the date whose lexical
            representation in XML Schema is <code>1502-01-11</code>
            (the day on which Pope Gregory XIII was born) might be
            formatted using the Old Style (Julian) calendar as
            <code>1 January 1502</code>. This reflects the fact
            that there was at that time a ten-day difference
            between the two calendars. It would be incorrect, and
            would produce incorrect results, to represent this date
            in an element or attribute of type <code>xs:date</code>
            as <code>1502-01-01</code>, even though this might
            reflect the way the date was recorded in contemporary
            documents.</p>

            <p>When referring to years occurring in antiquity,
            modern historians generally use a numbering system in
            which there is no year zero (the year before 1 CE is
            thus 1 BCE). This is the convention that <span class=
            "verb">should</span> be used when the requested
            calendar is OS (Julian) or AD (Gregorian). When the
            requested calendar is ISO, however, the conventions of
            ISO 8601 <span class="verb">should</span> be followed:
            here the year before +0001 is numbered zero. In
            <a href="#xmlschema-2">[XML Schema Part 2]</a> (version
            1.0), the value space for <code>xs:date</code> and
            <code>xs:dateTime</code> does not include a year zero:
            however, a future edition is expected to endorse the
            ISO 8601 convention. This means that the date on which
            Julius Caesar was assassinated has the ISO 8601 lexical
            representation -0043-03-13, but will be formatted as 15
            March 44 BCE in the Julian calendar or 13 March 44 BCE
            in the Gregorian calendar (dependant on the chosen
            localization of the names of months and eras).</p>
          </div>

          <p>The intended use of the <code>country</code> argument
          is to identify the place where an event represented by
          the <code>dateTime</code>, <code>date</code>, or
          <code>time</code> supplied in the <code>$value</code>
          argument took place or will take place. If the value is
          supplied, and is not the empty sequence, then it
          <span class="verb">should</span> be a country code
          defined in <a href="#ISO3166">[ISO 3166-1]</a>.
          Implementations <span class="verb">may</span> also allow
          the use of codes representing subdivisions of a country
          from ISO 3166-2, or codes representing formerly used
          names of countries from ISO 3166-3. This argument is not
          intended to identify the location of the user for whom
          the date or time is being formatted; that should be done
          by means of the <code>language</code> attribute. This
          information <span class="verb">may</span> be used to
          provide additional information when converting dates
          between calendars or when deciding how individual
          components of the date and time are to be formatted. For
          example, different countries using the Old Style (Julian)
          calendar started the new year on different days, and some
          countries used variants of the calendar that were out of
          synchronization as a result of differences in calculating
          leap years. <span>The geographical area identified by a
          country code is defined by the boundaries as they existed
          at the time of the date to be formatted, or the
          present-day boundaries for dates in the
          future.</span></p>
        </div>

        <div class="div3">
          <h4><a name="date-time-examples" id=
          "date-time-examples"></a>16.5.3 Examples of Date and Time
          Formatting</h4>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e24888" id="d5e24888"></a>Example:
              Gregorian Calendar
            </div>

            <p>The following examples show a selection of dates and
            times and the way they might be formatted. These
            examples assume the use of the Gregorian calendar as
            the default calendar.</p>

            <table border="1" cellpadding="5">
              <thead>
                <tr>
                  <th align="left">Required Output</th>

                  <th align="left">Expression</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td><code>2002-12-31</code></td>

                  <td><code>format-date($d,
                  "[Y0001]-[M01]-[D01]")</code></td>
                </tr>

                <tr>
                  <td><code>12-31-2002</code></td>

                  <td><code>format-date($d,
                  "[M]-[D]-[Y]")</code></td>
                </tr>

                <tr>
                  <td><code>31-12-2002</code></td>

                  <td><code>format-date($d,
                  "[D]-[M]-[Y]")</code></td>
                </tr>

                <tr>
                  <td><code>31 XII 2002</code></td>

                  <td><code>format-date($d, "[D1] [MI]
                  [Y]")</code></td>
                </tr>

                <tr>
                  <td><code>31st December, 2002</code></td>

                  <td><code>format-date($d, "[D1o] [MNn], [Y]",
                  "en", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>31 DEC 2002</code></td>

                  <td><code>format-date($d, "[D01] [MN,*-3]
                  [Y0001]", "en", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>December 31, 2002</code></td>

                  <td><code>format-date($d, "[MNn] [D], [Y]", "en",
                  (), ())</code></td>
                </tr>

                <tr>
                  <td><code>31 Dezember, 2002</code></td>

                  <td><code>format-date($d, "[D] [MNn], [Y]", "de",
                  (), ())</code></td>
                </tr>

                <tr>
                  <td><code>Tisdag 31 December 2002</code></td>

                  <td><code>format-date($d, "[FNn] [D] [MNn] [Y]",
                  "sv", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>[2002-12-31]</code></td>

                  <td><code>format-date($d,
                  "[[[Y0001]-[M01]-[D01]]]")</code></td>
                </tr>

                <tr>
                  <td><code>Two Thousand and Three</code></td>

                  <td><code>format-date($d, "[YWw]", "en", (),
                  ())</code></td>
                </tr>

                <tr>
                  <td><code>einunddreißigste Dezember</code></td>

                  <td><code>format-date($d, "[Dwo] [MNn]", "de",
                  (), ())</code></td>
                </tr>

                <tr>
                  <td><code>3:58 PM</code></td>

                  <td><code>format-time($t, "[h]:[m01] [PN]", "en",
                  (), ())</code></td>
                </tr>

                <tr>
                  <td><code>3:58:45 pm</code></td>

                  <td><code>format-time($t, "[h]:[m01]:[s01] [Pn]",
                  "en", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>3:58:45 PM PDT</code></td>

                  <td><code>format-time($t, "[h]:[m01]:[s01] [PN]
                  [ZN,*-3]", "en", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>3:58:45 o'clock PM PDT</code></td>

                  <td><code>format-time($t, "[h]:[m01]:[s01]
                  o'clock [PN] [ZN,*-3]", "en")</code></td>
                </tr>

                <tr>
                  <td><code>15:58</code></td>

                  <td>
                  <code>format-time($t,"[H01]:[m01]")</code></td>
                </tr>

                <tr>
                  <td><code>15:58:45.762</code></td>

                  <td>
                  <code>format-time($t,"[H01]:[m01]:[s01].[f001]")</code></td>
                </tr>

                <tr>
                  <td><code>15:58:45 GMT+02:00</code></td>

                  <td><code>format-time($t,"[H01]:[m01]:[s01] [z]",
                  "en", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>15.58 Uhr GMT+02:00</code></td>

                  <td><code>format-time($t,"[H01]:[m01] Uhr [z]",
                  "de", (), ())</code></td>
                </tr>

                <tr>
                  <td><code>3.58pm on Tuesday, 31st
                  December</code></td>

                  <td><code>format-dateTime($dt, "[h].[m01][Pn] on
                  [FNn], [D1o] [MNn]")</code></td>
                </tr>

                <tr>
                  <td><span><code>12/31/2002 at
                  15:58:45</code></span></td>

                  <td><code>format-dateTime($dt,
                  "[M01]/[D01]/[Y0001] at
                  [H01]:[m01]:[s01]")</code></td>
                </tr>
              </tbody>
            </table>
          </div>

          <p>&#160;</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e25057" id="d5e25057"></a>Example:
              Non-Gregorian Calendars
            </div>

            <p>The following examples use calendars other than the
            Gregorian calendar.</p>

            <p>These examples use non-Latin characters which might
            not display correctly in all browsers, depending on the
            system configuration.</p>

            <table border="1" cellpadding="5">
              <thead>
                <tr>
                  <th align="left">Description</th>

                  <th align="left">Request</th>

                  <th align="left">Result</th>
                </tr>
              </thead>

              <tbody>
                <tr>
                  <td valign="top">Islamic</td>

                  <td valign="top"><code>format-date($d,
                  "[D&amp;#x0661;] [Mn] [Y&amp;#x0661;]",
                  "Islamic", "ar", "AH", ())</code></td>

                  <td valign="top">٢٦ ﺸﻭّﺍﻝ ١٤٢٣</td>
                </tr>

                <tr>
                  <td valign="top">Jewish (with Western
                  numbering)</td>

                  <td valign="top"><code>format-date($d, "[D] [Mn]
                  [Y]", "he", "AM", ())</code></td>

                  <td valign="top">‏26 טבת 5763</td>
                </tr>

                <tr>
                  <td valign="top">Jewish (with traditional
                  numbering)</td>

                  <td valign="top"><code>format-date($d,
                  "[D&amp;#x05D0;t] [Mn] [Y&amp;#x05D0;t]", "he",
                  "AM", ())</code></td>

                  <td valign="top">כ״ו טבת תשס״ג</td>
                </tr>

                <tr>
                  <td valign="top">Julian (Old Style)</td>

                  <td valign="top"><code>format-date($d, "[D] [MNn]
                  [Y]", "en", "OS", ())</code></td>

                  <td valign="top">18 December 2002</td>
                </tr>

                <tr>
                  <td valign="top">Thai</td>

                  <td valign="top"><code>format-date($d,
                  "[D&amp;#x0E51;] [Mn] [Y&amp;#x0E51;]", "th",
                  "BE", ())</code></td>

                  <td valign="top">๓๑ ธันวาคม ๒๕๔๕</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="misc-func" id="misc-func"></a>16.6
        Miscellaneous Additional Functions</h3>

        <div class="div3">
          <h4><a name="current-function" id=
          "current-function"></a>16.6.1 current</h4><a name=
          "function-current" id="function-current"></a>

          <div class="proto">
            <code class="function">current</code>()<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">item()</code>
          </div>

          <p>The <a href=
          "#function-current"><code>current</code></a> function,
          used within an XPath <a title="expression" href=
          "#dt-expression">expression</a>, returns the item that
          was the <a title="context item" href=
          "#dt-context-item">context item</a> at the point where
          the expression was invoked from the XSLT <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>. This
          is referred to as the current item. For an outermost
          expression (an expression not occurring within another
          expression), the current item is always the same as the
          context item. Thus,</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:value-of select="current()"/&gt;
</pre>
          </div>

          <p>means the same as</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:value-of select="."/&gt;
</pre>
          </div>

          <p>However, within square brackets, or on the right-hand
          side of the <code>/</code> operator, the current item is
          generally different from the context item.</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e25146" id="d5e25146"></a>Example: Using
              the <code>current</code> Function
            </div>

            <p>For example,</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;
</pre>
            </div>

            <p>will process all <code>entry</code> elements that
            have a <code>glossary</code> parent element and that
            have a <code>name</code> attribute with value equal to
            the value of the current item's <code>ref</code>
            attribute. This is different from</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;
</pre>
            </div>

            <p>which means the same as</p>

            <div class="exampleInner">
              <pre>
&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;
</pre>
            </div>

            <p>and so would process all <code>entry</code> elements
            that have a <code>glossary</code> parent element and
            that have a <code>name</code> attribute and a
            <code>ref</code> attribute with the same value.</p>
          </div>

          <p>If the <a href=
          "#function-current"><code>current</code></a> function is
          used within a <a title="pattern" href=
          "#dt-pattern">pattern</a>, its value is the node that is
          being matched against the pattern.</p>

          <p><a name="err-XTDE1360" id="err-XTDE1360"><span class=
          "error">[ERR XTDE1360]</span></a> If the <a href=
          "#function-current"><code>current</code></a> function is
          evaluated within an expression that is evaluated when the
          context item is undefined, a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> occurs.</p>
        </div>

        <div class="div3">
          <h4><a name="unparsed-entity-uri" id=
          "unparsed-entity-uri"></a>16.6.2
          unparsed-entity-uri</h4><a name=
          "function-unparsed-entity-uri" id=
          "function-unparsed-entity-uri"></a>

          <div class="proto">
            <code class=
            "function">unparsed-entity-uri</code>(<code class=
            "arg">$entity-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:anyURI</code>
          </div>

          <p>The <a href=
          "#function-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
          function returns the URI of the unparsed entity whose
          name is given by the value of the
          <code>$entity-name</code> argument, in the document
          containing the <a title="context node" href=
          "#dt-context-node">context node</a>. It returns the
          zero-length <span><code>xs:anyURI</code></span> if there
          is no such entity. <span>This function maps to the
          <code>dm:unparsed-entity-system-id</code> accessor
          defined in <a href="#xpath-datamodel">[Data
          Model]</a>.</span></p>

          <p><a name="err-XTDE1370" id="err-XTDE1370"><span class=
          "error">[ERR XTDE1370]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a href=
          "#function-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
          function is called when there is no <a title=
          "context node" href="#dt-context-node">context node</a>,
          or when the root of the tree containing the context node
          is not a document node.</p>
        </div>

        <div class="div3">
          <h4><a name="unparsed-entity-public-id" id=
          "unparsed-entity-public-id"></a>16.6.3
          unparsed-entity-public-id</h4><a name=
          "function-unparsed-entity-public-id" id=
          "function-unparsed-entity-public-id"></a>

          <div class="proto">
            <code class=
            "function">unparsed-entity-public-id</code>(<code class="arg">
            $entity-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:string</code>
          </div>

          <p>The <a href=
          "#function-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
          function returns the public identifier of the unparsed
          entity whose name is given by the value of the
          <code>$entity-name</code> argument, in the document
          containing the <a title="context node" href=
          "#dt-context-node">context node</a>. It returns the
          zero-length string if there is no such entity<span>, or
          if the entity has no public identifier</span>. <span>This
          function maps to the
          <code>dm:unparsed-entity-public-id</code> accessor
          defined in <a href="#xpath-datamodel">[Data
          Model]</a>.</span></p>

          <p><a name="err-XTDE1380" id="err-XTDE1380"><span class=
          "error">[ERR XTDE1380]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a href=
          "#function-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
          function is called when there is no <a title=
          "context node" href="#dt-context-node">context node</a>,
          or when the root of the tree containing the context node
          is not a document node.</p>
        </div>

        <div class="div3">
          <h4><a name="generate-id" id="generate-id"></a>16.6.4
          generate-id</h4><a name="function-generate-id" id=
          "function-generate-id"></a>

          <div class="proto">
            <code class="function">generate-id</code>()<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:string</code>
          </div>

          <div class="proto">
            <code class="function">generate-id</code>(<code class=
            "arg">$node</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">node()?</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:string</code>
          </div>

          <p>The <a href=
          "#function-generate-id"><code>generate-id</code></a>
          function returns a string that uniquely identifies a
          given node. The unique identifier <span class=
          "verb">must</span> consist of ASCII alphanumeric
          characters and <span class="verb">must</span> start with
          an alphabetic character. Thus, the string is
          syntactically an XML name. An implementation is free to
          generate an identifier in any convenient way provided
          that it always generates the same identifier for the same
          node and that different identifiers are always generated
          from different nodes. An implementation is under no
          obligation to generate the same identifiers each time a
          document is transformed. There is no guarantee that a
          generated unique identifier will be distinct from any
          unique IDs specified in the source document. If the
          argument is the empty sequence, the result is the
          <span>zero-length string</span>. If the argument is
          omitted, it defaults to the <a title="context node" href=
          "#dt-context-node">context node</a>.</p>
        </div>

        <div class="div3">
          <h4><a name="system-property" id=
          "system-property"></a>16.6.5 system-property</h4><a name=
          "function-system-property" id=
          "function-system-property"></a>

          <div class="proto">
            <code class=
            "function">system-property</code>(<code class=
            "arg">$property-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:string</code>
          </div>

          <p>The <code>$property-name</code> argument <span class=
          "verb">must</span> evaluate to a <a title="lexical QName"
          href="#dt-lexical-qname">lexical QName</a>. The <a title=
          "lexical QName" href="#dt-lexical-qname">lexical
          QName</a> is expanded as described in <a href=
          "#qname"><i>5.1 Qualified Names</i></a>.</p>

          <p><a name="err-XTDE1390" id="err-XTDE1390"><span class=
          "error">[ERR XTDE1390]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the value is not a valid QName, or if there
          is no namespace declaration in scope for the prefix of
          the QName. If the processor is able to detect the error
          statically (for example, when the argument is supplied as
          a string literal), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>

          <p>The <a href=
          "#function-system-property"><code>system-property</code></a>
          function returns a string representing the value of the
          system property identified by the name. If there is no
          such system property, the zero-length string
          <span>is</span> returned.</p>

          <p>Implementations <span class="verb">must</span> provide
          the following system properties, which are all in the
          <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>:</p>

          <ul>
            <li>
              <p><code>xsl:version</code>, a number giving the
              version of XSLT implemented by the <a title=
              "processor" href="#dt-processor">processor</a>; for
              implementations conforming to the version of XSLT
              specified by this document, this is the string
              <code>"2.0"</code>. The value will always be a string
              in the lexical space of the decimal data type defined
              in XML Schema (see <a href="#xmlschema-2">[XML Schema
              Part 2]</a>). This allows the value to be converted
              to a number for the purpose of magnitude
              comparisons.</p>
            </li>

            <li>
              <p><code>xsl:vendor</code>, a string identifying the
              implementer of the <a title="processor" href=
              "#dt-processor">processor</a></p>
            </li>

            <li>
              <p><code>xsl:vendor-url</code>, a string containing a
              URL identifying the implementer of the <a title=
              "processor" href="#dt-processor">processor</a>;
              typically this is the host page (home page) of the
              implementer's Web site.</p>
            </li>

            <li>
              <p><code>xsl:product-name</code>, a string containing
              the name of the implementation, as defined by the
              implementer. This <span class="verb">should</span>
              normally remain constant from one release of the
              product to the next. It <span class=
              "verb">should</span> also be constant across
              platforms in cases where the same source code is used
              to produce compatible products for multiple execution
              platforms.</p>
            </li>

            <li>
              <p><code>xsl:product-version</code>, a string
              identifying the version of the implementation, as
              defined by the implementer. This <span class=
              "verb">should</span> normally vary from one release
              of the product to the next, and at the discretion of
              the implementer it <span class="verb">may</span> also
              vary across different execution platforms.</p>
            </li>

            <li>
              <p><code>xsl:is-schema-aware</code>, returns the
              string <code>"yes"</code> in the case of a processor
              that claims conformance as a <a title=
              "schema-aware XSLT processor" href=
              "#dt-schema-aware-xslt-processor">schema-aware XSLT
              processor</a>, or <code>"no"</code> in the case of a
              <a title="basic XSLT processor" href=
              "#dt-basic-xslt-processor">basic XSLT
              processor</a>.</p>
            </li>

            <li>
              <p><code>xsl:supports-serialization</code>, returns
              the string <code>"yes"</code> in the case of a
              processor that offers the <a title=
              "serialization feature" href=
              "#dt-serialization-feature">serialization
              feature</a>, or <code>"no"</code> otherwise.</p>
            </li>

            <li>
              <p><code>xsl:supports-backwards-compatibility</code>,
              returns the string <code>"yes"</code> in the case of
              a processor that offers the <a title=
              "backwards compatibility feature" href=
              "#dt-backwards-compatibility-feature">backwards
              compatibility feature</a>, or <code>"no"</code>
              otherwise.</p>
            </li>
          </ul>

          <p>Some of these properties relate to the conformance
          levels and features offered by the <a title="processor"
          href="#dt-processor">processor</a>: these options are
          described in <a href="#conformance"><i>21
          Conformance</i></a>.</p>

          <p>The actual values returned for the above properties
          are <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.</p>

          <p>The set of system properties that are supported, in
          addition to those listed above, is also <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          Implementations <span class="verb">must not</span> define
          additional system properties in the XSLT namespace.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>An implementation must not return the value
            <code>2.0</code> as the value of the
            <code>xsl:version</code> system property unless it is
            conformant to XSLT 2.0.</p>

            <p>It is recognized that vendors who are enhancing XSLT
            1.0 processors may wish to release interim
            implementations before all the mandatory features of
            this specification are implemented. Since such products
            are not conformant to XSLT 2.0, this specification
            cannot define their behavior. However, implementers of
            such products are encouraged to return a value for the
            <code>xsl:version</code> system property that is
            intermediate between 1.0 and 2.0, and to provide the
            <a href=
            "#function-element-available"><code>element-available</code></a>
            and <a href=
            "#function-function-available"><code>function-available</code></a>
            functions to allow users to test which features have
            been fully implemented.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="message" id="message"></a>17 Messages</h2>

      <p class="element-syntax"><a name="element-message" id=
      "element-message"></a><code>&lt;!-- Category: instruction
      --&gt;<br />
      &lt;xsl:message<br />
      &#160;&#160;select? = <var>expression</var><br />
      &#160;&#160;terminate? = { "yes" | "no" }&gt;<br />
      &#160;&#160;&lt;!-- Content: <var>sequence-constructor</var>
      --&gt;<br />
      &lt;/xsl:message&gt;</code></p>

      <p>The <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      sends a message in an <a title="implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a> way.
      The <a href="#element-message"><code>xsl:message</code></a>
      instruction causes the creation of a new document, which is
      typically serialized and output to an <a title=
      "implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a>
      destination. The result of the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      is an empty sequence.</p>

      <p>The content of the message may be specified by using
      either or both of the optional <code>select</code> attribute
      and the <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> that
      forms the content of the <a href=
      "#element-message"><code>xsl:message</code></a>
      instruction.</p>

      <p>If the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      contains a <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a>, then the
      sequence obtained by evaluating this sequence constructor is
      used to construct the content of the new document node, as
      described in <a href="#constructing-complex-content"><i>5.7.1
      Constructing Complex Content</i></a>.</p>

      <p>If the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      has a <code>select</code> attribute, then the value of the
      attribute <span class="verb">must</span> be an XPath
      expression. The effect of the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      is then the same as if a single <a href=
      "#element-copy-of"><code>xsl:copy-of</code></a> instruction
      with this <code>select</code> attribute were added to the
      start of the <a title="sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a>.</p>

      <p>If the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      has no content and no <code>select</code> attribute, then an
      empty message is produced.</p>

      <p>The tree produced by the <a href=
      "#element-message"><code>xsl:message</code></a> instruction
      is not technically a <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a>. The tree has
      no URI and processors are not <span class=
      "verb">required</span> to make the tree accessible to
      applications.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>In many cases, the XML document produced using <a href=
        "#element-message"><code>xsl:message</code></a> will
        consist of a document node owning a single text node.
        However, it may contain a more complex structure.</p>
      </div>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>An implementation might implement <a href=
        "#element-message"><code>xsl:message</code></a> by popping
        up an alert box or by writing to a log file. <span>Because
        the order of execution of instructions is
        implementation-defined, the order in which such messages
        appear is not predictable.</span></p>
      </div>

      <p>The <code>terminate</code> attribute is interpreted as an
      <a title="attribute value template" href=
      "#dt-attribute-value-template">attribute value
      template</a>.</p>

      <p>If the <a title="effective value" href=
      "#dt-effective-value">effective value</a> of the
      <code>terminate</code> attribute is <code>yes</code>, then
      the <a title="processor" href="#dt-processor">processor</a>
      <span class="verb">must</span> terminate processing after
      sending the message. The default value is <code>no</code>.
      Note that because the order of evaluation of instructions is
      <a title="implementation-dependent" href=
      "#dt-implementation-dependent">implementation-dependent</a>,
      this gives no guarantee that any particular instruction will
      or will not be evaluated before processing terminates.</p>

      <p><a name="err-XTMM9000" id="err-XTMM9000"><span class=
      "error">[ERR XTMM9000]</span></a> When a transformation is
      terminated by use of <code>xsl:message
      terminate="yes"</code>, the effect is the same as when a
      <a title="non-recoverable dynamic error" href=
      "#dt-nonrec-dynamic-error">non-recoverable dynamic error</a>
      occurs during the transformation.</p>

      <div class="example">
        <div class="exampleHeader">
          <a name="d5e25672" id="d5e25672"></a>Example: Localizing
          Messages
        </div>

        <p>One convenient way to do localization is to put the
        localized information (message text, etc.) in an XML
        document, which becomes an additional input file to the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>.
        For example, suppose messages for a language
        <code><var>L</var></code> are stored in an XML file
        <code>resources/<var>L</var>.xml</code> in the form:</p>

        <div class="exampleInner">
          <pre>
&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;
</pre>
        </div>

        <p>Then a stylesheet could use the following approach to
        localize messages:</p>

        <div class="exampleInner">
          <pre>
&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;
</pre>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="extension" id="extension"></a>18 Extensibility
      and Fallback</h2>

      <p>XSLT allows two kinds of extension, extension instructions
      and extension functions.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-extension-instruction" id="dt-extension-instruction"
      title="extension instruction"></a>An <b>extension
      instruction</b> is an element within a <a title=
      "sequence constructor" href=
      "#dt-sequence-constructor">sequence constructor</a> that is
      in a namespace (not the <a title="XSLT namespace" href=
      "#dt-xslt-namespace">XSLT namespace</a>) designated as an
      extension namespace.<span class="definition">]</span></p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-extension-function" id="dt-extension-function" title=
      "extension function"></a>An <b>extension function</b> is a
      function that is available for use within an XPath <a title=
      "expression" href="#dt-expression">expression</a>, other than
      a <a title="core function" href="#dt-core-function">core
      function</a> defined in <a href="#xpath-functions">[Functions
      and Operators]</a>, an additional function defined in this
      XSLT specification, <span>a constructor function named after
      an atomic type,</span> or a <a title="stylesheet function"
      href="#dt-stylesheet-function">stylesheet function</a>
      defined using an <a href=
      "#element-function"><code>xsl:function</code></a>
      declaration.<span class="definition">]</span>.</p>

      <p>This specification does not define any mechanism for
      creating or binding implementations of <a title=
      "extension instruction" href=
      "#dt-extension-instruction">extension instructions</a> or
      <a title="extension function" href=
      "#dt-extension-function">extension functions</a>, and it is
      not <span class="verb">required</span> that implementations
      support any such mechanism. Such mechanisms, if they exist,
      are <a title="implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a>.
      Therefore, an XSLT stylesheet that <span class=
      "verb">must</span> be portable between XSLT implementations
      cannot rely on particular extensions being available. XSLT
      provides mechanisms that allow an XSLT stylesheet to
      determine whether the implementation makes particular
      extensions available, and to specify what happens if those
      extensions are not available. If an XSLT stylesheet is
      careful to make use of these mechanisms, it is possible for
      it to take advantage of extensions and still retain
      portability.</p>

      <div class="div2">
        <h3><a name="extension-functions" id=
        "extension-functions"></a>18.1 Extension Functions</h3>

        <p>The set of functions that can be called from a <a href=
        "http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</a><sup>
        <small>XP</small></sup> within an XPath <a title=
        "expression" href="#dt-expression">expression</a> may
        include one or more <a title="extension function" href=
        "#dt-extension-function">extension functions</a>. The
        <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of an extension
        function always has a non-null namespace URI.</p>

        <div class="div3">
          <h4><a name="testing-function-availability" id=
          "testing-function-availability"></a>18.1.1 Testing
          Availability of Functions</h4>

          <p>The <a href=
          "#function-function-available"><code>function-available</code></a>
          function can be used with the <code>[xsl:]use-when</code>
          attribute (see <a href="#conditional-inclusion"><i>3.12
          Conditional Element Inclusion</i></a>) to explicitly
          control how a stylesheet behaves if a particular
          extension function is not available.</p><a name=
          "function-function-available" id=
          "function-function-available"></a>

          <div class="proto">
            <code class=
            "function">function-available</code>(<code class=
            "arg">$function-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:boolean</code>
          </div>

          <div class="proto">
            <table border="0" cellpadding="0" cellspacing="0">
              <tr>
                <td valign="baseline" rowspan="2"><code class=
                "function">function-available</code>(</td>

                <td valign="baseline"><code class=
                "arg">$function-name</code></td>

                <td valign="baseline"><code class=
                "as">&#160;as&#160;</code><code class=
                "type">xs:string</code>,</td>
              </tr>

              <tr>
                <td valign="baseline"><code class=
                "arg">$arity</code></td>

                <td valign="baseline"><code class=
                "as">&#160;as&#160;</code><code class=
                "type">xs:integer</code>)<code class=
                "as">&#160;as&#160;</code><code class=
                "return-type">xs:boolean</code></td>
              </tr>
            </table>
          </div>

          <p>A function is said to be available within an XPath
          expression if it is present in the <a href=
          "http://www.w3.org/TR/xpath20/#dt-function-signature">in-scope
          functions</a><sup><small>XP</small></sup> for that
          expression (see <a href="#static-context"><i>5.4.1
          Initializing the Static Context</i></a>). Functions in
          the static context are uniquely identified by the name of
          the function (a QName) in combination with its <a title=
          "arity" href="#dt-arity">arity</a>.</p>

          <p>The value of the <code>$function-name</code> argument
          <span class="verb">must</span> be a string containing a
          <a title="lexical QName" href="#dt-lexical-qname">lexical
          QName</a>. The lexical QName is expanded into an
          <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> using the
          namespace declarations in scope for the <a title=
          "expression" href="#dt-expression">expression</a>. If the
          lexical QName is unprefixed, then the <a title=
          "standard function namespace" href=
          "#dt-standard-function-namespace">standard function
          namespace</a> is used in the expanded QName.</p>

          <p>The two-argument version of the <a href=
          "#function-function-available"><code>function-available</code></a>
          function returns true if and only if there is an
          available function whose name matches the value of the
          <code>$function-name</code> argument and whose <a title=
          "arity" href="#dt-arity">arity</a> matches the value of
          the <code>$arity</code> argument.</p>

          <p>The single-argument version of the <a href=
          "#function-function-available"><code>function-available</code></a>
          function returns true if and only if there is at least
          one available function (with some arity) whose name
          matches the value of the <code>$function-name</code>
          argument.</p>

          <p><a name="err-XTDE1400" id="err-XTDE1400"><span class=
          "error">[ERR XTDE1400]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument does not evaluate to a string
          that is a valid <a title="QName" href=
          "#dt-qname">QName</a>, or if there is no namespace
          declaration in scope for the prefix of the <a title=
          "QName" href="#dt-qname">QName</a>. If the processor is
          able to detect the error statically (for example, when
          the argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>

          <p>When <a title="backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled, the <a href=
          "#function-function-available"><code>function-available</code></a>
          function returns false in respect of a function name and
          arity for which no implementation is available (other
          than the fallback error function that raises a dynamic
          error whenever it is called). This means that it is
          possible (as in XSLT 1.0) to use logic such as the
          following to test whether a function is available before
          calling it:</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e25880" id="d5e25880"></a>Example: Calling
              an extension function with backwards-compatibility
              enabled
            </div>

            <div class="exampleInner">
              <pre>
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;
</pre>
            </div>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The fact that a function with a given name is
            available gives no guarantee that any particular call
            on the function will be successful. For example, it is
            not possible to determine the types of the arguments
            expected.</p>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>In XSLT 2.0 <span>(without backwards compatibility
            enabled)</span> a static error occurs when an XPath
            expression references a function that is not available.
            This is true even in a part of the stylesheet that uses
            <a title="forwards-compatible behavior" href=
            "#dt-forwards-compatible-behavior">forwards-compatible
            behavior</a>. Therefore, the conditional logic to test
            whether a function is available before calling it
            should normally be written in a <code>use-when</code>
            attribute (see <a href="#conditional-inclusion"><i>3.12
            Conditional Element Inclusion</i></a>).</p>
          </div>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e25903" id="d5e25903"></a>Example:
              Stylesheet portable between XSLT 1.0 and XSLT 2.0
            </div>

            <p>A stylesheet that is designed to use XSLT 2.0
            facilities when they are available, but to fall back to
            XSLT 1.0 capabilities when not, might be written using
            the code:</p>

            <div class="exampleInner">
              <pre>
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches($input, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
                          translate($in, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;
</pre>
            </div>

            <p>Here an XSLT 2.0 processor will always take the
            <a href="#element-when"><code>xsl:when</code></a>
            branch, while a 1.0 processor will follow the <a href=
            "#element-otherwise"><code>xsl:otherwise</code></a>
            branch. The single-argument version of the <a href=
            "#function-function-available"><code>function-available</code></a>
            function is used here, because that is the only version
            available in XSLT 1.0. Under the rules of XSLT 1.0, the
            call on the <code>matches</code> function is not an
            error, because it is never evaluated.</p>
          </div>

          <p>&#160;</p>

          <div class="example">
            <div class="exampleHeader">
              <a name="d5e25924" id="d5e25924"></a>Example:
              Stylesheet portable between XSLT 2.0 and a future
              version of XSLT
            </div>

            <p>A stylesheet that is designed to use facilities in
            some future XSLT version when they are available, but
            to fall back to XSLT 2.0 capabilities when not, might
            be written using code such as the following. This
            hypothesizes the availability in some future version of
            a function <code>pad</code> which pads a string to a
            fixed length with spaces:</p>

            <div class="exampleInner">
              <pre>
 &lt;xsl:value-of select="pad($input, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat($input, string-join(
                          for $i in 1 to 10 - string-length($input) 
                                                  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;
 
</pre>
            </div>

            <p>In this case the two-argument version of <a href=
            "#function-function-available"><code>function-available</code></a>
            is used, because there is no requirement for this code
            to run under XSLT 1.0.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="calling-extension-functions" id=
          "calling-extension-functions"></a>18.1.2 Calling
          Extension Functions</h4>

          <p>If the function name used in a <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</a><sup>
          <small>XP</small></sup> within an XPath <a title=
          "expression" href="#dt-expression">expression</a>
          identifies an extension function, then to evaluate the
          <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</a><sup>
          <small>XP</small></sup>, the processor will first
          evaluate each of the arguments in the <a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-FunctionCall">FunctionCall</a><sup>
          <small>XP</small></sup>. If the processor has information
          about the data types expected by the extension function,
          then it <span class="verb">may</span> perform any
          necessary type conversions between the XPath data types
          and those defined by the implementation language. If
          multiple extension functions are available with the same
          name, the processor <span class="verb">may</span> decide
          which one to invoke based on the number of arguments, the
          types of the arguments, or any other criteria. The result
          returned by the implementation is returned as the result
          of the function call, again after any necessary
          conversions between the data types of the implementation
          language and those of XPath. The details of such type
          conversions are outside the scope of this
          specification.</p>

          <p><a name="err-XTDE1420" id="err-XTDE1420"><span class=
          "error">[ERR XTDE1420]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the arguments supplied to a call on an
          extension function do not satisfy the rules defined for
          that particular extension function, or if the extension
          function reports an error, or if the result of the
          extension function cannot be converted to an XPath
          value.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Implementations may also provide mechanisms allowing
            extension functions to report recoverable dynamic
            errors, or to execute within an environment that treats
            some or all of the errors listed above as
            recoverable.</p>
          </div>

          <p><a name="err-XTDE1425" id="err-XTDE1425"><span class=
          "error">[ERR XTDE1425]</span></a> When <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled, it is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> to evaluate an extension function call if no
          implementation of the extension function is
          available.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>When backwards-compatible behavior is not enabled,
            this is a static error [XPST0017].</p>
          </div>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>There is no prohibition on calling extension
            functions that have side-effects (for example, an
            extension function that writes data to a file).
            However, the order of execution of XSLT instructions is
            not defined in this specification, so the effects of
            such functions are unpredictable.</p>
          </div>

          <p>Implementations are not <span class=
          "verb">required</span> to perform full validation of
          values returned by extension functions. It is an error
          for an extension function to return a string containing
          characters that are not permitted in XML, but the
          consequences of this error are <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          The implementation <span class="verb">may</span> raise an
          error, <span class="verb">may</span> convert the string
          to a string containing valid characters only, or
          <span class="verb">may</span> treat the invalid
          characters as if they were permitted characters.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>The ability to execute extension functions
            represents a potential security weakness, since
            untrusted stylesheets may invoke code that has
            privileged access to resources on the machine where the
            <a title="processor" href="#dt-processor">processor</a>
            executes. Implementations may therefore provide
            mechanisms that restrict the use of extension functions
            by untrusted stylesheets.</p>
          </div>

          <p>All observations in this section regarding the errors
          that can occur when invoking extension functions apply
          equally when invoking <a title="extension instruction"
          href="#dt-extension-instruction">extension
          instructions</a>.</p>
        </div>

        <div class="div3">
          <h4><a name="external-objects" id=
          "external-objects"></a>18.1.3 External Objects</h4>

          <p>An implementation <span class="verb">may</span> allow
          an extension function to return an object that does not
          have any natural representation in the <span>XDM</span>
          data model, either as an atomic value or as a node. For
          example, an extension function <code>sql:connect</code>
          might return an object that represents a connection to a
          relational database; the resulting connection object
          might be passed as an argument to calls on other
          extension functions such as <code>sql:insert</code> and
          <code>sql:select</code>.</p>

          <p>The way in which such objects are represented in the
          type system is <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          They might be represented by a completely new data type,
          or they might be mapped to existing data types such as
          <code>integer</code>, <code>string</code>, or
          <code>anyURI</code>.</p>
        </div>

        <div class="div3">
          <h4><a name="testing-type-availability" id=
          "testing-type-availability"></a>18.1.4 Testing
          Availability of Types</h4>

          <p>The <a href=
          "#function-type-available"><code>type-available</code></a>
          function can be used, for example with the
          <code>[xsl:]use-when</code> attribute (see <a href=
          "#conditional-inclusion"><i>3.12 Conditional Element
          Inclusion</i></a>), to explicitly control how a
          stylesheet behaves if a particular schema type is not
          available in the static context.</p><a name=
          "function-type-available" id=
          "function-type-available"></a>

          <div class="proto">
            <code class=
            "function">type-available</code>(<code class=
            "arg">$type-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:boolean</code>
          </div>

          <p>A schema type (that is, a simple type or a complex
          type) is said to be available within an XPath expression
          if it is a type definition that is present in the
          <a href="http://www.w3.org/TR/xpath20/#dt-is-types">in-scope
          schema types</a><sup><small>XP</small></sup> for that
          expression (see <a href="#static-context"><i>5.4.1
          Initializing the Static Context</i></a>). This includes
          built-in types, types imported using <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>,
          and extension types defined by the implementation.</p>

          <p>The value of the <code>$type-name</code> argument
          <span class="verb">must</span> be a string containing a
          <a title="lexical QName" href="#dt-lexical-qname">lexical
          QName</a>. The lexical QName is expanded into an
          <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> using the
          namespace declarations in scope for the <a title=
          "expression" href="#dt-expression">expression</a>. If the
          lexical QName is unprefixed, then the default namespace
          is used in the expanded QName.</p>

          <p>The function returns true if and only if there is an
          available type whose name matches the value of the
          <code>$type-name</code> argument.</p>

          <p><a name="err-XTDE1428" id="err-XTDE1428"><span class=
          "error">[ERR XTDE1428]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument does not evaluate to a string
          that is a valid <a title="QName" href=
          "#dt-qname">QName</a>, or if there is no namespace
          declaration in scope for the prefix of the <a title=
          "QName" href="#dt-qname">QName</a>. If the processor is
          able to detect the error statically (for example, when
          the argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="extension-instruction" id=
        "extension-instruction"></a>18.2 Extension
        Instructions</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-extension-namespace" id="dt-extension-namespace" title=
        "extension namespace"></a>The <a title=
        "extension instruction" href=
        "#dt-extension-instruction">extension instruction</a>
        mechanism allows namespaces to be designated as
        <b>extension namespaces</b>. When a namespace is designated
        as an extension namespace and an element with a name from
        that namespace occurs in a <a title="sequence constructor"
        href="#dt-sequence-constructor">sequence constructor</a>,
        then the element is treated as an <a title="instruction"
        href="#dt-instruction">instruction</a> rather than as a
        <a title="literal result element" href=
        "#dt-literal-result-element">literal result
        element</a>.<span class="definition">]</span> The namespace
        determines the semantics of the instruction.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Since an element that is a child of an <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element is not occurring <em>in a <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a></em>,
          <a title="user-defined data element" href=
          "#dt-data-element">user-defined data elements</a> (see
          <a href="#user-defined-top-level"><i>3.6.2 User-defined
          Data Elements</i></a>) are not extension elements as
          defined here, and nothing in this section applies to
          them.</p>
        </div>

        <div class="div3">
          <h4><a name="designating-extension-namespace" id=
          "designating-extension-namespace"></a>18.2.1 Designating
          an Extension Namespace</h4>

          <p>A namespace is designated as an extension namespace by
          using an <code>[xsl:]extension-element-prefixes</code>
          attribute on an element in the stylesheet (see <a href=
          "#standard-attributes"><i>3.5 Standard
          Attributes</i></a>). The attribute <span class=
          "verb">must</span> be in the XSLT namespace only if its
          parent element is <em>not</em> in the XSLT namespace. The
          value of the attribute is a whitespace-separated list of
          namespace prefixes. The namespace bound to each of the
          prefixes is designated as an extension namespace.</p>

          <p>The default namespace (as declared by
          <code>xmlns</code>) may be designated as an extension
          namespace by including <code>#default</code> in the list
          of namespace prefixes.</p>

          <p><a name="err-XTSE1430" id="err-XTSE1430"><span class=
          "error">[ERR XTSE1430]</span></a> It is a <a title=
          "static error" href="#dt-static-error">static error</a>
          if there is no namespace bound to the prefix on the
          element bearing the
          <code>[xsl:]extension-element-prefixes</code> attribute
          <span>or, when <code>#default</code> is specified, if
          there is no default namespace</span>.</p>

          <p>The designation of a namespace as an extension
          namespace is effective for the element bearing the
          <code>[xsl:]extension-element-prefixes</code> attribute
          and for all descendants of that element within the same
          stylesheet module.</p>
        </div>

        <div class="div3">
          <h4><a name="testing-instruction-available" id=
          "testing-instruction-available"></a>18.2.2 Testing
          Availability of Instructions</h4>

          <p>The <a href=
          "#function-element-available"><code>element-available</code></a>
          function can be used with the <a href=
          "#element-choose"><code>xsl:choose</code></a> and
          <a href="#element-if"><code>xsl:if</code></a>
          instructions<span>, or with the
          <code>[xsl:]use-when</code> attribute (see <a href=
          "#conditional-inclusion"><i>3.12 Conditional Element
          Inclusion</i></a>) to explicitly control how a stylesheet
          behaves when a particular XSLT instruction or extension
          instruction is (or is not) available.</span></p><a name=
          "function-element-available" id=
          "function-element-available"></a>

          <div class="proto">
            <code class=
            "function">element-available</code>(<code class=
            "arg">$element-name</code><code class=
            "as">&#160;as&#160;</code><code class=
            "type">xs:string</code>)<code class=
            "as">&#160;as&#160;</code><code class=
            "return-type">xs:boolean</code>
          </div>

          <p>The value of the <code>$element-name</code> argument
          <span class="verb">must</span> be a string containing a
          <a title="QName" href="#dt-qname">QName</a>. The
          <a title="QName" href="#dt-qname">QName</a> is expanded
          into an <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> using the
          namespace declarations in scope for the <a title=
          "expression" href="#dt-expression">expression</a>. If
          there is a default namespace in scope, then it is used to
          expand an unprefixed <a title="QName" href=
          "#dt-qname">QName</a>. The <a href=
          "#function-element-available"><code>element-available</code></a>
          function returns true if and only if the <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> is the name of an
          <a title="instruction" href=
          "#dt-instruction">instruction</a>. If the <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> has a namespace
          URI equal to the <a title="XSLT namespace" href=
          "#dt-xslt-namespace">XSLT namespace</a> URI, then it
          refers to an element defined by XSLT. Otherwise, it
          refers to an <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>. If
          the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> has a null
          namespace URI, the <a href=
          "#function-element-available"><code>element-available</code></a>
          function will return false.</p>

          <p><a name="err-XTDE1440" id="err-XTDE1440"><span class=
          "error">[ERR XTDE1440]</span></a> It is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument does not evaluate to a string
          that is a valid <a title="QName" href=
          "#dt-qname">QName</a>, or if there is no namespace
          declaration in scope for the prefix of the <a title=
          "QName" href="#dt-qname">QName</a>. If the processor is
          able to detect the error statically (for example, when
          the argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>

          <p>If the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> is in the
          <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, the function returns true if and only if
          the expanded QName is the name of an <a title=
          "XSLT instruction" href="#dt-xslt-instruction">XSLT
          instruction</a>, that is, an <a title="XSLT element"
          href="#dt-xslt-element">XSLT element</a> whose syntax
          summary in this specification classifies it as an
          <a title="instruction" href=
          "#dt-instruction">instruction</a>.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Although the result of applying this function to a
            name in the XSLT namespace when using a conformant XSLT
            2.0 processor is entirely predictable, the function is
            useful in cases where the stylesheet might be executing
            under a processor that implements some other version of
            XSLT with different rules.</p>
          </div>

          <p>If the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> is not in the
          <a title="XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, the function returns true if and only if
          the processor has an implementation available of an
          <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>
          with the given expanded QName. This applies whether or
          not the namespace has been designated as an <a title=
          "extension namespace" href=
          "#dt-extension-namespace">extension namespace</a>.</p>

          <p>If the processor does not have an implementation of a
          particular extension instruction available, and such an
          extension instruction is evaluated, then the processor
          <span class="verb">must</span> perform fallback for the
          element as specified in <a href="#fallback"><i>18.2.3
          Fallback</i></a>. An implementation <span class=
          "verb">must not</span> signal an error merely because the
          stylesheet contains an extension instruction for which no
          implementation is available.</p>
        </div>

        <div class="div3">
          <h4><a name="fallback" id="fallback"></a>18.2.3
          Fallback</h4>

          <p class="element-syntax"><a name="element-fallback" id=
          "element-fallback"></a><code>&lt;!-- Category:
          instruction --&gt;<br />
          &lt;xsl:fallback&gt;<br />
          &#160;&#160;&lt;!-- Content:
          <var>sequence-constructor</var> --&gt;<br />
          &lt;/xsl:fallback&gt;</code></p>

          <p>The content of an <a href=
          "#element-fallback"><code>xsl:fallback</code></a> element
          is a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, and
          when performing fallback, the value returned by the
          <a href="#element-fallback"><code>xsl:fallback</code></a>
          element is the result of evaluating this sequence
          constructor.</p>

          <p>When not performing fallback, evaluating an <a href=
          "#element-fallback"><code>xsl:fallback</code></a> element
          returns an empty sequence: the content of the <a href=
          "#element-fallback"><code>xsl:fallback</code></a> element
          is ignored.</p>

          <p>There are two situations where a <a title="processor"
          href="#dt-processor">processor</a> performs fallback:
          when an extension instruction that is not available is
          evaluated, and when an instruction in the XSLT namespace,
          that is not defined in XSLT 2.0, is evaluated within a
          region of the stylesheet for which <a title=
          "forwards-compatible behavior" href=
          "#dt-forwards-compatible-behavior">forwards compatible
          behavior</a> is enabled.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>Fallback processing is not invoked in other
            situations, for example it is not invoked when an XPath
            expression uses unrecognized syntax or contains a call
            to an unknown function. To handle such situations
            dynamically, the stylesheet should call functions such
            as <a href=
            "#function-system-property"><code>system-property</code></a>
            and <a href=
            "#function-function-available"><code>function-available</code></a>
            to decide what capabilities are available.</p>
          </div>

          <p><a name="err-XTDE1450" id="err-XTDE1450"><span class=
          "error">[ERR XTDE1450]</span></a> When a <a title=
          "processor" href="#dt-processor">processor</a> performs
          fallback for an <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>
          that is not recognized, if the instruction element has
          one or more <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children, then the content of each of the <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children <span class="verb">must</span> be evaluated; it
          is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if it has no <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children.</p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>This is different from the situation with
            unrecognized <a title="XSLT element" href=
            "#dt-xslt-element">XSLT elements</a>. As explained in
            <a href="#forwards"><i>3.9 Forwards-Compatible
            Processing</i></a>, an unrecognized XSLT element
            appearing within a <a title="sequence constructor"
            href="#dt-sequence-constructor">sequence
            constructor</a> is a static error unless (a) <a title=
            "forwards-compatible behavior" href=
            "#dt-forwards-compatible-behavior">forwards-compatible
            behavior</a> is enabled, and (b) the instruction has an
            <a href=
            "#element-fallback"><code>xsl:fallback</code></a>
            child.</p>
          </div>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="result-trees" id="result-trees"></a>19 Final
      Result Trees</h2>

      <p>The output of a transformation is a set of
      <span>one</span> or more <a title="final result tree" href=
      "#dt-final-result-tree">final result trees</a>.</p>

      <p>A <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a> can be created
      explicitly, by evaluating an <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      instruction. <span>As explained in <a href=
      "#executing-a-transformation"><i>2.4 Executing a
      Transformation</i></a>,</span> a final result tree is also
      created implicitly if no <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      instruction is evaluated, or if the result of evaluating the
      <a title="initial template" href=
      "#dt-initial-template">initial template</a> is a non-empty
      sequence.</p>

      <p>The way in which a <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a> is delivered to
      an application is <a title="implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a>.</p>

      <p>Serialization of <a title="final result tree" href=
      "#dt-final-result-tree">final result trees</a> is described
      further in <a href="#serialization"><i>20
      Serialization</i></a></p>

      <div class="div2">
        <h3><a name="creating-result-trees" id=
        "creating-result-trees"></a>19.1 Creating Final Result
        Trees</h3>

        <p class="element-syntax"><a name="element-result-document"
        id="element-result-document"></a><code>&lt;!-- Category:
        instruction --&gt;<br />
        &lt;xsl:result-document<br />
        &#160;&#160;format? = { <var>qname</var> }<br />
        &#160;&#160;href? = { <var>uri-reference</var> }<br />
        &#160;&#160;validation? = "strict" | "lax" | "preserve" |
        "strip"<br />
        &#160;&#160;type? = <var>qname</var><br />
        &#160;&#160;method? = { "xml" | "html" | "xhtml" | "text" |
        <var>qname-but-not-ncname</var> }<br />
        &#160;&#160;byte-order-mark? = { "yes" | "no" }<br />
        &#160;&#160;cdata-section-elements? = { <var>qnames</var>
        }<br />
        &#160;&#160;doctype-public? = { <var>string</var> }<br />
        &#160;&#160;doctype-system? = { <var>string</var> }<br />
        &#160;&#160;encoding? = { <var>string</var> }<br />
        &#160;&#160;escape-uri-attributes? = { "yes" | "no" }<br />
        &#160;&#160;include-content-type? = { "yes" | "no" }<br />
        &#160;&#160;indent? = { "yes" | "no" }<br />
        &#160;&#160;media-type? = { <var>string</var> }<br />
        &#160;&#160;normalization-form? = { "NFC" | "NFD" | "NFKC"
        | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var>
        }<br />
        &#160;&#160;omit-xml-declaration? = { "yes" | "no" }<br />
        &#160;&#160;standalone? = { "yes" | "no" | "omit" }<br />
        &#160;&#160;undeclare-prefixes? = { "yes" | "no" }<br />
        &#160;&#160;use-character-maps? = <var>qnames</var><br />
        &#160;&#160;output-version? = { <var>nmtoken</var>
        }&gt;<br />
        &#160;&#160;&lt;!-- Content:
        <var>sequence-constructor</var> --&gt;<br />
        &lt;/xsl:result-document&gt;</code></p>

        <p>The <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction is used to create a <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a>. The content of the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        element is a <a title="sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> for the
        children of the document node of the tree. A document node
        is created, and the sequence obtained by evaluating the
        sequence constructor is used to construct the content of
        the document, as described in <a href=
        "#constructing-complex-content"><i>5.7.1 Constructing
        Complex Content</i></a>. The tree rooted at this document
        node forms the final result tree.</p>

        <p>The <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction defines the URI of the result tree, and may
        optionally specify the output format to be used for
        serializing this tree.</p>

        <p>The <span><a title="effective value" href=
        "#dt-effective-value">effective value</a></span> of the
        <code>format</code> attribute, if specified, <span class=
        "verb">must</span> be a <a title="lexical QName" href=
        "#dt-lexical-qname">lexical QName</a>. The QName is
        expanded using the namespace declarations in scope for the
        <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        element. The <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> <span class=
        "verb">must</span> match the expanded QName of a named
        <a title="output definition" href=
        "#dt-output-definition">output definition</a> in the
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>.
        This identifies the <a href=
        "#element-output"><code>xsl:output</code></a> declaration
        that will control the serialization of the <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a> (see <a href="#serialization"><i>20
        Serialization</i></a>), if the result tree is serialized.
        If the <code>format</code> attribute is omitted, the
        unnamed <a title="output definition" href=
        "#dt-output-definition">output definition</a> is used to
        control serialization of the result tree.</p>

        <p><a name="err-XTDE1460" id="err-XTDE1460"><span class=
        "error">[ERR XTDE1460]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>format</code> attribute is not a valid <a title=
        "lexical QName" href="#dt-lexical-qname">lexical QName</a>,
        or if it does not match the <a title="expanded-QName" href=
        "#dt-expanded-qname">expanded-QName</a> of an <a title=
        "output definition" href="#dt-output-definition">output
        definition</a> in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>. If the processor is able
        to detect the error statically (for example, when the
        <code>format</code> attribute contains no curly brackets),
        then the processor <span class="verb">may</span> optionally
        signal this as a <a title="static error" href=
        "#dt-static-error">static error</a>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The only way to select the unnamed <a title=
          "output definition" href="#dt-output-definition">output
          definition</a> is to omit the <code>format</code>
          attribute.</p>
        </div>

        <p>The attributes <code>method</code>,
        <code>byte-order-mark</code>
        <code>cdata-section-elements</code>,
        <code>doctype-public</code>, <code>doctype-system</code>,
        <code>encoding</code>, <code>escape-uri-attributes</code>,
        <code>indent</code>, <code>media-type</code>,
        <code>normalization-form</code>,
        <code>omit-xml-declaration</code>, <code>standalone</code>,
        <code>undeclare-prefixes</code>,
        <code>use-character-maps</code>, and
        <code>output-version</code> may be used to override
        attributes defined in the selected <a title=
        "output definition" href="#dt-output-definition">output
        definition</a>.</p>

        <p>With the exception of <code>use-character-maps</code>,
        these attributes are all defined as <a title=
        "attribute value template" href=
        "#dt-attribute-value-template">attribute value
        templates</a>, so their values may be set dynamically. For
        any of these attributes that is present on the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction, the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the attribute
        overrides or supplements the corresponding value from the
        output definition. This works in the same way as when one
        <a href="#element-output"><code>xsl:output</code></a>
        declaration overrides another:</p>

        <ul>
          <li>
            <p>In the case of <code>cdata-section-elements</code>,
            the value of the serialization parameter is the union
            of the expanded names of the elements named in this
            instruction and the elements named in the selected
            output definition;</p>
          </li>

          <li>
            <p>In the case of <code>use-character-maps</code>, the
            character maps referenced in this instruction
            supplement and take precedence over those defined in
            the selected output definition;</p>
          </li>

          <li>
            <p>In all other cases, the effective value of an
            attribute actually present on this instruction takes
            precedence over the value defined in the selected
            output definition.</p>
          </li>
        </ul>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>In the case of the attributes <code>method</code>,
          <code>cdata-section-elements</code>, <span>and
          <code>use-character-maps</code>,</span> the <a title=
          "effective value" href="#dt-effective-value">effective
          value</a> of the attribute contains one or more lexical
          QNames. The prefix in such a QName is expanded using the
          in-scope namespaces for the
          <code>xsl:result-document</code> element. In the case of
          <code>cdata-section-elements</code>, an unprefixed
          element name is expanded using the default namespace.</p>
        </div>

        <p>The <code>output-version</code> attribute on the
        <a href="#element-result-document"><code>xsl:result-document</code></a>
        instruction overrides the <code>version</code> attribute on
        <a href="#element-output"><code>xsl:output</code></a> (it
        has been renamed because <code>version</code> is available
        with a different meaning as a standard attribute: see
        <a href="#standard-attributes"><i>3.5 Standard
        Attributes</i></a>). In all other cases, attributes
        correspond if they have the same name.</p>

        <p>There are some serialization parameters that apply to
        some output methods but not to others. For example, the
        <code>indent</code> attribute has no effect on the
        <code>text</code> output method. If a value is supplied for
        an attribute that is inapplicable to the output method, its
        value is <span>not passed to the serializer</span>. The
        processor <span class="verb">may</span> validate the value
        of such an attribute, but is not <span class=
        "verb">required</span> to do so.</p>

        <p>The <code>href</code> attribute is optional. The default
        value is the zero-length string. The <a title=
        "effective value" href="#dt-effective-value">effective
        value</a> of the attribute <span class="verb">must</span>
        be a <a title="URI Reference" href="#dt-uri-reference">URI
        Reference</a>, which may be absolute or relative. There
        <span class="verb">may</span> be <a title=
        "implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        restrictions on the form of absolute URI that may be used,
        but the implementation is not <span class=
        "verb">required</span> to enforce any restrictions. Any
        legal relative URI <span class="verb">must</span> be
        accepted. Note that the zero-length string is a legal
        relative URI.</p>

        <p>The base URI of the document node at the root of the
        <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> is based on
        the <a title="effective value" href=
        "#dt-effective-value">effective value</a> of the
        <code>href</code> attribute. If the <a title=
        "effective value" href="#dt-effective-value">effective
        value</a> is a relative URI, then it is resolved relative
        to the <a title="base output URI" href=
        "#dt-base-output-uri">base output URI</a>. If the
        implementation provides an API to access final result
        trees, then it <span class="verb">must</span> allow a final
        result tree to be identified by means of this base URI.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The base URI of the <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a> is not
          <span>necessarily</span> the same thing as the URI of its
          serialized representation on disk, if any. For example, a
          server (or browser client) might store final result trees
          only in memory, or in an internal disk cache. As long as
          <span>the processor</span> satisfies requests for those
          URIs, it is irrelevant where they are actually written on
          disk, if at all.</p>
        </div>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>It will often be the case that one <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> contains links to another final result
          tree produced during the same transformation, in the form
          of a relative URI. The mechanism of associating a URI
          with a final result tree has been chosen to allow the
          integrity of such links to be preserved when the trees
          are serialized.</p>

          <p>As well as being potentially significant in any API
          that provides access to final result trees, the base URI
          of the new document node is relevant if the final result
          tree, rather than being serialized, is supplied as input
          to a further transformation.</p>
        </div>

        <p>The optional attributes <code>type</code> and
        <code>validation</code> may be used on the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction to validate the contents of the new document,
        and to determine the <a title="type annotation" href=
        "#dt-annotation">type annotation</a> that elements and
        attributes within the <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> will carry.
        The permitted values and their semantics are described in
        <a href="#validating-document-nodes"><i>19.2.2 Validating
        Document Nodes</i></a>.</p>

        <p>A <a title="processor" href=
        "#dt-processor">processor</a> <span class="verb">may</span>
        allow a <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> to be
        serialized. Serialization is described in <a href=
        "#serialization"><i>20 Serialization</i></a>. However, an
        implementation (for example, a <a title="processor" href=
        "#dt-processor">processor</a> running in an environment
        with no access to writable filestore) is not <span class=
        "verb">required</span> to support the serialization of
        <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a>. An
        implementation that does not support the serialization of
        final result trees <span class="verb">may</span> ignore the
        <code>format</code> attribute <span>and the serialization
        attributes</span>. Such an implementation <span class=
        "verb">must</span> provide the application with some means
        of access to the (un-serialized) result tree, using its URI
        to identify it.</p>

        <p>Implementations may provide additional mechanisms,
        outside the scope of this specification, for defining the
        way in which <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a> are
        processed. Such mechanisms <span class="verb">may</span>
        make use of the XSLT-defined attributes on the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        and/or <a href=
        "#element-output"><code>xsl:output</code></a> elements, or
        they <span class="verb">may</span> use additional elements
        or attributes in an <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        namespace.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e27003" id="d5e27003"></a>Example: Multiple
            Result Documents
          </div>

          <p>The following example takes an XHTML document as
          input, and breaks it up so that the text following each
          &lt;h1&gt; element is included in a separate document. A
          new document <code>toc.html</code> is constructed to act
          as an index:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:stylesheet
        version="2.0"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
        xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
        
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
            doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
            doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;        
         
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" format="toc-format" validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;&lt;a href="section{position()}.html"&gt;&lt;xsl:value-of select="."/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;         
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;
</pre>
          </div>
        </div>

        <p>There are restrictions on the use of the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction, designed to ensure that the results are fully
        interoperable even when processors optimize the sequence in
        which instructions are evaluated. Informally, the
        restriction is that the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction can only be used while writing a final result
        tree, not while writing to a temporary tree or a sequence.
        This restriction is defined formally as follows.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-output-state" id="dt-output-state" title=
        "output state"></a>Each instruction in the <a title=
        "stylesheet" href="#dt-stylesheet">stylesheet</a> is
        evaluated in one of two possible <b>output states</b>:
        <a title="final output state" href=
        "#dt-final-output-state">final output state</a> or
        <a title="temporary output state" href=
        "#dt-temporary-output-state">temporary output
        state</a><span class="definition">]</span>.</p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-final-output-state" id="dt-final-output-state" title=
        "final output state"></a>The first of the two <a title=
        "output state" href="#dt-output-state">output states</a> is
        called <b>final output</b> state. This state applies when
        instructions are writing to a <a title="final result tree"
        href="#dt-final-result-tree">final result
        tree</a>.<span class="definition">]</span></p>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-temporary-output-state" id="dt-temporary-output-state"
        title="temporary output state"></a>The second of the two
        <a title="output state" href="#dt-output-state">output
        states</a> is called <b>temporary output</b> state. This
        state applies when instructions are writing to a <a title=
        "temporary tree" href="#dt-temporary-tree">temporary
        tree</a> or any other non-final destination.<span class=
        "definition">]</span></p>

        <p>The instructions in the <a title="initial template"
        href="#dt-initial-template">initial template</a> are
        evaluated in <a title="final output state" href=
        "#dt-final-output-state">final output state</a>. An
        instruction is evaluated in the same <a title=
        "output state" href="#dt-output-state">output state</a> as
        its calling instruction, except that <a href=
        "#element-variable"><code>xsl:variable</code></a>, <a href=
        "#element-param"><code>xsl:param</code></a>, <a href=
        "#element-with-param"><code>xsl:with-param</code></a>,
        <a href=
        "#element-attribute"><code>xsl:attribute</code></a>,
        <a href="#element-comment"><code>xsl:comment</code></a>,
        <a href=
        "#element-processing-instruction"><code>xsl:processing-instruction</code></a>,
        <a href=
        "#element-namespace"><code>xsl:namespace</code></a>,
        <a href="#element-value-of"><code>xsl:value-of</code></a>,
        <a href="#element-function"><code>xsl:function</code></a>,
        <a href="#element-key"><code>xsl:key</code></a>, <a href=
        "#element-sort"><code>xsl:sort</code></a>, and <a href=
        "#element-message"><code>xsl:message</code></a> always
        evaluate the instructions in their contained <a title=
        "sequence constructor" href=
        "#dt-sequence-constructor">sequence constructor</a> in
        <a title="temporary output state" href=
        "#dt-temporary-output-state">temporary output
        state</a>.</p>

        <p><a name="err-XTDE1480" id="err-XTDE1480"><span class=
        "error">[ERR XTDE1480]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> to evaluate the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction in <a title="temporary output state" href=
        "#dt-temporary-output-state">temporary output
        state</a>.</p>

        <p><a name="err-XTDE1490" id="err-XTDE1490"><span class=
        "error">[ERR XTDE1490]</span></a> It is a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> for a transformation to generate two or more
        <a title="final result tree" href=
        "#dt-final-result-tree">final result trees</a> with the
        same URI.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Note, this means that it is an error to evaluate more
          than one <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction that omits the <code>href</code> attribute,
          or to evaluate any <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction that omits the <code>href</code> attribute if
          an initial <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a> is created
          implicitly.</p>
        </div>

        <p>Technically, the result of evaluating the <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction is an empty sequence. This means it does not
        contribute any nodes to the result of the
        <span>sequence</span> constructor it is part of.</p>

        <p><a name="err-XTRE1495" id="err-XTRE1495"><span class=
        "error">[ERR XTRE1495]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> for a
        transformation to generate two or more <a title=
        "final result tree" href="#dt-final-result-tree">final
        result trees</a> with URIs that identify the same physical
        resource. The <a title="optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is <a title="implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>,
        since it may be impossible for the processor to detect the
        error.</p>

        <p><a name="err-XTRE1500" id="err-XTRE1500"><span class=
        "error">[ERR XTRE1500]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> for a
        <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>
        to write to an external resource and read from the same
        resource during a single transformation, whether or not the
        same URI is used to access the resource in both cases. The
        <a title="optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is <a title="implementation-dependent" href=
        "#dt-implementation-dependent">implementation-dependent</a>:
        implementations are not <span class="verb">required</span>
        to detect the error condition. <span>Note that if the error
        is not detected, it is undefined whether the document that
        is read from the resource reflects its state before or
        after the result tree is written.</span></p>
      </div>

      <div class="div2">
        <h3><a name="validation" id="validation"></a>19.2
        Validation</h3>

        <p>It is possible to control the <a title="type annotation"
        href="#dt-annotation">type annotation</a> applied to
        individual element and attribute nodes as they are
        constructed. This is done using the <code>type</code> and
        <code>validation</code> attributes of the <a href=
        "#element-element"><code>xsl:element</code></a>, <a href=
        "#element-attribute"><code>xsl:attribute</code></a>,
        <a href="#element-copy"><code>xsl:copy</code></a>, <a href=
        "#element-copy-of"><code>xsl:copy-of</code></a>,
        <span><a href=
        "#element-document"><code>xsl:document</code></a></span>,
        and <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instructions, or the <code>xsl:type</code> and
        <code>xsl:validation</code> attributes of a <a title=
        "literal result element" href=
        "#dt-literal-result-element">literal result
        element</a>.</p>

        <p>The <code>[xsl:]type</code> attribute is used to request
        validation of an element or attribute against a specific
        simple or complex type defined in a schema. The
        <code>[xsl:]validation</code> attribute is used to request
        validation against the global element or attribute
        declaration whose name matches the name of the element or
        attribute being validated.</p>

        <p>The <code>[xsl:]type</code> and
        <code>[xsl:]validation</code> attributes are mutually
        exclusive. Both are optional, but if one is present then
        the other <span class="verb">must</span> be omitted. If
        both attributes are omitted, the effect is the same as
        specifying the <code>validation</code> attribute with the
        value specified in the <code>default-validation</code>
        attribute of the containing <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element; if this is not specified, the effect is the same
        as specifying <code>validation="strip"</code>.</p>

        <p><a name="err-XTSE1505" id="err-XTSE1505"><span class=
        "error">[ERR XTSE1505]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        both the <code>[xsl:]type</code> and
        <code>[xsl:]validation</code> attributes are present on the
        <a href="#element-element"><code>xsl:element</code></a>,
        <a href=
        "#element-attribute"><code>xsl:attribute</code></a>,
        <a href="#element-copy"><code>xsl:copy</code></a>, <a href=
        "#element-copy-of"><code>xsl:copy-of</code></a>,
        <span><a href=
        "#element-document"><code>xsl:document</code></a></span>,
        or <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instructions, or on a <a title="literal result element"
        href="#dt-literal-result-element">literal result
        element</a>.</p>

        <p>The detailed rules for validation vary depending on the
        kind of node being validated. The rules for element and
        attribute nodes are given in <a href=
        "#validating-constructed-nodes"><i>19.2.1 Validating
        Constructed Elements and Attributes</i></a>, while those
        for document nodes are given in <a href=
        "#validating-document-nodes"><i>19.2.2 Validating Document
        Nodes</i></a>.</p>

        <div class="div3">
          <h4><a name="validating-constructed-nodes" id=
          "validating-constructed-nodes"></a>19.2.1 Validating
          Constructed Elements and Attributes</h4>

          <div class="div4">
            <h5><a name="validating-using-validation-attribute" id=
            "validating-using-validation-attribute"></a>19.2.1.1
            Validation using the <code>[xsl:]validation</code>
            Attribute</h5>

            <p>The <code>[xsl:]validation</code> attribute defines
            the validation action to be taken. It determines not
            only the <a title="type annotation" href=
            "#dt-annotation">type annotation</a> of the node that
            is constructed by the relevant instruction itself, but
            also the type annotations of all element and attribute
            nodes that have the constructed node as an ancestor.
            Conceptually, the validation requested for a child
            element or attribute node is applied before the
            validation requested for its parent element. For
            example, if the instruction that constructs a child
            element specifies <code>validation="strict"</code>,
            this will cause the child element to be checked against
            an element declaration, but if the instruction that
            constructs its parent element specifies
            <code>validation="strip"</code>, then the final effect
            will be that the child node is annotated as
            <span><code>xs:untyped</code></span>.</p>

            <p>In the paragraphs below, the term <em>contained
            nodes</em> means the elements and attributes that have
            the newly constructed node as an ancestor.</p>

            <ul>
              <li>
                <p>The value <code>strip</code> indicates that the
                new node and each of the contained nodes will have
                the <a title="type annotation" href=
                "#dt-annotation">type annotation</a>
                <span><code>xs:untyped</code></span> if it is an
                element, or
                <span><code>xs:untypedAtomic</code></span> if it is
                an attribute. Any previous type annotation present
                on a contained element or attribute node (for
                example, a type annotation that is present on an
                element copied from a source document) is also
                replaced by <span><code>xs:untyped</code></span> or
                <span><code>xs:untypedAtomic</code></span> as
                appropriate. <span>The typed value of the node is
                changed to be the same as its string value, as an
                instance of <code>xs:untypedAtomic</code>. In the
                case of elements the <code>nilled</code> property
                is set to <code>false</code>. The values of the
                <code>is-id</code> and <code>is-idrefs</code>
                properties are unchanged.</span> Schema validation
                is not invoked.</p>
              </li>

              <li>
                <p>The value <code>preserve</code> indicates that
                nodes that are copied will retain their <a title=
                "type annotation" href="#dt-annotation">type
                annotations</a>, but nodes whose content is newly
                constructed will be annotated as
                <code>xs:anyType</code> in the case of elements, or
                <span><code>xs:untypedAtomic</code></span> in the
                case of attributes. Schema validation is not
                invoked. The detailed effect depends on the
                instruction:</p>

                <ul>
                  <li>
                    <p>In the case of <a href=
                    "#element-element"><code>xsl:element</code></a>
                    and literal result elements, the new element
                    has a <a title="type annotation" href=
                    "#dt-annotation">type annotation</a> of
                    <code>xs:anyType</code>, and the type
                    annotations of contained nodes are retained
                    unchanged.</p>
                  </li>

                  <li>
                    <p>In the case of <a href=
                    "#element-attribute"><code>xsl:attribute</code></a>,
                    the effect is exactly the same as specifying
                    <code>validation="strip"</code>: that is, the
                    new attribute will have the type annotation
                    <span><code>xs:untypedAtomic</code></span>.</p>
                  </li>

                  <li>
                    <p>In the case of <a href=
                    "#element-copy-of"><code>xsl:copy-of</code></a>,
                    all the nodes that are copied will retain their
                    type annotations unchanged.</p>
                  </li>

                  <li>
                    <p>In the case of <a href=
                    "#element-copy"><code>xsl:copy</code></a>, the
                    effect depends on the kind of node being
                    copied.</p>

                    <ol class="enumar">
                      <li>
                        <p>Where the node being copied is an
                        attribute, the copied attribute will retain
                        its <a title="type annotation" href=
                        "#dt-annotation">type annotation</a>.</p>
                      </li>

                      <li>
                        <p>Where the node being copied is an
                        element, the copied element will have a
                        <a title="type annotation" href=
                        "#dt-annotation">type annotation</a> of
                        <span><code>xs:anyType</code></span>
                        (because this instruction does not copy the
                        content of the element, it would be wrong
                        to assume that the type is unchanged); but
                        any contained nodes will have their type
                        annotations retained in the same way as
                        with <a href=
                        "#element-element"><code>xsl:element</code></a>.</p>
                      </li>
                    </ol>
                  </li>
                </ul>
              </li>

              <li>
                <p>The value <code>strict</code> indicates that
                <a title="type annotation" href=
                "#dt-annotation">type annotations</a> are
                established by performing strict schema validity
                assessment on the element or attribute node created
                by this instruction as follows:</p>

                <ul>
                  <li>
                    <p>In the case of an element, <span>a
                    top-level</span> element declaration is
                    identified whose local name and namespace (if
                    any) match the name of the element, and
                    schema-validity assessment is carried out
                    according to the rules defined in <a href=
                    "#xmlschema-1">[XML Schema Part 1]</a> (section
                    3.3.4 "Element Declaration Validation Rules",
                    validation rule "Schema-Validity Assessment
                    (Element)", clauses 1.1 and 2<span>, using the
                    top-level element declaration as the
                    "declaration stipulated by the processor",
                    which is mentioned in clause 1.1.1.1</span>).
                    The element is considered valid if the result
                    of the schema validity assessment is a PSVI in
                    which the relevant element node has a
                    <code>validity</code> property whose value is
                    <code>valid</code>. If <span>there is no
                    matching element declaration, or if</span> the
                    element is not considered valid, the
                    transformation fails <span class="error">[see
                    <a href="#err-XTTE1510">ERR
                    XTTE1510</a>]</span>, <span class="error">[see
                    <a href="#err-XTTE1512">ERR
                    XTTE1512</a>]</span>. In effect this means that
                    the element being validated <span class=
                    "verb">must</span> be declared using a
                    top-level declaration in the schema, and
                    <span class="verb">must</span> conform to its
                    declaration. The process of validation applies
                    recursively to contained elements and
                    attributes to the extent required by the schema
                    definition.</p>

                    <div class="note">
                      <p class="prefix"><b>Note:</b></p>

                      <p>It is not an error if the identified type
                      definition is a simple type, although
                      <a href="#xmlschema-1">[XML Schema Part
                      1]</a> does not define explicitly that this
                      case is permitted.</p>
                    </div>
                  </li>

                  <li>
                    <p>In the case of an attribute, <span>a
                    top-level</span> attribute declaration is
                    identified whose local name and namespace (if
                    any) match the name of the attribute, and
                    schema-validity assessment is carried out
                    according to the rules defined in <a href=
                    "#xmlschema-1">[XML Schema Part 1]</a> (section
                    3.2.4 "Attribute Declaration Validation Rules",
                    validation rule "Schema-Validity Assessment
                    (Attribute)"). The attribute is considered
                    valid if the result of the schema validity
                    assessment is a PSVI in which the relevant
                    attribute node has a <code>validity</code>
                    property whose value is <code>valid</code>. If
                    the attribute is not considered valid, the
                    transformation fails <span><span class=
                    "error">[see <a href="#err-XTTE1510">ERR
                    XTTE1510</a>]</span></span>. In effect this
                    means that the attribute being validated
                    <span class="verb">must</span> be declared
                    using a top-level declaration in the schema,
                    and <span class="verb">must</span> conform to
                    its declaration.</p>
                  </li>

                  <li>
                    <p>The schema components used to validate an
                    element or attribute may be located in any way
                    <span>described</span> by <a href=
                    "#xmlschema-1">[XML Schema Part 1]</a> (see
                    section 4.3.2, <em>How schema documents are
                    located on the Web</em>). The components in the
                    schema constructed from the synthetic schema
                    document (see <a href="#import-schema"><i>3.14
                    Importing Schema Components</i></a>) will
                    always be available for validating constructed
                    nodes; if additional schema components are
                    needed, they <span class="verb">may</span>
                    <span>be located in other ways, for example
                    implicitly from knowledge of the namespace in
                    which the elements and attributes appear, or
                    using the <code>xsi:schemaLocation</code>
                    attribute of elements within the tree being
                    validated.</span></p>
                  </li>

                  <li>
                    <p>If no validation is performed for a node,
                    which can happen when the schema specifies
                    <code>lax</code> or <code>skip</code>
                    validation for that node or for a subtree, then
                    the node is annotated as
                    <span><code>xs:anyType</code></span> in the
                    case of an element, and
                    <span><code>xs:untypedAtomic</code></span> in
                    the case of an attribute.</p>
                  </li>
                </ul>
              </li>

              <li>
                <p>The value <code>lax</code> has the same effect
                as the value <code>strict</code>, except that
                whereas <code>strict</code> validation fails
                <span>if there is no matching top-level element
                declaration or</span> if the outcome of validity
                assessment is a <code>validity</code> property of
                <code>invalid</code> or <code>notKnown</code>,
                <code>lax</code> validation fails only if the
                outcome of validity assessment is a
                <code>validity</code> property of
                <code>invalid</code>. That is, <code>lax</code>
                validation does not cause a type error when the
                outcome is <code>notKnown</code>.</p>

                <p>In practice this means that the element or
                attribute being validated <span class=
                "verb">must</span> conform to its declaration if a
                top-level declaration is available. If no such
                declaration is available, then the element or
                attribute is not validated, but its attributes and
                children are validated, again with lax validation.
                Any nodes whose validation outcome is a
                <code>validity</code> property of
                <code>notKnown</code> are annotated as
                <span><code>xs:anyType</code></span> in the case of
                an element, and
                <span><code>xs:untypedAtomic</code></span> in the
                case of an attribute.</p>

                <div class="note">
                  <p class="prefix"><b>Note:</b></p>

                  <p>When the parent element lacks a declaration,
                  the XML Schema specification defines the
                  recursive checking of children and attributes as
                  optional. For this specification, this recursive
                  checking is required.</p>
                </div>

                <div class="note">
                  <p class="prefix"><b>Note:</b></p>

                  <p>If an element that is being validated has an
                  <code>xsi:type</code> attribute, then the value
                  of the <code>xsi:type</code> attribute will be
                  taken into account when performing the
                  validation. However, the presence of an
                  <code>xsi:type</code> attribute will not of
                  itself cause an element to be validated: if
                  validation against a named type is required, as
                  distinct from validation against a top-level
                  element declaration, then it must be requested
                  using the XSLT <code>[xsl:]type</code> attribute
                  on the instruction that invokes the validation,
                  as described in section <a href=
                  "#validation-xsl-type"><i>19.2.1.2 Validation
                  using the [xsl:]type Attribute</i></a></p>
                </div>
              </li>
            </ul>

            <p><a name="err-XTTE1510" id=
            "err-XTTE1510"><span class="error">[ERR
            XTTE1510]</span></a> If the <code>validation</code>
            attribute of an <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>,
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>, or
            <a href=
            "#element-result-document"><code>xsl:result-document</code></a>
            instruction, or the <code>xsl:validation</code>
            attribute of a literal result element, has the
            effective value <code>strict</code>, and schema
            validity assessment concludes that the validity of the
            element or attribute is invalid or unknown, a type
            error occurs. As with other type errors, the error
            <span class="verb">may</span> be signaled statically if
            it can be detected statically.</p>

            <p><a name="err-XTTE1512" id=
            "err-XTTE1512"><span class="error">[ERR
            XTTE1512]</span></a> If the <code>validation</code>
            attribute of an <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>,
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>, or
            <a href=
            "#element-result-document"><code>xsl:result-document</code></a>
            instruction, or the <code>xsl:validation</code>
            attribute of a literal result element, has the
            effective value <code>strict</code>, and there is no
            matching top-level declaration in the schema, then a
            type error occurs. As with other type errors, the error
            <span class="verb">may</span> be signaled statically if
            it can be detected statically.</p>

            <p><a name="err-XTTE1515" id=
            "err-XTTE1515"><span class="error">[ERR
            XTTE1515]</span></a> If the <code>validation</code>
            attribute of an <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>,
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>, or
            <a href=
            "#element-result-document"><code>xsl:result-document</code></a>
            instruction, or the <code>xsl:validation</code>
            attribute of a literal result element, has the
            effective value <code>lax</code>, and schema validity
            assessment concludes that the element or attribute is
            invalid, a type error occurs. As with other type
            errors, the error <span class="verb">may</span> be
            signaled statically if it can be detected
            statically.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>No mechanism is provided to validate an element or
              attribute against a local declaration in a schema.
              Such validation can usually be achieved by applying
              validation to a containing element for which a
              top-level element declaration exists.</p>
            </div>
          </div>

          <div class="div4">
            <h5><a name="validation-xsl-type" id=
            "validation-xsl-type"></a>19.2.1.2 Validation using the
            <code>[xsl:]type</code> Attribute</h5>

            <p>The <code>[xsl:]type</code> attribute takes as its
            value a <code>QName</code>. This <span class=
            "verb">must</span> <span>be the name of a type
            definition included in the <a title=
            "in-scope schema component" href=
            "#dt-in-scope-schema-component">in-scope schema
            components</a> for the stylesheet.</span> If the QName
            has no prefix, it is expanded using the default
            namespace established using the effective
            <code>[xsl:]xpath-default-namespace</code> attribute if
            there is one; otherwise, it is taken as being a name in
            no namespace.</p>

            <p>If the <code>[xsl:]type</code> attribute is present,
            then the newly constructed element or attribute is
            validated against the type definition identified by
            this attribute.</p>

            <ul>
              <li>
                <p>In the case of an element, schema-validity
                assessment is carried out according to the rules
                defined in <a href="#xmlschema-1">[XML Schema Part
                1]</a> (section 3.3.4 "Element Declaration
                Validation Rules", validation rule "Schema-Validity
                Assessment (Element)", clauses 1.2 and 2), using
                this type definition as the "processor-stipulated
                type definition". The element is considered valid
                if the result of the schema validity assessment is
                a PSVI in which the relevant element node has a
                <code>validity</code> property whose value is
                <code>valid</code>.</p>
              </li>

              <li>
                <p>In the case of an attribute, the attribute is
                considered valid if (in the terminology of XML
                Schema) the attribute's normalized value is locally
                valid with respect to that type definition
                according to the rules for "String Valid" (<a href=
                "#xmlschema-1">[XML Schema Part 1]</a>, section
                3.14.4). (Normalization here refers to the process
                of normalizing whitespace according to the rules of
                the <code>whiteSpace</code> facet for the data
                type).</p>
              </li>

              <li>
                <p>If the element or attribute is not considered
                valid, <span>as defined above</span>, the
                transformation fails <span><span class="error">[see
                <a href="#err-XTTE1540">ERR
                XTTE1540</a>]</span></span>.</p>
              </li>
            </ul>

            <p><a name="err-XTSE1520" id=
            "err-XTSE1520"><span class="error">[ERR
            XTSE1520]</span></a> It is a <a title="static error"
            href="#dt-static-error">static error</a> if the value
            of the <code>type</code> attribute of an <a href=
            "#element-element"><code>xsl:element</code></a>,
            <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>,
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>,
            <span><a href=
            "#element-document"><code>xsl:document</code></a>,</span>
            or <a href=
            "#element-result-document"><code>xsl:result-document</code></a>
            instruction, or the <code>xsl:type</code> attribute of
            a literal result element, is not a valid
            <code>QName</code>, or if it uses a prefix that is not
            defined in an in-scope namespace declaration, or if the
            QName is not the name of a type definition included in
            the <a title="in-scope schema component" href=
            "#dt-in-scope-schema-component">in-scope schema
            components</a> for the stylesheet.</p>

            <p><a name="err-XTSE1530" id=
            "err-XTSE1530"><span class="error">[ERR
            XTSE1530]</span></a> It is a <a title="static error"
            href="#dt-static-error">static error</a> if the value
            of the <code>type</code> attribute of an <a href=
            "#element-attribute"><code>xsl:attribute</code></a>
            instruction refers to a complex type definition.</p>

            <p><a name="err-XTTE1540" id=
            "err-XTTE1540"><span class="error">[ERR
            XTTE1540]</span></a> It is a <a title="type errors"
            href="#dt-type-error">type error</a> if an
            <code>[xsl:]type</code> attribute is defined for a
            constructed element or attribute, and the outcome of
            schema validity assessment against that type is that
            the <code>validity</code> property of that element or
            attribute information item is other than
            <code>valid</code>.</p>

            <div class="note">
              <p class="prefix"><b>Note:</b></p>

              <p>Like other type errors, this error may be signaled
              statically if it can be detected statically. For
              example, the instruction <code>&lt;xsl:attribute
              name="dob"
              type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code>
              may result in a static error being signaled. If the
              error is not signaled statically, it will be signaled
              when the instruction is evaluated.</p>
            </div>
          </div>

          <div class="div4">
            <h5><a name="validation-process" id=
            "validation-process"></a>19.2.1.3 The Validation
            Process</h5>

            <p>As well as checking for validity against the schema,
            the validity assessment process causes <a title=
            "type annotation" href="#dt-annotation">type
            annotations</a> to be associated with element and
            attribute nodes. If default values for elements or
            attributes are defined in the schema, the validation
            process will where necessary create new nodes
            containing these default values.</p>

            <p>Validation of an element or attribute node only
            takes into account constraints on the content of the
            element or attribute. Validation rules affecting the
            document as a whole are not applied. Specifically, this
            means:</p>

            <ul>
              <li>
                <p>The validation rule "Validation Root Valid
                (ID/IDREF)" is not applied. This means that
                validation will not fail if there are non-unique ID
                values or dangling IDREF values in the subtree
                being validated.</p>
              </li>

              <li>
                <p>The validation rule "Validation Rule:
                Identity-constraint Satisfied" is not applied.</p>
              </li>

              <li>
                <p>There is no check that the document contains
                unparsed entities whose names match the values of
                nodes of type <code>xs:ENTITY</code> or
                <code>xs:ENTITIES</code>. (XSLT 2.0 provides no
                facility to construct unparsed entities within a
                tree.)</p>
              </li>

              <li>
                <p>There is no check that the document contains
                notations whose names match the values of nodes of
                type <code>xs:NOTATION</code>. (The
                <span>XDM</span> data model makes no provision for
                notations to be represented in the tree.)</p>
              </li>
            </ul>

            <p>With these caveats, validating a newly constructed
            element, using strict or lax validation, is equivalent
            to the following steps:</p>

            <ol class="enumar">
              <li>
                <p>The element is serialized to textual XML form,
                according to the rules defined in <a href=
                "#xslt-xquery-serialization">[XSLT and XQuery
                Serialization]</a> using the XML output method,
                with all parameters defaulted. Note that this
                process discards any existing <a title=
                "type annotation" href="#dt-annotation">type
                annotations</a>.</p>
              </li>

              <li>
                <p>The resulting XML document is parsed to create
                an XML Information Set (see <a href=
                "#xml-infoset">[XML Information Set]</a>.)</p>
              </li>

              <li>
                <p>The Information Set produced in the previous
                step is validated according to the rules in
                <a href="#xmlschema-1">[XML Schema Part 1]</a>. The
                result of this step is a Post-Schema Validation
                Infoset (PSVI). If the validation process is not
                successful (as defined above), a type error is
                raised.</p>
              </li>

              <li>
                <p>The PSVI produced in the previous step is
                converted back into the <span>XDM</span> data model
                by the mapping described in <a href=
                "#xpath-datamodel">[Data Model]</a> (<a href=
                "http://www.w3.org/TR/xpath-datamodel/#PSVI2Types">Section
                3.3.1 Mapping PSVI Additions to Node
                Properties</a><sup><small>DM</small></sup>). This
                process creates nodes with simple or complex
                <a title="type annotation" href=
                "#dt-annotation">type annotations</a> based on the
                types established during schema validation.</p>
              </li>
            </ol>

            <p>Validating an attribute using strict or lax
            validation requires a modified version of this
            procedure. A copy of the attribute is first added to an
            element node that is created for the purpose, and
            namespace fixup (see <a href=
            "#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>) is
            performed on this element node. The name of this
            element is of no consequence, but it must be the same
            as the name of a synthesized element declaration of the
            form:</p>

            <div class="exampleInner">
              <pre>
&lt;xs:element name="E"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:sequence/&gt;
    &lt;xs:attribute ref="A"/&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;
</pre>
            </div>

            <p>where A is the name of the attribute being
            validated.</p>

            <p>This synthetic element is then validated using the
            procedure given above for validating elements, and if
            it is found to be valid, a copy of the validated
            attribute is made, retaining its <a title=
            "type annotation" href="#dt-annotation">type
            annotation</a>, but detaching it from the containing
            element (and thus, from any namespace nodes).</p>

            <p>The <span>XDM</span> data model does not permit an
            attribute node with no parent to have a typed value
            that includes a namespace-qualified name, that is, a
            value whose type is derived from <code>xs:QName</code>
            or <code>xs:NOTATION</code>. This restriction is
            imposed because these types rely on the namespace nodes
            of a containing element to resolve namespace prefixes.
            Therefore, it is an error to validate a parentless
            attribute against such a type. This affects the
            instructions <a href=
            "#element-attribute"><code>xsl:attribute</code></a>,
            <a href="#element-copy"><code>xsl:copy</code></a>, and
            <a href=
            "#element-copy-of"><code>xsl:copy-of</code></a>.</p>

            <p><a name="err-XTTE1545" id=
            "err-XTTE1545"><span class="error">[ERR
            XTTE1545]</span></a> A <a title="type errors" href=
            "#dt-type-error">type error</a> occurs if a
            <code>type</code> or <code>validation</code> attribute
            is defined (explicitly or implicitly) for an
            instruction that constructs a new attribute node, if
            the effect of this is to cause the attribute value to
            be validated against a type that is derived from, or
            constructed by list or union from, the primitive types
            <code>xs:QName</code> or <code>xs:NOTATION</code>.</p>
          </div>
        </div>

        <div class="div3">
          <h4><a name="validating-document-nodes" id=
          "validating-document-nodes"></a>19.2.2 Validating
          Document Nodes</h4>

          <p>It is possible to apply validation to a document node.
          <span>This happens when a new document node is
          constructed by one of the instructions <a href=
          "#element-document"><code>xsl:document</code></a>,
          <a href=
          "#element-result-document"><code>xsl:result-document</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>, or
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          and this instruction has a <code>type</code> attribute,
          or a <code>validation</code> attribute with the value
          <code>strict</code> or <code>lax</code></span>.</p>

          <p>Document-level validation is not applied to the
          document node that is created implicitly when a
          variable-binding element has no <code>select</code>
          attribute and no <code>as</code> attribute (see <a href=
          "#temporary-trees"><i>9.4 Creating implicit document
          nodes</i></a>). This is equivalent to using
          <code>validation="preserve"</code> on <a href=
          "#element-document"><code>xsl:document</code></a>: nodes
          within such trees retain their <a title="type annotation"
          href="#dt-annotation">type annotation</a>. Similarly,
          validation is not applied to document nodes created using
          <a href=
          "#element-message"><code>xsl:message</code></a>.</p>

          <p>The values <code>validation="preserve"</code> and
          <code>validation="strip"</code> do not request
          validation. In the first case, all element and attribute
          nodes within the tree rooted at the new document node
          retain their <a title="type annotation" href=
          "#dt-annotation">type annotations</a>. In the second
          case, elements within the tree have their type annotation
          set to <span><code>xs:untyped</code></span>, while
          attributes have their type annotation set to
          <span><code>xs:untypedAtomic</code></span>.</p>

          <p>When validation is requested for a document node (that
          is, when <code>validation</code> is set to
          <code>strict</code> or <code>lax</code>, or when a
          <code>type</code> attribute is present), the following
          processing takes place:</p>

          <ul>
            <li>
              <p><a name="err-XTTE1550" id=
              "err-XTTE1550"><span class="error">[ERR
              XTTE1550]</span></a> A <a title="type errors" href=
              "#dt-type-error">type error</a> occurs unless the
              children of the document node comprise exactly one
              element node, no text nodes, and zero or more comment
              and processing instruction nodes, in any order.</p>
            </li>

            <li>
              <p>The single element node child is validated, using
              the supplied values of the <code>validation</code>
              and <code>type</code> attributes, as described in
              <a href="#validating-constructed-nodes"><i>19.2.1
              Validating Constructed Elements and
              Attributes</i></a>.</p>

              <div class="note">
                <p class="prefix"><b>Note:</b></p>

                <p>The <code>type</code> attribute on
                <span><a href="#element-document"><code>xsl:document</code></a>
                and</span> <a href=
                "#element-result-document"><code>xsl:result-document</code></a>,
                and on <a href=
                "#element-copy"><code>xsl:copy</code></a> and
                <a href=
                "#element-copy-of"><code>xsl:copy-of</code></a>
                when copying a document node, thus refers to the
                required type of the element node that is the only
                element child of the document node. It does not
                refer to the type of the document node itself.</p>
              </div>
            </li>

            <li>
              <p>The validation rule "Validation Root Valid
              (ID/IDREF)" is applied to the single element node
              child of the document node. This means that
              validation will fail if there are non-unique ID
              values or dangling IDREF values in the document
              tree.</p>
            </li>

            <li>
              <p>Identity constraints, as defined in section 3.11
              of <a href="#xmlschema-1">[XML Schema Part 1]</a>,
              are checked. (This refers to constraints defined
              using <code>xs:unique</code>, <code>xs:key</code>,
              and <code>xs:keyref</code>.)</p>
            </li>

            <li>
              <p>There is no check that the tree contains unparsed
              entities whose names match the values of nodes of
              type <code>xs:ENTITY</code> or
              <code>xs:ENTITIES</code>. This is because there is no
              facility in XSLT 2.0 to create unparsed entities in a
              <a title="result tree" href="#dt-result-tree">result
              tree</a>. It is possible to add unparsed entity
              declarations to the result document by referencing a
              suitable DOCTYPE during serialization.</p>
            </li>

            <li>
              <p>There is no check that the document contains
              notations whose names match the values of nodes of
              type <code>xs:NOTATION</code>. This is because
              notations are not part of the <span>XDM</span> data
              model. It is possible to add notations to the result
              document by referencing a suitable DOCTYPE during
              serialization.</p>
            </li>

            <li>
              <p>All other children of the document node (comments
              and processing instructions) are copied
              unchanged.</p>
            </li>
          </ul>

          <p><a name="err-XTTE1555" id="err-XTTE1555"><span class=
          "error">[ERR XTTE1555]</span></a> It is a <a title=
          "type errors" href="#dt-type-error">type error</a> if,
          when validating a document node, document-level
          constraints are not satisfied. These constraints include
          identity constraints (<code>xs:unique</code>,
          <code>xs:key</code>, and <code>xs:keyref</code>) and
          ID/IDREF constraints.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="serialization" id="serialization"></a>20
      Serialization</h2>

      <p>A <a title="processor" href="#dt-processor">processor</a>
      <span class="verb">may</span> output a <a title=
      "final result tree" href="#dt-final-result-tree">final result
      tree</a> as a sequence of octets, although it is not
      <span class="verb">required</span> to be able to do so (see
      <a href="#conformance"><i>21 Conformance</i></a>).
      <span>Stylesheet authors can use <a href=
      "#element-output"><code>xsl:output</code></a> declarations to
      specify how they wish result trees to be serialized. If a
      processor serializes a final result tree, it <span class=
      "verb">must</span> do so as specified by these
      declarations.</span></p>

      <p>The rules governing the output of the serializer are
      defined in <a href="#xslt-xquery-serialization">[XSLT and
      XQuery Serialization]</a>. The serialization is controlled
      using a number of serialization parameters. The values of
      these serialization parameters may be set within the
      <a title="stylesheet" href="#dt-stylesheet">stylesheet</a>,
      using the <a href=
      "#element-output"><code>xsl:output</code></a>, <a href=
      "#element-result-document"><code>xsl:result-document</code></a>,
      and <a href=
      "#element-character-map"><code>xsl:character-map</code></a>
      declarations.</p>

      <p class="element-syntax"><a name="element-output" id=
      "element-output"></a><code>&lt;!-- Category: declaration
      --&gt;<br />
      &lt;xsl:output<br />
      &#160;&#160;name? = <var>qname</var><br />
      &#160;&#160;method? = "xml" | "html" | "xhtml" | "text" |
      <var>qname-but-not-ncname</var><br />
      &#160;&#160;byte-order-mark? = "yes" | "no"<br />
      &#160;&#160;cdata-section-elements? = <var>qnames</var><br />
      &#160;&#160;doctype-public? = <var>string</var><br />
      &#160;&#160;doctype-system? = <var>string</var><br />
      &#160;&#160;encoding? = <var>string</var><br />
      &#160;&#160;escape-uri-attributes? = "yes" | "no"<br />
      &#160;&#160;include-content-type? = "yes" | "no"<br />
      &#160;&#160;indent? = "yes" | "no"<br />
      &#160;&#160;media-type? = <var>string</var><br />
      &#160;&#160;normalization-form? = "NFC" | "NFD" | "NFKC" |
      "NFKD" | "fully-normalized" | "none" |
      <var>nmtoken</var><br />
      &#160;&#160;omit-xml-declaration? = "yes" | "no"<br />
      &#160;&#160;standalone? = "yes" | "no" | "omit"<br />
      &#160;&#160;undeclare-prefixes? = "yes" | "no"<br />
      &#160;&#160;use-character-maps? = <var>qnames</var><br />
      &#160;&#160;version? =
      <var>nmtoken</var>&#160;/&gt;</code></p>

      <p>The <a href="#element-output"><code>xsl:output</code></a>
      declaration is optional; if used, it <span class=
      "verb">must</span> always appear as a <a title="top-level"
      href="#dt-top-level">top-level</a> element within a
      <span>stylesheet module</span>.</p>

      <p>A <a title="stylesheet" href=
      "#dt-stylesheet">stylesheet</a> may contain multiple <a href=
      "#element-output"><code>xsl:output</code></a> declarations
      and may include or import stylesheet modules that also
      contain <a href="#element-output"><code>xsl:output</code></a>
      declarations. The name of an <a href=
      "#element-output"><code>xsl:output</code></a> declaration is
      the value of its <code>name</code> attribute, if any.</p>

      <p><span class="definition">[Definition:&#160;</span><a name=
      "dt-output-definition" id="dt-output-definition" title=
      "output definition"></a>All the <a href=
      "#element-output"><code>xsl:output</code></a> declarations in
      a stylesheet that share the same name are grouped into a
      named <b>output definition</b>; those that have no name are
      grouped into a single unnamed output definition.<span class=
      "definition">]</span></p>

      <p>A stylesheet always includes an unnamed <a title=
      "output definition" href="#dt-output-definition">output
      definition</a>; in the absence of an unnamed <a href=
      "#element-output"><code>xsl:output</code></a> declaration,
      the unnamed output definition is equivalent to the one that
      would be used if the stylesheet contained an <a href=
      "#element-output"><code>xsl:output</code></a> declaration
      having no attributes.</p>

      <p>A named <a title="output definition" href=
      "#dt-output-definition">output definition</a> is used when
      its name matches the <code>format</code> attribute used in an
      <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      element. The unnamed output definition is used when an
      <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      element omits the <code>format</code> attribute. It is also
      used when serializing the <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a> that is created
      implicitly in the absence of an <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      element.</p>

      <p>All the <a href=
      "#element-output"><code>xsl:output</code></a> elements making
      up an <a title="output definition" href=
      "#dt-output-definition">output definition</a> are effectively
      merged. <span>For those attributes whose values are
      namespace-sensitive, the merging is done after <a title=
      "lexical QName" href="#dt-lexical-qname">lexical QNames</a>
      have been converted into <a title="expanded-QName" href=
      "#dt-expanded-qname">expanded QNames</a>.</span> For the
      <code>cdata-section-elements</code> attribute, the output
      definition uses the union of the values from all the
      constituent <a href=
      "#element-output"><code>xsl:output</code></a> declarations.
      <span>For the <code>use-character-maps</code> attribute, the
      output definition uses the concatenation of the sequences of
      <a title="expanded-QName" href="#dt-expanded-qname">expanded
      QNames</a> values from all the constituent <a href=
      "#element-output"><code>xsl:output</code></a> declarations,
      taking them in order of increasing <a title=
      "import precedence" href="#dt-import-precedence">import
      precedence</a>, or where several have the same import
      precedence, in <a title="declaration order" href=
      "#dt-declaration-order">declaration order</a>.</span> For
      other attributes, the <a title="output definition" href=
      "#dt-output-definition">output definition</a> uses the value
      of that attribute from the <a href=
      "#element-output"><code>xsl:output</code></a> declaration
      with the highest <a title="import precedence" href=
      "#dt-import-precedence">import precedence</a>.</p>

      <p><a name="err-XTSE1560" id="err-XTSE1560"><span class=
      "error">[ERR XTSE1560]</span></a> It is a <a title=
      "static error" href="#dt-static-error">static error</a> if
      two <a href="#element-output"><code>xsl:output</code></a>
      declarations within an <a title="output definition" href=
      "#dt-output-definition">output definition</a> specify
      explicit values for the same attribute (other than
      <code>cdata-section-elements</code> and
      <code>use-character-maps</code>), with the values of the
      attributes being not equal, unless there is another <a href=
      "#element-output"><code>xsl:output</code></a> declaration
      within the same <a title="output definition" href=
      "#dt-output-definition">output definition</a> that has higher
      import precedence and that specifies an explicit value for
      the same attribute.</p>

      <p>If none of the <a href=
      "#element-output"><code>xsl:output</code></a> declarations
      within an <a title="output definition" href=
      "#dt-output-definition">output definition</a> specifies a
      value for a particular attribute, then the corresponding
      serialization parameter takes a default value. The default
      value depends on the chosen output method.</p>

      <p>There are some serialization parameters that apply to some
      output methods but not to others. For example, the
      <code>indent</code> attribute has no effect on the
      <code>text</code> output method. If a value is supplied for
      an attribute that is inapplicable to the output method, its
      value is <span>not passed to the serializer</span>. The
      processor <span class="verb">may</span> validate the value of
      such an attribute, but is not <span class=
      "verb">required</span> to do so.</p>

      <p>An implementation <span class="verb">may</span> allow the
      attributes of the <a href=
      "#element-output"><code>xsl:output</code></a> declaration to
      be overridden, or the default values to be changed, using the
      API that controls the transformation.</p>

      <p>The location to which <a title="final result tree" href=
      "#dt-final-result-tree">final result trees</a> are serialized
      (whether in filestore or elsewhere) is <a title=
      "implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a>
      (which in practice <span class="verb">may</span> mean that it
      is controlled using an implementation-defined API). However,
      these locations <span class="verb">must</span> satisfy the
      constraint that when two <a title="final result tree" href=
      "#dt-final-result-tree">final result trees</a> are both
      created (implicitly or explicitly) using relative URIs in the
      <code>href</code> attribute of the <a href=
      "#element-result-document"><code>xsl:result-document</code></a>
      instruction, then these relative URIs may be used to
      construct references from one tree to the other, and such
      references <span class="verb">must</span> remain valid when
      both result trees are serialized.</p>

      <p>The <code>method</code> attribute on the <a href=
      "#element-output"><code>xsl:output</code></a> element
      identifies the overall method that is to be used for
      outputting the <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a>.</p>

      <p><a name="err-XTSE1570" id="err-XTSE1570"><span class=
      "error">[ERR XTSE1570]</span></a> The value <span class=
      "verb">must</span> <span>(if present)</span> be a valid
      <a title="QName" href="#dt-qname">QName</a>. If the <a title=
      "QName" href="#dt-qname">QName</a> does not have a prefix,
      then it identifies a method specified in <a href=
      "#xslt-xquery-serialization">[XSLT and XQuery
      Serialization]</a> and <span class="verb">must</span> be one
      of <code>xml</code>, <code>html</code>, <code>xhtml</code>,
      or <code>text</code>. If the <a title="QName" href=
      "#dt-qname">QName</a> has a prefix, then the <a title="QName"
      href="#dt-qname">QName</a> is expanded into an <a title=
      "expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
      as described in <a href="#qname"><i>5.1 Qualified
      Names</i></a>; the <a title="expanded-QName" href=
      "#dt-expanded-qname">expanded-QName</a> identifies the output
      method; the behavior in this case is not specified by this
      document.</p>

      <p>The default for the <code>method</code> attribute
      <span>depends on the contents of the tree being serialized,
      and</span> is chosen as follows. If the document node of the
      <a title="final result tree" href=
      "#dt-final-result-tree">final result tree</a> has an element
      child, and any text nodes preceding the first element child
      of the document node of the result tree contain only
      whitespace characters, then:</p>

      <ul>
        <li>
          <p>If the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of this first
          element child has local part <code>html</code> (in lower
          case), and namespace URI
          <code>http://www.w3.org/1999/xhtml</code>, then the
          default output method is <span>normally</span>
          <code>xhtml</code>. <span>However, if the
          <code>version</code> attribute of the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element of the <a title="principal stylesheet module"
          href="#dt-principal-stylesheet-module">principal
          stylesheet module</a> has the value <code>1.0</code>, and
          if the result tree is generated implicitly (rather than
          by an explicit <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction), then the default output method in this
          situation is <code>xml</code>.</span></p>
        </li>

        <li>
          <p>If the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of this first
          element child has local part <code>html</code> (in any
          combination of upper and lower case) and a null namespace
          URI, then the default output method is
          <code>html</code>.</p>
        </li>
      </ul>

      <p>In all other cases, the default output method is
      <code>xml</code>.</p>

      <p>The default output method is used if the selected
      <a title="output definition" href=
      "#dt-output-definition">output definition</a> does not
      include a <code>method</code> attribute.</p>

      <p>The other attributes on <a href=
      "#element-output"><code>xsl:output</code></a> provide
      parameters for the output method. The following attributes
      are allowed:</p>

      <ul>
        <li>
          <p>The value of the <code>encoding</code> attribute
          provides the value of the <code>encoding</code> parameter
          to the serialization method. The default value is
          <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>,
          but in the case of the <code>xml</code> and
          <code>xhtml</code> methods it <span class=
          "verb">must</span> be either <code>UTF-8</code> or
          <code>UTF-16</code>.</p>
        </li>

        <li>
          <p>The <code>byte-order-mark</code> attribute defines
          whether a byte order mark is written at the start of the
          file. If the value <code>yes</code> is specified, a byte
          order mark is written; if <code>no</code> is specified,
          no byte order mark is written. The default value depends
          on the encoding used. If the encoding is
          <code>UTF-16</code>, the default is <code>yes</code>; for
          <code>UTF-8</code> it is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>,
          and for all other encodings it is <code>no</code>. The
          value of the byte order mark indicates whether high order
          bytes are written before or after low order bytes; the
          actual byte order used is <a title=
          "implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a><span>
          , unless it is defined by the selected
          encoding</span>.</p>
        </li>

        <li>
          <p>The <code>cdata-section-elements</code> attribute is a
          whitespace-separated list of QNames. The default value is
          an empty list. After expansion of these names using the
          in-scope namespace declarations for the <a href=
          "#element-output"><code>xsl:output</code></a> declaration
          in which they appear, this list of names provides the
          value of the <code>cdata-section-elements</code>
          parameter to the serialization method. <span>In the case
          of an unprefixed name, the default namespace (that is,
          the namespace declared using <code>xmlns="uri"</code>) is
          used.</span></p>

          <div class="note">
            <p class="prefix"><b>Note:</b></p>

            <p>This differs from the rule for most other QNames
            used in a stylesheet. The reason is that these names
            refer to elements in the result document, and therefore
            follow the same convention as the name of a literal
            result element or the <code>name</code> attribute of
            <a href=
            "#element-element"><code>xsl:element</code></a>.</p>
          </div>
        </li>

        <li>
          <p>The value of the <code>doctype-system</code> attribute
          provides the value of the <code>doctype-system</code>
          parameter to the serialization method. By default, the
          parameter is not supplied.</p>
        </li>

        <li>
          <p>The value of the <code>doctype-public</code> attribute
          provides the value of the <code>doctype-public</code>
          parameter to the serialization method. By default, the
          parameter is not supplied.</p>
        </li>

        <li>
          <p>The value of the <code>escape-uri-attributes</code>
          attribute provides the value of the
          <code>escape-uri-attributes</code> parameter to the
          serialization method. The default value is
          <code>yes</code>.</p>
        </li>

        <li>
          <p>The value of the <code>include-content-type</code>
          attribute provides the value of the
          <code>include-content-type</code> parameter to the
          serialization method. The default value is
          <code>yes</code>.</p>
        </li>

        <li>
          <p>The value of the <code>indent</code> attribute
          provides the value of the <code>indent</code> parameter
          to the serialization method. The default value is
          <code>yes</code> in the case of the <code>html</code> and
          <code>xhtml</code> output methods, <code>no</code> in the
          case of the <code>xml</code> output method.</p>
        </li>

        <li>
          <p>The value of the <code>media-type</code> attribute
          provides the value of the <code>media-type</code>
          parameter to the serialization method. The default value
          is <code>text/xml</code> in the case of the
          <code>xml</code> output method, <code>text/html</code> in
          the case of the <code>html</code> and <code>xhtml</code>
          output methods, and <code>text/plain</code> in the case
          of the <code>text</code> output method.</p>
        </li>

        <li>
          <p>The value of the <code>normalization-form</code>
          attribute provides the value of the
          <code>normalization-form</code> parameter to the
          serialization method. A value that is an
          <code>NMTOKEN</code> other than one of those enumerated
          for the <code>normalization-form</code> attribute
          specifes an implementation-defined normalization form;
          the behavior in this case is not specified by this
          document. The default value is <code>none</code>.</p>
        </li>

        <li>
          <p>The value of the <code>omit-xml-declaration</code>
          attribute provides the value of the
          <code>omit-xml-declaration</code> parameter to the
          serialization method. The default value is
          <code>no</code>.</p>
        </li>

        <li>
          <p>The value of the <code>standalone</code> attribute
          provides the value of the <code>standalone</code>
          parameter to the serialization method. <span>The default
          value is <code>omit</code>; this means that no
          <code>standalone</code> attribute is to be included in
          the XML declaration.</span></p>
        </li>

        <li>
          <p>The <code>undeclare-prefixes</code> attribute is
          relevant only when producing output with
          <code>method="xml"</code> and <code>version="1.1"</code>
          <span>(or later)</span>. It defines whether namespace
          undeclarations (of the form <code>xmlns:foo=""</code>)
          <span class="verb">should</span> be output when a child
          element has no namespace node with the same name (that
          is, namespace prefix) as a namespace node of its parent
          element. The default value is <code>no</code>: this means
          that namespace undeclarations are not output, which has
          the effect that when the resulting XML is reparsed, the
          new tree may contain namespace nodes on the child element
          that were not there in the original tree before
          serialization.</p>
        </li>

        <li>
          <p>The <code>use-character-maps</code> attribute provides
          a list of named character maps that are used in
          conjunction with this <a title="output definition" href=
          "#dt-output-definition">output definition</a>. The way
          this attribute is used is described in <a href=
          "#character-maps"><i>20.1 Character Maps</i></a>.
          <span>The default value is an empty list.</span></p>
        </li>

        <li>
          <p>The value of the <code>version</code> attribute
          provides the value of the <code>version</code> parameter
          to the serialization method. <span>The set of permitted
          values, and the default value, are <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          A <a title="serialization error" href=
          "#dt-serialization-error">serialization error</a> will be
          reported if the requested version is not supported by the
          implementation.</span></p>
        </li>
      </ul>

      <p>If the processor performs serialization, then it must
      signal any non-recoverable serialization errors that occur.
      These have the same effect as <a title=
      "non-recoverable dynamic error" href=
      "#dt-nonrec-dynamic-error">non-recoverable dynamic
      errors</a>: that is, the processor must signal the error and
      must not finish as if the transformation had been
      successful.</p>

      <div class="div2">
        <h3><a name="character-maps" id="character-maps"></a>20.1
        Character Maps</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-character-map" id="dt-character-map" title=
        "character map"></a>A <b>character map</b> allows a
        specific character appearing in a text or attribute node in
        the <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> to be
        substituted by a specified string of characters during
        serialization.<span class="definition">]</span> The effect
        of character maps is defined in <a href=
        "#xslt-xquery-serialization">[XSLT and XQuery
        Serialization]</a>.</p>

        <p>The character map that is supplied as a parameter to the
        serializer is determined from the <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        elements referenced from the <a href=
        "#element-output"><code>xsl:output</code></a> declaration
        for the selected <a title="output definition" href=
        "#dt-output-definition">output definition</a>.</p>

        <p>The <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        element is a declaration that may appear as a child of the
        <a href=
        "#element-stylesheet"><code>xsl:stylesheet</code></a>
        element.</p>

        <p class="element-syntax"><a name="element-character-map"
        id="element-character-map"></a><code>&lt;!-- Category:
        declaration --&gt;<br />
        &lt;xsl:character-map<br />
        &#160;&#160;<b>name</b> = <var>qname</var><br />
        &#160;&#160;use-character-maps? =
        <var>qnames</var>&gt;<br />
        &#160;&#160;&lt;!-- Content: (<a href=
        "#element-output-character">xsl:output-character</a>*)
        --&gt;<br />
        &lt;/xsl:character-map&gt;</code></p>

        <p>The <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declaration declares a character map with a name and a set
        of character mappings. The character mappings are specified
        by means of <a href=
        "#element-output-character"><code>xsl:output-character</code></a>
        elements contained either directly within the <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        element, or in further character maps referenced in the
        <code>use-character-maps</code> attribute.</p>

        <p>The <span class="verb">required</span> <code>name</code>
        attribute provides a name for the character map. When a
        character map is used by an <a title="output definition"
        href="#dt-output-definition">output definition</a> or
        another character map, the character map with the highest
        <a title="import precedence" href=
        "#dt-import-precedence">import precedence</a> is used.</p>

        <p><a name="err-XTSE1580" id="err-XTSE1580"><span class=
        "error">[ERR XTSE1580]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> contains two or more
        character maps with the same name and the same <a title=
        "import precedence" href="#dt-import-precedence">import
        precedence</a><span>, unless it also contains another
        character map with the same name and higher import
        precedence.</span></p>

        <p>The optional <code>use-character-maps</code> attribute
        lists the names of further character maps that are included
        into this character map.</p>

        <p><a name="err-XTSE1590" id="err-XTSE1590"><span class=
        "error">[ERR XTSE1590]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a name in the <code>use-character-maps</code> attribute
        <span>of the <a href=
        "#element-output"><code>xsl:output</code></a> or <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        elements</span> does not match the <code>name</code>
        attribute of any <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        in the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a>.</p>

        <p><a name="err-XTSE1600" id="err-XTSE1600"><span class=
        "error">[ERR XTSE1600]</span></a> It is a <a title=
        "static error" href="#dt-static-error">static error</a> if
        a character map references itself, directly or indirectly,
        via a name in the <code>use-character-maps</code>
        attribute.</p>

        <p>It is not an error if the same character map is
        referenced more than once, directly or indirectly.</p>

        <p>An <a title="output definition" href=
        "#dt-output-definition">output definition</a>, after
        recursive expansion of character maps referenced via its
        <code>use-character-maps</code> attribute, may contain
        several mappings for the same character. In this situation,
        the last character mapping takes precedence. To establish
        the ordering, the following rules are used:</p>

        <ul>
          <li>
            <p>Within a single <a href=
            "#element-character-map"><code>xsl:character-map</code></a>
            element, the characters defined in character maps
            referenced in the <code>use-character-maps</code>
            attribute are considered before the characters defined
            in the child <a href=
            "#element-output-character"><code>xsl:output-character</code></a>
            elements.</p>
          </li>

          <li>
            <p>The character maps referenced in a single
            <code>use-character-maps</code> attribute are
            considered in the order in which they are listed in
            that attribute. The expansion is depth-first: each
            referenced character map is fully expanded before the
            next one is considered.</p>
          </li>

          <li>
            <p>Two <a href=
            "#element-output-character"><code>xsl:output-character</code></a>
            elements appearing as children of the same <a href=
            "#element-character-map"><code>xsl:character-map</code></a>
            element are considered in document order.</p>
          </li>
        </ul>

        <p>The <a href=
        "#element-output-character"><code>xsl:output-character</code></a>
        element is defined as follows:</p>

        <p class="element-syntax"><a name=
        "element-output-character" id=
        "element-output-character"></a><code>&lt;xsl:output-character<br />

        &#160;&#160;<b>character</b> = <var>char</var><br />
        &#160;&#160;<b>string</b> =
        <var>string</var>&#160;/&gt;</code></p>

        <p>The character map that is passed as a parameter to the
        serializer contains a mapping for the character specified
        in the <code>character</code> attribute to the string
        specified in the <code>string</code> attribute.</p>

        <p>Character mapping is not applied to characters for which
        output escaping has been disabled as described in <a href=
        "#disable-output-escaping"><i>20.2 Disabling Output
        Escaping</i></a>.</p>

        <p>If a character is mapped, then it is not subjected to
        XML or HTML escaping.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e29242" id="d5e29242"></a>Example: Using
            Character Maps to Generate Non-XML Output
          </div>

          <p>Character maps can be useful when producing serialized
          output in a format that resembles, but is not strictly
          conformant to, HTML or XML. For example, when the output
          is a JSP page, there might be a need to generate the
          output:</p>

          <div class="exampleInner">
            <pre>
&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;
</pre>
          </div>

          <p>Although this output is not well-formed XML or HTML,
          it is valid in Java Server Pages. This can be achieved by
          allocating three Unicode characters (which are not needed
          for any other purpose) to represent the strings
          <code>&lt;%</code>, <code>%&gt;</code>, and
          <code>"</code>, for example:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;
</pre>
          </div>

          <p>When this character map is referenced in the <a href=
          "#element-output"><code>xsl:output</code></a>
          declaration, the required output can be produced by
          writing the following in the stylesheet:</p>

          <div class="exampleInner">
            <pre>
&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;
</pre>
          </div>

          <p>This works <span>on the assumption that</span> when an
          apostrophe or quotation mark is generated as part of an
          attribute value by the use of character maps, the
          serializer will (where possible) use the other choice of
          delimiter around the attribute value.</p>
        </div>

        <p>&#160;</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e29274" id="d5e29274"></a>Example:
            Constructing a Composite Character Map
          </div>

          <p>The following example illustrates a composite
          character map constructed in a modular fashion:</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="div2">
        <h3><a name="disable-output-escaping" id=
        "disable-output-escaping"></a>20.2 Disabling Output
        Escaping</h3>

        <p>Normally, when using the XML, HTML, or XHTML output
        method, the serializer will escape special characters such
        as <code>&amp;</code> and <code>&lt;</code> when outputting
        text nodes. This ensures that the output is well-formed.
        However, it is sometimes convenient to be able to produce
        output that is almost, but not quite well-formed XML; for
        example, the output may include ill-formed sections which
        are intended to be transformed into well-formed XML by a
        subsequent non-XML-aware process. For this reason, XSLT
        defines a mechanism for disabling output escaping.</p>

        <p>This feature is <a title="deprecated" href=
        "#dt-deprecated">deprecated</a>.</p>

        <p>This is an optional feature: it is not <span class=
        "verb">required</span> that a XSLT processor that
        implements the serialization option <span class=
        "verb">should</span> offer the ability to disable output
        escaping, and there is no conformance level that requires
        this feature.</p>

        <p>This feature requires an extension to the serializer
        described in <a href="#xslt-xquery-serialization">[XSLT and
        XQuery Serialization]</a>. Conceptually, the <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a> provides an additional boolean property
        <code>disable-escaping</code> associated with every
        character in a text node. When this property is set, the
        normal action of the serializer to escape special
        characters such as <code>&amp;</code> and <code>&lt;</code>
        is suppressed.</p>

        <p>An <a href=
        "#element-value-of"><code>xsl:value-of</code></a> or
        <a href="#element-text"><code>xsl:text</code></a> element
        may have a <code>disable-output-escaping</code> attribute;
        the allowed values are <code>yes</code> or <code>no</code>.
        The default is <code>no</code>; if the value is
        <code>yes</code>, then every character in the text node
        generated by evaluating the <a href=
        "#element-value-of"><code>xsl:value-of</code></a> or
        <a href="#element-text"><code>xsl:text</code></a> element
        <span class="verb">should</span> have the
        <code>disable-output</code> property set.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e29357" id="d5e29357"></a>Example: Disable
            Output Escaping
          </div>

          <p>For example,</p>

          <div class="exampleInner">
            <pre>
&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;
</pre>
          </div>

          <p>should generate the single character
          <code>&lt;</code>.</p>
        </div>

        <p>If output escaping is disabled for an <a href=
        "#element-value-of"><code>xsl:value-of</code></a> or
        <a href="#element-text"><code>xsl:text</code></a>
        instruction evaluated when <a title=
        "temporary output state" href=
        "#dt-temporary-output-state">temporary output state</a> is
        in effect, the request to disable output escaping is
        ignored.</p>

        <p>If output escaping is disabled for text within an
        element that would normally be output using a CDATA
        section, because the element is listed in the
        <code>cdata-section-elements</code>, then the relevant text
        will not be included in a CDATA section. In effect, CDATA
        is treated as an alternative escaping mechanism, which is
        disabled by the <code>disable-output-escaping</code>
        option.</p>

        <div class="example">
          <div class="exampleHeader">
            <a name="d5e29388" id="d5e29388"></a>Example:
            Interaction of Output Escaping and CDATA
          </div>

          <p>For example, if <code>&lt;xsl:output
          cdata-section-elements="title"/&gt;</code> is specified,
          then the following instructions:</p>

          <div class="exampleInner">
            <pre>
&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;
</pre>
          </div>

          <p>should generate the output:</p>

          <div class="exampleInner">
            <pre>
&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;
</pre>
          </div>
        </div>

        <p>The <code>disable-output-escaping</code> attribute may
        be used with the <code>html</code> output method as well as
        with the <code>xml</code> output method. The
        <code>text</code> output method ignores the
        <code>disable-output-escaping</code> attribute, since it
        does not perform any output escaping.</p>

        <p>A <a title="processor" href=
        "#dt-processor">processor</a> will only be able to disable
        output escaping if it controls how the <a title=
        "final result tree" href="#dt-final-result-tree">final
        result tree</a> is output. This might not always be the
        case. For example, the result tree might be used as a
        <a title="source tree" href="#dt-source-tree">source
        tree</a> for another XSLT transformation instead of being
        output. It is <a title="implementation-defined" href=
        "#dt-implementation-defined">implementation-defined</a>
        whether (and under what circumstances) disabling output
        escaping is supported.</p>

        <p><a name="err-XTRE1620" id="err-XTRE1620"><span class=
        "error">[ERR XTRE1620]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> if an
        <a href="#element-value-of"><code>xsl:value-of</code></a>
        or <a href="#element-text"><code>xsl:text</code></a>
        instruction specifies that output escaping is to be
        disabled and the implementation does not support this. The
        <a title="optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is to ignore the <code>disable-output-escaping</code>
        attribute.</p>

        <p><a name="err-XTRE1630" id="err-XTRE1630"><span class=
        "error">[ERR XTRE1630]</span></a> It is a <a title=
        "recoverable error" href=
        "#dt-recoverable-error">recoverable dynamic error</a> if an
        <a href="#element-value-of"><code>xsl:value-of</code></a>
        or <a href="#element-text"><code>xsl:text</code></a>
        instruction specifies that output escaping is to be
        disabled when writing to a <a title="final result tree"
        href="#dt-final-result-tree">final result tree</a> that is
        not being serialized. The <a title=
        "optional recovery action" href=
        "#dt-optional-recovery-action">optional recovery action</a>
        is to ignore the <code>disable-output-escaping</code>
        attribute.</p>

        <p>If output escaping is disabled for a character that is
        not representable in the encoding that the <a title=
        "processor" href="#dt-processor">processor</a> is using for
        output, the request to disable output escaping is ignored
        in respect of that character.</p>

        <p>Since disabling output escaping might not work with all
        implementations and can result in XML that is not
        well-formed, it <span class="verb">should</span> be used
        only when there is no alternative.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The facility to define character maps for use during
          serialization, as described in <a href=
          "#character-maps"><i>20.1 Character Maps</i></a>, has
          been produced as an alternative mechanism that can be
          used in many situations where disabling of output
          escaping was previously necessary, without the same
          difficulties.</p>
        </div>
      </div>
    </div>

    <div class="div1">
      <h2><a name="conformance" id="conformance"></a>21
      Conformance</h2>

      <p>A <a title="processor" href="#dt-processor">processor</a>
      that claims conformance with this specification <span class=
      "verb">must</span> claim conformance either as a <a title=
      "basic XSLT processor" href="#dt-basic-xslt-processor">basic
      XSLT processor</a> or as a <a title=
      "schema-aware XSLT processor" href=
      "#dt-schema-aware-xslt-processor">schema-aware XSLT
      processor</a>. The rules for these two conformance levels are
      defined in the following sections.</p>

      <p>A processor that claims conformance at either of these two
      levels <span class="verb">may</span> additionally claim
      conformance with either or both of the following optional
      features: the serialization feature, defined in <a href=
      "#serialization-feature"><i>21.3 Serialization
      Feature</i></a>, and the backwards compatibility feature,
      defined in <a href="#backwards-compatibility-feature"><i>21.4
      Backwards Compatibility Feature</i></a>.</p>

      <div class="note">
        <p class="prefix"><b>Note:</b></p>

        <p>There is no conformance level or feature defined in this
        specification that requires implementation of the static
        typing features described in <a href="#xpath20">[XPath
        2.0]</a>. An XSLT processor may provide a user option to
        invoke static typing, but to be conformant with this
        specification it must allow a stylesheet to be processed
        with static typing disabled. The interaction of XSLT
        stylesheets with the static typing feature of XPath 2.0 has
        not been specified, so the results of using static typing,
        if available, are implementation-defined.</p>
      </div>

      <p>An XSLT processor takes as its inputs a stylesheet and one
      or more <span>XDM trees conforming to</span> the data model
      defined in <a href="#xpath-datamodel">[Data Model]</a>. It is
      not <span class="verb">required</span> that the processor
      supports any particular method of constructing <span>XDM
      trees</span>, but conformance can only be tested if it
      provides a mechanism that enables <span>XDM trees</span>
      representing the stylesheet and primary source document to be
      constructed and supplied as input to the processor.</p>

      <p>The output of the XSLT processor consists of
      <span>zero</span> or more <a title="final result tree" href=
      "#dt-final-result-tree">final result trees</a>. It is not
      <span class="verb">required</span> that the processor
      supports any particular method of accessing a final result
      tree, but if it does not support the serialization module,
      conformance can only be tested if it provides some
      alternative mechanism that enables access to the results of
      the transformation.</p>

      <p>Certain facilities in this specification are described as
      producing <a title="implementation-defined" href=
      "#dt-implementation-defined">implementation-defined</a>
      results. A claim that asserts conformance with this
      specification <span class="verb">must</span> be accompanied
      by documentation stating the effect of each
      implementation-defined feature. For convenience, a
      non-normative checklist of implementation-defined features is
      provided at <a href="#implementation-defined-features"><i>F
      Checklist of Implementation-Defined Features</i></a>.</p>

      <p>A conforming <a title="processor" href=
      "#dt-processor">processor</a> <span class="verb">must</span>
      signal any <a title="static error" href=
      "#dt-static-error">static error</a> occurring in the
      stylesheet, or in any XPath <a title="expression" href=
      "#dt-expression">expression</a>, except where specified
      otherwise either for individual error conditions or under the
      general provisions for <a title=
      "forwards-compatible behavior" href=
      "#dt-forwards-compatible-behavior">forwards compatible
      behavior</a> (see <a href="#forwards"><i>3.9
      Forwards-Compatible Processing</i></a>). After signaling such
      an error, the processor <span class="verb">may</span>
      continue for the purpose of signaling additional errors, but
      <span class="verb">must</span> terminate abnormally without
      performing any transformation.</p>

      <p>When a <a title="dynamic error" href=
      "#dt-dynamic-error">dynamic error</a> occurs during the
      course of a transformation, the action depends on whether the
      error is classified as a <a title="recoverable error" href=
      "#dt-recoverable-error">recoverable error</a>. If a
      non-recoverable error occurs, the processor <span class=
      "verb">must</span> signal it and <span class=
      "verb">must</span> eventually terminate abnormally. If a
      recoverable error occurs, the processor <span class=
      "verb">must</span> either signal it and terminate abnormally,
      or it <span class="verb">must</span> take the defined
      recovery action and continue processing.</p>

      <p>Some errors, notably <a title="type errors" href=
      "#dt-type-error">type errors</a>, <span class=
      "verb">may</span> be treated as <a title="static error" href=
      "#dt-static-error">static errors</a> or <a title=
      "dynamic error" href="#dt-dynamic-error">dynamic errors</a>
      at the discretion of the processor.</p>

      <p>A conforming processor <span class="verb">may</span>
      impose limits on the processing resources consumed by the
      processing of a stylesheet.</p>

      <div class="div2">
        <h3><a name="basic-conformance" id=
        "basic-conformance"></a>21.1 Basic XSLT Processor</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-basic-xslt-processor" id="dt-basic-xslt-processor"
        title="basic XSLT processor"></a>A <b>basic XSLT
        processor</b> is an XSLT processor that implements all the
        mandatory requirements of this specification with the
        exception of certain explicitly-identified constructs
        related to schema processing.<span class=
        "definition">]</span> These constructs are listed
        below.</p>

        <p>The mandatory requirements of this specification are
        taken to include the mandatory requirements of XPath 2.0,
        as described in <a href="#xpath20">[XPath 2.0]</a>. A
        requirement is mandatory unless the specification includes
        wording (such as the use of the words <span class=
        "verb">should</span> or <span class="verb">may</span>) that
        clearly indicates that it is optional.</p>

        <p>A <a title="basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a>
        <span class="verb">must</span> enforce the following
        restrictions. It <span class="verb">must</span> signal a
        static or dynamic error when the restriction is violated,
        as described below.</p>

        <p><a name="err-XTSE1650" id="err-XTSE1650"><span class=
        "error">[ERR XTSE1650]</span></a> A <a title=
        "basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a>
        <span class="verb">must</span> signal a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> includes an <a href=
        "#element-import-schema"><code>xsl:import-schema</code></a>
        declaration.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>A processor that rejects an <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          declaration will also reject any reference to a
          user-defined type defined in a schema, or to a
          user-defined element or attribute declaration; it will
          not, however, reject references to the built-in types
          listed in <a href="#built-in-types"><i>3.13 Built-in
          Types</i></a>.</p>
        </div>

        <p><a name="err-XTSE1660" id="err-XTSE1660"><span class=
        "error">[ERR XTSE1660]</span></a> A <a title=
        "basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a>
        <span class="verb">must</span> signal a <a title=
        "static error" href="#dt-static-error">static error</a> if
        the <a title="stylesheet" href=
        "#dt-stylesheet">stylesheet</a> includes an
        <code>[xsl:]type</code> attribute, or an
        <code>[xsl:]validation</code> or
        <code>default-validation</code> attribute with a value
        other than <code>strip</code>.</p>

        <p>A <a title="basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a>
        constrains the data model as follows:</p>

        <ul>
          <li>
            <p>Atomic values <span class="verb">must</span> belong
            to one of the atomic types listed in <a href=
            "#built-in-types"><i>3.13 Built-in Types</i></a>
            (except as noted below).</p>

            <p>An atomic value may also belong to an
            implementation-defined type that has been added to the
            context for use with <a title="extension function"
            href="#dt-extension-function">extension functions</a>
            or <a title="extension instruction" href=
            "#dt-extension-instruction">extension
            instructions</a>.</p>

            <p>The set of constructor functions available are
            limited to those that construct values of the above
            atomic types.</p>

            <p>The static context, which defines the full set of
            type names recognized by an XSLT processor and also by
            the XPath processor, includes these atomic types, plus
            <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
            <span><code>xs:untyped</code></span>, and
            <span><code>xs:anyAtomicType</code></span>.</p>
          </li>

          <li>
            <p>Element nodes <span class="verb">must</span> be
            annotated with the <a title="type annotation" href=
            "#dt-annotation">type annotation</a>
            <span><code>xs:untyped</code></span>, and attribute
            nodes with the type annotation
            <code>xs:untypedAtomic</code>.</p>
          </li>
        </ul>

        <p><a name="err-XTDE1665" id="err-XTDE1665"><span class=
        "error">[ERR XTDE1665]</span></a> A <a title=
        "basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a>
        <span class="verb">must</span> raise a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if the input to the processor includes a node
        with a <a title="type annotation" href=
        "#dt-annotation">type annotation</a> other than
        <span><code>xs:untyped</code></span> or
        <span><code>xs:untypedAtomic</code></span>, or an atomic
        value of a type other than those which a basic XSLT
        processor supports. <span>This error will not arise if the
        <code>input-type-annotations</code> attribute is set to
        <code>strip</code>.</span></p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>Although this is expressed in terms of a requirement
          to detect invalid input, an alternative approach is for a
          basic XSLT processor to prevent this error condition
          occurring, by not providing any interfaces that would
          allow the situation to arise. A processor might, for
          example, implement a mapping from the PSVI to the data
          model that loses all non-trivial <a title=
          "type annotation" href="#dt-annotation">type
          annotations</a>; or it might not accept input from a PSVI
          at all.</p>

          <p>The phrase <em>input to the processor</em> is
          deliberately wide: it includes the tree containing the
          <a title="initial context node" href=
          "#dt-initial-context-node">initial context node</a>,
          trees passed as <a title="stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameters</a>,
          trees accessed using the <a href=
          "#function-document"><code>document</code></a>, <a href=
          "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
          <small>FO</small></sup>, and <a href=
          "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
          collection</code></a><sup><small>FO</small></sup>
          functions, and trees returned by <a title=
          "extension function" href=
          "#dt-extension-function">extension functions</a> and
          <a title="extension instruction" href=
          "#dt-extension-instruction">extension
          instructions</a>.</p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="schema-aware-conformance" id=
        "schema-aware-conformance"></a>21.2 Schema-Aware XSLT
        Processor</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-schema-aware-xslt-processor" id=
        "dt-schema-aware-xslt-processor" title=
        "schema-aware XSLT processor"></a>A <b>schema-aware XSLT
        processor</b> is an XSLT processor that implements all the
        mandatory requirements of this specification, including
        those features that a <a title="basic XSLT processor" href=
        "#dt-basic-xslt-processor">basic XSLT processor</a> signals
        as an error. The mandatory requirements of this
        specification are taken to include the mandatory
        requirements of XPath 2.0, as described in <a href=
        "#xpath20">[XPath 2.0]</a>. A requirement is mandatory
        unless the specification includes wording (such as the use
        of the words <span class="verb">should</span> or
        <span class="verb">may</span>) that clearly indicates that
        it is optional.<span class="definition">]</span></p>
      </div>

      <div class="div2">
        <h3><a name="serialization-feature" id=
        "serialization-feature"></a>21.3 Serialization Feature</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-serialization-feature" id="dt-serialization-feature"
        title="serialization feature"></a>A processor that claims
        conformance with the <b>serialization feature</b>
        <span class="verb">must</span> support the conversion of a
        <a title="final result tree" href=
        "#dt-final-result-tree">final result tree</a> to a sequence
        of <span>octets</span> following the rules defined in
        <a href="#serialization"><i>20
        Serialization</i></a>.<span class="definition">]</span> It
        <span class="verb">must</span> respect all the attributes
        of the <a href=
        "#element-output"><code>xsl:output</code></a> and <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declarations, and <span class="verb">must</span> provide
        all four output methods, <code>xml</code>,
        <code>xhtml</code>, <code>html</code>, and
        <code>text</code>. Where the specification uses words such
        as <span class="verb">must</span> and <span class=
        "verb">required</span>, then it <span class=
        "verb">must</span> serialize the result tree in precisely
        the way described; in other cases it <span class=
        "verb">may</span> use an alternative, equivalent
        representation.</p>

        <p>A processor may claim conformance with the serialization
        feature whether or not it supports the setting
        <code>disable-output-escaping="yes"</code> on <a href=
        "#element-text"><code>xsl:text</code></a>, or <a href=
        "#element-value-of"><code>xsl:value-of</code></a>.</p>

        <p>A processor that does not claim conformance with the
        serialization feature <span class="verb">must not</span>
        signal an error merely because the <a title="stylesheet"
        href="#dt-stylesheet">stylesheet</a> contains <a href=
        "#element-output"><code>xsl:output</code></a> or <a href=
        "#element-character-map"><code>xsl:character-map</code></a>
        declarations, <span>or serialization attributes on the
        <a href=
        "#element-result-document"><code>xsl:result-document</code></a>
        instruction. Such a processor <span class="verb">may</span>
        check that these declarations and attributes have valid
        values, but is not <span class="verb">required</span> to do
        so. Apart from optional validation,</span> these
        declarations <span class="verb">should</span> be
        ignored.</p>
      </div>

      <div class="div2">
        <h3><a name="backwards-compatibility-feature" id=
        "backwards-compatibility-feature"></a>21.4 Backwards
        Compatibility Feature</h3>

        <p><span class=
        "definition">[Definition:&#160;</span><a name=
        "dt-backwards-compatibility-feature" id=
        "dt-backwards-compatibility-feature" title=
        "backwards compatibility feature"></a>A processor that
        claims conformance with the <b>backwards compatibility
        feature</b> <span class="verb">must</span> support the
        processing of stylesheet instructions and XPath expressions
        with <a title="backwards compatible behavior" href=
        "#dt-backwards-compatible-behavior">backwards compatible
        behavior</a>, as defined in <a href="#backwards"><i>3.8
        Backwards-Compatible Processing</i></a>.<span class=
        "definition">]</span></p>

        <p>Note that a processor that does not claim conformance
        with the backwards compatibility feature <span class=
        "verb">must</span> raise a <a title=
        "non-recoverable dynamic error" href=
        "#dt-nonrec-dynamic-error">non-recoverable dynamic
        error</a> if an instruction is evaluated containing an
        <code>[xsl:]version</code> attribute that invokes backwards
        compatible behavior <span class="error">[see <a href=
        "#err-XTDE0160">ERR XTDE0160</a>]</span>.</p>

        <div class="note">
          <p class="prefix"><b>Note:</b></p>

          <p>The reason this is a dynamic error rather than a
          static error is to allow stylesheets to contain
          conditional logic, following different paths depending on
          whether the XSLT processor implements XSLT 1.0 or XSLT
          2.0. The selection of which path to use can be controlled
          by using the <a href=
          "#function-system-property"><code>system-property</code></a>
          function to test the <code>xsl:version</code> system
          property.</p>
        </div>

        <p>A processor that claims conformance with the backwards
        compatibility feature <span class="verb">must</span> permit
        the use of the namespace axis in XPath expressions when
        backwards compatible behavior is enabled. In all other
        circumstances, support for the namespace axis is
        optional.</p>
      </div>
    </div>
  </div>

  <div class="back">
    <div class="div1">
      <h2><a name="references" id="references"></a>A
      References</h2>

      <div class="div2">
        <h3><a name="normative-references" id=
        "normative-references"></a>A.1 Normative References</h3>

        <dl>
          <dt class="label"><span><a name="xpath-datamodel" id=
          "xpath-datamodel"></a>Data Model</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xpath-datamodel/"><cite>XQuery
              1.0 and XPath 2.0 Data Model (XDM)</cite></a>, Norman
              Walsh, Mary Fernández, Ashok Malhotra, <em>et.
              al.</em>, Editors. World Wide Web Consortium, 23 Jan
              2007. This version is
              http://www.w3.org/TR/2007/REC-xpath-datamodel-20070123/.
              The <a href=
              "http://www.w3.org/TR/xpath-datamodel/">latest
              version</a> is available at
              http://www.w3.org/TR/xpath-datamodel/.
            </div>
          </dd>

          <dt class="label"><span><a name="xpath-functions" id=
          "xpath-functions"></a>Functions and Operators</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xpath-functions/"><cite>XQuery
              1.0 and XPath 2.0 Functions and Operators</cite></a>,
              Ashok Malhotra, Jim Melton, and Norman Walsh,
              Editors. World Wide Web Consortium, 23 Jan 2007. This
              version is
              http://www.w3.org/TR/2007/REC-xpath-functions-20070123/.
              The <a href=
              "http://www.w3.org/TR/xpath-functions/">latest
              version</a> is available at
              http://www.w3.org/TR/xpath-functions/.
            </div>
          </dd>

          <dt class="label"><span><a name="xml-infoset" id=
          "xml-infoset"></a>XML Information Set</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xml-infoset"><cite>XML
              Information Set (Second Edition)</cite></a>, John
              Cowan and Richard Tobin, Editors. World Wide Web
              Consortium, 04&#160;Feb&#160;2004. This version is
              http://www.w3.org/TR/2004/REC-xml-infoset-20040204.
              The <a href="http://www.w3.org/TR/xml-infoset">latest
              version</a> is available at
              http://www.w3.org/TR/xml-infoset.
            </div>
          </dd>

          <dt class="label"><span><a name="ISO3166" id=
          "ISO3166"></a>ISO 3166-1</span></dt>

          <dd>
            <div>
              ISO (International Organization for Standardization)
              <em>Codes for the representation of names of
              countries and their subdivisions - Part 1: Country
              codes</em> ISO 3166-1:1997.
            </div>
          </dd>

          <dt class="label"><span><a name="ISO8601" id=
          "ISO8601"></a>ISO 8601</span></dt>

          <dd>
            <div>
              ISO (International Organization for Standardization)
              <em>Data elements and interchange formats -
              Information interchange - Representation of dates and
              times.</em> ISO 8601:2000(E), Second edition,
              2000-12-15.
            </div>
          </dd>

          <dt class="label"><span><a name=
          "xslt-xquery-serialization" id=
          "xslt-xquery-serialization"></a>XSLT and XQuery
          Serialization</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xslt-xquery-serialization/"><cite>
              XSLT 2.0 and XQuery 1.0 Serialization</cite></a>,
              Joanne Tong, Michael Kay, Norman Walsh, <em>et.
              al.</em>, Editors. World Wide Web Consortium, 23 Jan
              2007. This version is
              http://www.w3.org/TR/2007/REC-xslt-xquery-serialization-20070123/.
              The <a href=
              "http://www.w3.org/TR/xslt-xquery-serialization/">latest
              version</a> is available at
              http://www.w3.org/TR/xslt-xquery-serialization/.
            </div>
          </dd>

          <dt class="label"><span><a name="REC-xml" id=
          "REC-xml"></a>XML 1.0</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xml"><cite>Extensible
              Markup Language (XML) 1.0 (Fourth
              Edition)</cite></a>, Eve Maler, Jean Paoli, François
              Yergeau, <em>et. al.</em>, Editors. World Wide Web
              Consortium, 16&#160;Aug&#160;2006. This version is
              http://www.w3.org/TR/2006/REC-xml-20060816. The
              <a href="http://www.w3.org/TR/xml">latest version</a>
              is available at http://www.w3.org/TR/xml.
            </div>
          </dd>

          <dt class="label"><span><a name="xml11" id=
          "xml11"></a>XML 1.1</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xml11/"><cite>Extensible Markup
              Language (XML) 1.1 (Second Edition)</cite></a>, Tim
              Bray, John Cowan, Jean Paoli, <em>et. al.</em>,
              Editors. World Wide Web Consortium,
              16&#160;Aug&#160;2006. This version is
              http://www.w3.org/TR/2006/REC-xml11-20060816. The
              <a href="http://www.w3.org/TR/xml11/">latest
              version</a> is available at
              http://www.w3.org/TR/xml11/.
            </div>
          </dd>

          <dt class="label"><span><a name="xmlbase" id=
          "xmlbase"></a>XML Base</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xmlbase/"><cite>XML
              Base</cite></a>, Jonathan Marsh, Editor. World Wide
              Web Consortium, 27&#160;Jun&#160;2001. This version
              is http://www.w3.org/TR/2001/REC-xmlbase-20010627/.
              The <a href="http://www.w3.org/TR/xmlbase/">latest
              version</a> is available at
              http://www.w3.org/TR/xmlbase/.
            </div>
          </dd>

          <dt class="label"><span><a name="xml-id" id=
          "xml-id"></a>xml:id</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xml-id/"><cite>xml:id
              Version 1.0</cite></a>, Norman Walsh, Daniel
              Veillard, and Jonathan Marsh, Editors. World Wide Web
              Consortium, 09&#160;Sep&#160;2005. This version is
              http://www.w3.org/TR/2005/REC-xml-id-20050909/. The
              <a href="http://www.w3.org/TR/xml-id/">latest
              version</a> is available at
              http://www.w3.org/TR/xml-id/.
            </div>
          </dd>

          <dt class="label"><span><a name="REC-xml-names" id=
          "REC-xml-names"></a>Namespaces in XML 1.0</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/REC-xml-names"><cite>Namespaces
              in XML</cite></a>, Andrew Layman, Dave Hollander, and
              Tim Bray, Editors. World Wide Web Consortium,
              14&#160;Jan&#160;1999. This version is
              http://www.w3.org/TR/1999/REC-xml-names-19990114. The
              <a href="http://www.w3.org/TR/REC-xml-names">latest
              version</a> is available at
              http://www.w3.org/TR/REC-xml-names.
            </div>
          </dd>

          <dt class="label"><span><a name="xml-names11" id=
          "xml-names11"></a>Namespaces in XML 1.1</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xml-names11/"><cite>Namespaces
              in XML 1.1 (Second Edition)</cite></a>, Tim Bray,
              Dave Hollander, Andrew Layman, and Richard Tobin,
              Editors. World Wide Web Consortium,
              16&#160;Aug&#160;2006. This version is
              http://www.w3.org/TR/2006/REC-xml-names11-20060816.
              The <a href=
              "http://www.w3.org/TR/xml-names11/">latest
              version</a> is available at
              http://www.w3.org/TR/xml-names11/.
            </div>
          </dd>

          <dt class="label"><span><a name="xmlschema-1" id=
          "xmlschema-1"></a>XML Schema Part 1</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML
              Schema Part 1: Structures Second Edition</cite></a>,
              Henry S. Thompson, David Beech, Noah Mendelsohn, and
              Murray Maloney, Editors. World Wide Web Consortium,
              28&#160;Oct&#160;2004. This version is
              http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/.
              The <a href=
              "http://www.w3.org/TR/xmlschema-1/">latest
              version</a> is available at
              http://www.w3.org/TR/xmlschema-1/.
            </div>
          </dd>

          <dt class="label"><span><a name="xmlschema-2" id=
          "xmlschema-2"></a>XML Schema Part 2</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML
              Schema Part 2: Datatypes Second Edition</cite></a>,
              Paul V. Biron and Ashok Malhotra, Editors. World Wide
              Web Consortium, 28&#160;Oct&#160;2004. This version
              is
              http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/.
              The <a href=
              "http://www.w3.org/TR/xmlschema-2/">latest
              version</a> is available at
              http://www.w3.org/TR/xmlschema-2/.
            </div>
          </dd>

          <dt class="label"><span><a name="xpath20" id=
          "xpath20"></a>XPath 2.0</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xpath20/"><cite>XML
              Path Language (XPath) 2.0</cite></a>, Don Chamberlin
              , Anders Berglund, Scott Boag, <em>et. al.</em>,
              Editors. World Wide Web Consortium, 23 Jan 2007. This
              version is
              http://www.w3.org/TR/2007/REC-xpath20-20070123/. The
              <a href="http://www.w3.org/TR/xpath20/">latest
              version</a> is available at
              http://www.w3.org/TR/xpath20/.
            </div>
          </dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a name="other-references" id=
        "other-references"></a>A.2 Other References</h3>

        <dl>
          <dt class="label"><span><a name="CALCALC" id=
          "CALCALC"></a>Calendrical Calculations</span></dt>

          <dd>
            <div>
              Edward M. Reingold and Nachum Dershowitz.
              <em>Calendrical Calculations Millennium edition (2nd
              Edition)</em>. Cambridge University Press, ISBN 0 521
              77752 6
            </div>
          </dd>

          <dt class="label"><span><a name="DOM-Level-2-Core" id=
          "DOM-Level-2-Core"></a>DOM Level 2</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/DOM-Level-2-Core/"><cite>Document
              Object Model (DOM) Level 2 Core
              Specification</cite></a>, Philippe Le Hégaret, Steve
              Byrne, Arnaud Le Hors, <em>et. al.</em>, Editors.
              World Wide Web Consortium, 13&#160;Nov&#160;2000.
              This version is
              http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113.
              The <a href=
              "http://www.w3.org/TR/DOM-Level-2-Core/">latest
              version</a> is available at
              http://www.w3.org/TR/DOM-Level-2-Core/.
            </div>
          </dd>

          <dt class="label"><span><a name="RFC2119" id=
          "RFC2119"></a>RFC2119</span></dt>

          <dd>
            <div>
              S. Bradner. <em>Key words for use in RFCs to Indicate
              Requirement Levels</em>. IETF RFC 2119. See <a href=
              "http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.
            </div>
          </dd>

          <dt class="label"><span><a name="RFC2376" id=
          "RFC2376"></a>RFC2376</span></dt>

          <dd>
            <div>
              E. Whitehead, M. Murata. <em>XML Media Types</em>.
              IETF RFC 2376. See <a href=
              "http://www.ietf.org/rfc/rfc2376.txt">http://www.ietf.org/rfc/rfc2376.txt</a>.
            </div>
          </dd>

          <dt class="label"><span><a name="RFC3023" id=
          "RFC3023"></a>RFC3023</span></dt>

          <dd>
            <div>
              M. Murata, S. St.Laurent, and D. Cohn. <em>XML Media
              Types</em>. IETF RFC 3023. See <a href=
              "http://www.ietf.org/rfc/rfc3023.txt">http://www.ietf.org/rfc/rfc3023.txt</a>.
              <span>References to RFC 3023 should be taken to refer
              to any document that supersedes RFC 3023.</span>
            </div>
          </dd>

          <dt class="label"><span><a name="RFC3986" id=
          "RFC3986"></a>RFC3986</span></dt>

          <dd>
            <div>
              T. Berners-Lee, R. Fielding, and L. Masinter.
              <em>Uniform Resource Identifiers (URI): Generic
              Syntax</em>. IETF RFC 3986. See <a href=
              "http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.
            </div>
          </dd>

          <dt class="label"><span><a name="RFC3987" id=
          "RFC3987"></a>RFC3987</span></dt>

          <dd>
            <div>
              M. Duerst, M. Suignard. <em>Internationalized
              Resource Identifiers (IRIs)</em>. IETF RFC 3987. See
              <a href=
              "http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.
            </div>
          </dd>

          <dt class="label"><span><a name="UNICODE-TR10" id=
          "UNICODE-TR10"></a>UNICODE TR10</span></dt>

          <dd>
            <div>
              Unicode Consortium. <em>Unicode Technical Standard
              #10. Unicode Collation Algorithm</em>. Unicode
              Technical Report. See <a href=
              "http://www.unicode.org/unicode/reports/tr10/">http://www.unicode.org/unicode/reports/tr10/</a>.
            </div>
          </dd>

          <dt class="label"><span><a name="xinclude" id=
          "xinclude"></a>XInclude</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xinclude/"><cite>XML
              Inclusions (XInclude) Version 1.0 (Second
              Edition)</cite></a>, David Orchard, Jonathan Marsh,
              and Daniel Veillard, Editors. World Wide Web
              Consortium, 15&#160;Nov&#160;2006. This version is
              http://www.w3.org/TR/2006/REC-xinclude-20061115/. The
              <a href="http://www.w3.org/TR/xinclude/">latest
              version</a> is available at
              http://www.w3.org/TR/xinclude/.
            </div>
          </dd>

          <dt class="label"><span><a name="xlink" id=
          "xlink"></a>XLink</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xlink/"><cite>XML
              Linking Language (XLink) Version 1.0</cite></a>,
              David Orchard, Eve Maler, and Steven DeRose, Editors.
              World Wide Web Consortium, 27&#160;Jun&#160;2001.
              This version is
              http://www.w3.org/TR/2001/REC-xlink-20010627/. The
              <a href="http://www.w3.org/TR/xlink/">latest
              version</a> is available at
              http://www.w3.org/TR/xlink/.
            </div>
          </dd>

          <dt class="label"><span><a name="SCHEMA-AND-XML-1.1" id=
          "SCHEMA-AND-XML-1.1"></a>XML Schema 1.0 and XML
          1.1</span></dt>

          <dd>
            <div>
              World Wide Web Consortium. <em>Processing XML 1.1
              documents with XML Schema 1.0 processors</em>. W3C
              Working Group Note 11 May 2005. See <a href=
              "http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">
              http://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</a>
            </div>
          </dd>

          <dt class="label"><span><a name="xml-stylesheet" id=
          "xml-stylesheet"></a>XML Stylesheet</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xml-stylesheet"><cite>Associating
              Style Sheets with XML documents</cite></a>, James
              Clark, Editor. World Wide Web Consortium,
              29&#160;Jun&#160;1999. This version is
              http://www.w3.org/1999/06/REC-xml-stylesheet-19990629.
              The <a href=
              "http://www.w3.org/TR/xml-stylesheet">latest
              version</a> is available at
              http://www.w3.org/TR/xml-stylesheet.
            </div>
          </dd>

          <dt class="label"><span><a name="xptr-framework" id=
          "xptr-framework"></a>XPointer Framework</span></dt>

          <dd>
            <div>
              <a href=
              "http://www.w3.org/TR/xptr-framework/"><cite>XPointer
              Framework</cite></a>, Paul Grosso, Jonathan Marsh,
              Eve Maler, and Norman Walsh, Editors. World Wide Web
              Consortium, 25&#160;Mar&#160;2003. This version is
              http://www.w3.org/TR/2003/REC-xptr-framework-20030325/.
              The <a href=
              "http://www.w3.org/TR/xptr-framework/">latest
              version</a> is available at
              http://www.w3.org/TR/xptr-framework/.
            </div>
          </dd>

          <dt class="label"><span><a name="xsl" id=
          "xsl"></a>Extensible Stylesheet Language
          (XSL)</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xsl/"><cite>Extensible
              Stylesheet Language (XSL) Version 1.1</cite></a>,
              Anders Berglund, Editor. World Wide Web Consortium,
              05&#160;Dec&#160;2006. This version is
              http://www.w3.org/TR/2006/REC-xsl11-20061205/. The
              <a href="http://www.w3.org/TR/xsl/">latest
              version</a> is available at
              http://www.w3.org/TR/xsl/.
            </div>
          </dd>

          <dt class="label"><span><a name="xslt" id="xslt"></a>XSLT
          1.0</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xslt"><cite>XSL
              Transformations (XSLT) Version 1.0</cite></a>, James
              Clark, Editor. World Wide Web Consortium,
              16&#160;Nov&#160;1999. This version is
              http://www.w3.org/TR/1999/REC-xslt-19991116. The
              <a href="http://www.w3.org/TR/xslt">latest
              version</a> is available at
              http://www.w3.org/TR/xslt.
            </div>
          </dd>

          <dt class="label"><span><a name="xslt20req" id=
          "xslt20req"></a>XSLT 2.0 Requirements</span></dt>

          <dd>
            <div>
              <a href="http://www.w3.org/TR/xslt20req"><cite>XSLT
              Requirements Version 2.0</cite></a>, Steve Muench and
              Mark Scardina, Editors. World Wide Web Consortium,
              14&#160;Feb&#160;2001. This version is
              http://www.w3.org/TR/2001/WD-xslt20req-20010214. The
              <a href="http://www.w3.org/TR/xslt20req">latest
              version</a> is available at
              http://www.w3.org/TR/xslt20req.
            </div>
          </dd>
        </dl>
      </div>
    </div>

    <div class="div1">
      <h2><a name="xslt-mime-definition" id=
      "xslt-mime-definition"></a>B The XSLT Media Type</h2>

      <p>This appendix registers a new MIME media type,
      "<code>application/xslt+xml</code>".</p>

      <p>This information is being submitted to the IESG (Internet
      Engineering Steering Group) for review, approval, and
      registration with IANA (the Internet Assigned Numbers
      Authority).</p>

      <div class="div2">
        <h3><a name="media-type-registration" id=
        "media-type-registration"></a>B.1 Registration of MIME
        Media Type application/xslt+xml</h3>

        <dl>
          <dt class="label">MIME media type name:</dt>

          <dd>
            <p><code>application</code></p>
          </dd>

          <dt class="label">MIME subtype name:</dt>

          <dd>
            <p><code>xslt+xml</code></p>
          </dd>

          <dt class="label">Required parameters:</dt>

          <dd>
            <p>None.</p>
          </dd>

          <dt class="label">Optional parameters:</dt>

          <dd>
            <dl>
              <dt class="label"><code>charset</code></dt>

              <dd>
                <p>This parameter has identical semantics to the
                <code>charset</code> parameter of the
                <code>application/xml</code> media type as
                specified in <a href="#RFC3023">[RFC3023]</a>.</p>
              </dd>
            </dl>
          </dd>

          <dt class="label">Encoding considerations:</dt>

          <dd>
            <p>By virtue of XSLT content being XML, it has the same
            considerations when sent as
            "<code>application/xslt+xml</code>" as does XML. See
            RFC 3023, section 3.2.</p>
          </dd>

          <dt class="label">Security considerations:</dt>

          <dd>
            <p>Several XSLT instructions may cause arbitrary URIs
            to be dereferenced. In this case, the security issues
            of <span><a href="#RFC3986">[RFC3986]</a>, section
            7,</span> should be considered.</p>

            <p>In addition, because of the extensibility features
            for XSLT, it is possible that
            "<code>application/xslt+xml</code>" may describe
            content that has security implications beyond those
            described here. However, if the processor follows only
            the normative semantics of this specification, this
            content will be ignored. Only in the case where the
            processor recognizes and processes the additional
            content, or where further processing of that content is
            dispatched to other processors, would security issues
            potentially arise. And in that case, they would fall
            outside the domain of this registration document.</p>
          </dd>

          <dt class="label">Interoperability considerations:</dt>

          <dd>
            <p>This specification describes processing semantics
            that dictate behavior that must be followed when
            dealing with, among other things, unrecognized
            elements.</p>

            <p>Because XSLT is extensible, conformant
            "<code>application/xslt+xml</code>" processors can
            expect that content received is well-formed XML, but it
            cannot be guaranteed that the content is valid XSLT or
            that the processor will recognize all of the elements
            and attributes in the document.</p>
          </dd>

          <dt class="label">Published specification:</dt>

          <dd>
            <p>This media type registration is for XSLT stylesheet
            modules as described by the XSLT 2.0 specification,
            <span>which is located at <a href=
            "http://www.w3.org/TR/xslt20/">http://www.w3.org/TR/xslt20/</a>.</span>
            It is also appropriate to use this media type with
            earlier and later versions of the XSLT language.</p>
          </dd>

          <dt class="label">Applications which use this media
          type:</dt>

          <dd>
            <p>Existing XSLT 1.0 stylesheets are most often
            described using the unregistered media type
            "<code>text/xsl</code>".</p>

            <p>There is no experimental, vendor specific, or
            personal tree predecessor to
            "<code>application/xslt+xml</code>", reflecting the
            fact that no applications currently recognize it. This
            new type is being registered in order to allow for the
            expected deployment of XSLT 2.0 on the World Wide Web,
            as a first class XML application.</p>
          </dd>

          <dt class="label">Additional information:</dt>

          <dd>
            <dl>
              <dt class="label">Magic number(s):</dt>

              <dd>
                <p>There is no single initial octet sequence that
                is always present in XSLT documents.</p>
              </dd>

              <dt class="label">File extension(s):</dt>

              <dd>
                <p>XSLT documents are most often identified with
                the extensions "<code>.xsl</code>" or
                "<code>.xslt</code>".</p>
              </dd>

              <dt class="label">Macintosh File Type Code(s):</dt>

              <dd>
                <p>TEXT</p>
              </dd>
            </dl>
          </dd>

          <dt class="label">Person &amp; email address to contact
          for further information:</dt>

          <dd>
            <p>Norman Walsh, <code>&lt;<a href=
            "mailto:Norman.Walsh@Sun.COM">Norman.Walsh@Sun.COM</a>&gt;</code>.</p>
          </dd>

          <dt class="label">Intended usage:</dt>

          <dd>
            <p>COMMON</p>
          </dd>

          <dt class="label">Author/Change controller:</dt>

          <dd>
            <p>The XSLT specification is a work product of the
            World Wide Web Consortium's XSL Working Group. The W3C
            has change control over these specifications.</p>
          </dd>
        </dl>
      </div>

      <div class="div2">
        <h3><a name="media-type-fragid" id=
        "media-type-fragid"></a>B.2 Fragment Identifiers</h3>

        <p>For documents labeled as
        "<code>application/xslt+xml</code>", the fragment
        identifier notation is exactly that for
        "<code>application/xml</code>", as specified in RFC
        3023.</p>
      </div>
    </div>

    <div class="div1">
      <h2><a name="glossary" id="glossary"></a>C Glossary
      (Non-Normative)</h2>

      <dl>
        <dt><a href="#dt-qname">QName</a></dt>

        <dd>
          <p>A <b>QName</b> is always written in the form
          <code>(NCName ":")? NCName</code>, that is, a local name
          optionally preceded by a namespace prefix. When two
          QNames are compared, however, they are considered equal
          if the corresponding <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QNames</a> are the same, as
          described below.</p>
        </dd>

        <dt><a href="#dt-uri-reference">URI Reference</a></dt>

        <dd>
          <p>Within this specification, the term <b>URI
          Reference</b>, unless otherwise stated, refers to a
          string in the lexical space of the <code>xs:anyURI</code>
          data type as defined in <a href="#xmlschema-2">[XML
          Schema Part 2]</a>.</p>
        </dd>

        <dt><a href="#xml-namespace">XML namespace</a></dt>

        <dd>
          <p>The <b>XML namespace</b>, <span>defined in <a href=
          "#REC-xml-names">[Namespaces in XML 1.0]</a> as
          <code>http://www.w3.org/XML/1998/namespace</code></span>,
          is used for attributes such as <code>xml:lang</code>,
          <code>xml:space</code>, and <code>xml:id</code>.</p>
        </dd>

        <dt><a href="#dt-compatibility-mode">XPath 1.0
        compatibility mode</a></dt>

        <dd>
          <p>The term <b>XPath 1.0 compatibility mode</b> is
          defined in <a href=
          "http://www.w3.org/TR/xpath20/#static_context">Section
          2.1.1 Static Context</a><sup><small>XP</small></sup>.
          This is a setting in the static context of an XPath
          expression; it has two values, <code>true</code> and
          <code>false</code>. When the value is set to true, the
          semantics of function calls and certain other operations
          are adjusted to give a greater degree of backwards
          compatibility between XPath 2.0 and XPath 1.0.</p>
        </dd>

        <dt><a href="#dt-xslt-element">XSLT element</a></dt>

        <dd>
          <p>An <b>XSLT element</b> is an element in the <a title=
          "XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a> whose syntax and semantics are defined in
          this specification.</p>
        </dd>

        <dt><a href="#dt-xslt-instruction">XSLT
        instruction</a></dt>

        <dd>
          <p>An <b>XSLT instruction</b> is an <a title=
          "XSLT element" href="#dt-xslt-element">XSLT element</a>
          whose syntax summary in this specification contains the
          annotation <code>&lt;!-- category: instruction
          --&gt;</code>.</p>
        </dd>

        <dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt>

        <dd>
          <p>The <b>XSLT namespace</b> has the URI
          <code>http://www.w3.org/1999/XSL/Transform</code>. It is
          used to identify elements, attributes, and other names
          that have a special meaning defined in this
          specification.</p>
        </dd>

        <dt><a href="#dt-alias">alias</a></dt>

        <dd>
          <p>A stylesheet can use the <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          element to declare that a <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> is
          being used as an <b>alias</b> for a <a title=
          "target namespace URI" href=
          "#dt-target-namespace-uri">target namespace URI</a>.</p>
        </dd>

        <dt><a href="#dt-arity">arity</a></dt>

        <dd>
          <p>The <b>arity</b> of a stylesheet function is the
          number of <a href=
          "#element-param"><code>xsl:param</code></a> elements in
          the function definition.</p>
        </dd>

        <dt><a href="#dt-atomization">atomize</a></dt>

        <dd>
          <p>The term <b>atomization</b> is defined in <a href=
          "http://www.w3.org/TR/xpath20/#id-atomization">Section
          2.4.2 Atomization</a><sup><small>XP</small></sup>. It is
          a process that takes as input a sequence of nodes and
          atomic values, and returns a sequence of atomic values,
          in which the nodes are replaced by their typed values as
          defined in <a href="#xpath-datamodel">[Data
          Model]</a>.</p>
        </dd>

        <dt><a href="#dt-attribute-set">attribute set</a></dt>

        <dd>
          <p>The <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a>
          element defines a named <b>attribute set</b>: that is, a
          collection of attribute <span>definitions</span> that can
          be used repeatedly on different constructed elements.</p>
        </dd>

        <dt><a href="#dt-attribute-value-template">attribute value
        template</a></dt>

        <dd>
          <p>In an attribute that is designated as an <b>attribute
          value template</b>, such as an attribute of a <a title=
          "literal result element" href=
          "#dt-literal-result-element">literal result element</a>,
          an <a title="expression" href=
          "#dt-expression">expression</a> can be used by
          surrounding the expression with curly brackets
          (<code>{}</code>)</p>
        </dd>

        <dt><a href="#dt-backwards-compatibility-feature">backwards
        compatibility feature</a></dt>

        <dd>
          <p>A processor that claims conformance with the
          <b>backwards compatibility feature</b> <span class=
          "verb">must</span> support the processing of stylesheet
          instructions and XPath expressions with <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a>, as defined in <a href="#backwards"><i>3.8
          Backwards-Compatible Processing</i></a>.</p>
        </dd>

        <dt><a href="#dt-backwards-compatible-behavior">backwards
        compatible behavior</a></dt>

        <dd>
          <p>An element enables backwards-compatible behavior for
          itself, its attributes, its descendants and their
          attributes if it has an <code>[xsl:]version</code>
          attribute (see <a href="#standard-attributes"><i>3.5
          Standard Attributes</i></a>) whose value is less than
          <code>2.0</code>.</p>
        </dd>

        <dt><a href="#dt-base-output-uri">base output URI</a></dt>

        <dd>
          <p>The <b>base output URI</b> is a URI to be used as the
          base URI when resolving a relative URI allocated to a
          <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a>. If the
          transformation generates more than one final result tree,
          then typically each one will be allocated a URI relative
          to this base URI.</p>
        </dd>

        <dt><a href="#dt-basic-xslt-processor">basic XSLT
        processor</a></dt>

        <dd>
          <p>A <b>basic XSLT processor</b> is an XSLT processor
          that implements all the mandatory requirements of this
          specification with the exception of certain
          explicitly-identified constructs related to schema
          processing.</p>
        </dd>

        <dt><a href="#dt-character-map">character map</a></dt>

        <dd>
          <p>A <b>character map</b> allows a specific character
          appearing in a text or attribute node in the <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> to be substituted by a specified string
          of characters during serialization.</p>
        </dd>

        <dt><a href="#dt-circularity">circularity</a></dt>

        <dd>
          <p>A <b>circularity</b> is said to exist if a construct
          such as a <a title="global variable" href=
          "#dt-global-variable">global variable</a>, an <a title=
          "attribute set" href="#dt-attribute-set">attribute
          set</a>, or a <a title="key" href="#dt-key">key</a> is
          defined in terms of itself. For example, if the <a title=
          "expression" href="#dt-expression">expression</a> or
          <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>
          specifying the value of a <a title="global variable"
          href="#dt-global-variable">global variable</a>
          <var>X</var> references a global variable <var>Y</var>,
          then the value for <var>Y</var> <span class=
          "verb">must</span> be computed before the value of
          <var>X</var>. A circularity exists if it is impossible to
          do this for all global variable definitions.</p>
        </dd>

        <dt><a href="#dt-collation">collation</a></dt>

        <dd>
          <p>Facilities in XSLT 2.0 and XPath 2.0 that require
          strings to be ordered rely on the concept of a named
          <b>collation</b>. A collation is a set of rules that
          determine whether two strings are equal, and if not,
          which of them is to be sorted before the other.</p>
        </dd>

        <dt><a href="#dt-context-item">context item</a></dt>

        <dd>
          <p>The <b>context item</b> is the item currently being
          processed. An item (see <a href="#xpath-datamodel">[Data
          Model]</a>) is either an atomic value (such as an
          integer, date, or string), or a node. The context item is
          initially set to the <a title="initial context node"
          href="#dt-initial-context-node">initial context node</a>
          supplied when the transformation is invoked (see <a href=
          "#initiating"><i>2.3 Initiating a
          Transformation</i></a>). It changes whenever instructions
          such as <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          and <a href=
          "#element-for-each"><code>xsl:for-each</code></a> are
          used to process a sequence of items; each item in such a
          sequence becomes the context item while that item is
          being processed.</p>
        </dd>

        <dt><a href="#dt-context-node">context node</a></dt>

        <dd>
          <p>If the <a title="context item" href=
          "#dt-context-item">context item</a> is a node (as
          distinct from an atomic value such as an integer), then
          it is also referred to as the <b>context node</b>. The
          context node is not an independent variable, it changes
          whenever the context item changes. When the context item
          is an atomic value, there is no context node.</p>
        </dd>

        <dt><a href="#dt-context-position">context
        position</a></dt>

        <dd>
          <p>The <b>context position</b> is the position of the
          context item within the sequence of items currently being
          processed. It changes whenever the context item changes.
          When an instruction such as <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          or <a href=
          "#element-for-each"><code>xsl:for-each</code></a> is used
          to process a sequence of items, the first item in the
          sequence is processed with a context position of 1, the
          second item with a context position of 2, and so on.</p>
        </dd>

        <dt><a href="#dt-context-size">context size</a></dt>

        <dd>
          <p>The <b>context size</b> is the number of items in the
          sequence of items currently being processed. It changes
          whenever instructions such as <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          and <a href=
          "#element-for-each"><code>xsl:for-each</code></a> are
          used to process a sequence of items; during the
          processing of each one of those items, the context size
          is set to the count of the number of items in the
          sequence (or equivalently, the position of the last item
          in the sequence).</p>
        </dd>

        <dt><a href="#dt-core-function">core function</a></dt>

        <dd>
          <p>The term <b>core function</b> means a function that is
          specified in <a href="#xpath-functions">[Functions and
          Operators]</a> and that is in the <a title=
          "standard function namespace" href=
          "#dt-standard-function-namespace">standard function
          namespace</a>.</p>
        </dd>

        <dt><a href="#dt-current-captured-substrings">current
        captured substrings</a></dt>

        <dd>
          <p>While the <a href=
          "#element-matching-substring"><code>xsl:matching-substring</code></a>
          instruction is active, a set of <b>current captured
          substrings</b> is available, corresponding to the
          parenthesized sub-expressions of the regular
          expression.</p>
        </dd>

        <dt><a href="#dt-current-group">current group</a></dt>

        <dd>
          <p>The evaluation context for XPath <a title="expression"
          href="#dt-expression">expressions</a> includes a
          <span>component</span> called the <b>current group</b>,
          which is a sequence. The current group is the collection
          of related items that are processed collectively in one
          iteration of the <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          element.</p>
        </dd>

        <dt><a href="#dt-current-grouping-key">current grouping
        key</a></dt>

        <dd>
          <p>The evaluation context for XPath <a title="expression"
          href="#dt-expression">expressions</a> includes a
          component called the <b>current grouping key</b>, which
          is an atomic value. The current grouping key is <span>the
          <a title="grouping key" href="#dt-grouping-key">grouping
          key</a></span> shared in common by all the items within
          the <a title="current group" href=
          "#dt-current-group">current group</a>.</p>
        </dd>

        <dt><a href="#dt-current-mode">current mode</a></dt>

        <dd>
          <p>At any point in the processing of a stylesheet, there
          is a <b>current mode</b>. When the transformation is
          initiated, the current mode is the <a title=
          "default mode" href="#dt-default-mode">default mode</a>,
          <span>unless a different initial mode has been supplied,
          as described in <a href="#initiating"><i>2.3 Initiating a
          Transformation</i></a>.</span> Whenever an <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction is evaluated, the current mode becomes the
          mode selected by this instruction.</p>
        </dd>

        <dt><a href="#dt-current-template-rule">current template
        rule</a></dt>

        <dd>
          <p>At any point in the processing of a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>, there
          may be a <b>current template rule</b>. Whenever a
          <a title="template rule" href=
          "#dt-template-rule">template rule</a> is chosen <span>as
          a result of evaluating <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          or <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>,
          the template rule becomes the current template rule for
          the evaluation of the rule's sequence constructor. When
          an <a href=
          "#element-for-each"><code>xsl:for-each</code></a>,
          <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>,
          <span>or <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          instruction is evaluated, or when evaluating a sequence
          constructor contained in an <a href=
          "#element-sort"><code>xsl:sort</code></a> or <a href=
          "#element-key"><code>xsl:key</code></a> element, or
          when</span> a <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a> is
          called (see <a href="#stylesheet-functions"><i>10.3
          Stylesheet Functions</i></a>), the current template rule
          becomes null for the evaluation of that instruction or
          function.</p>
        </dd>

        <dt><a href="#dt-date-formatting-function">date formatting
        function</a></dt>

        <dd>
          <p>The three functions <a href=
          "#function-format-date"><code>format-date</code></a>,
          <a href=
          "#function-format-time"><code>format-time</code></a>, and
          <a href=
          "#function-format-dateTime"><code>format-dateTime</code></a>
          are referred to collectively as the <b>date formatting
          functions</b>.</p>
        </dd>

        <dt><a href="#dt-decimal-format">decimal format</a></dt>

        <dd>
          <p>All the <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations in a stylesheet that share the same name are
          grouped into a named <b>decimal format</b>; those that
          have no name are grouped into a single unnamed decimal
          format.</p>
        </dd>

        <dt><a href="#dt-declaration">declaration</a></dt>

        <dd>
          <p>Top-level elements fall into two categories:
          declarations, and user-defined data elements. Top-level
          elements whose names are in the <a title="XSLT namespace"
          href="#dt-xslt-namespace">XSLT namespace</a> are
          <b>declarations</b>. Top-level elements in any other
          namespace are <a title="user-defined data element" href=
          "#dt-data-element">user-defined data elements</a> (see
          <a href="#user-defined-top-level"><i>3.6.2 User-defined
          Data Elements</i></a>)</p>
        </dd>

        <dt><a href="#dt-declaration-order">declaration
        order</a></dt>

        <dd>
          <p>The <a title="declaration" href=
          "#dt-declaration">declarations</a> within a <a title=
          "stylesheet level" href="#dt-stylesheet-level">stylesheet
          level</a> have a total ordering known as <b>declaration
          order</b>. The order of declarations within a stylesheet
          level is the same as the document order that would result
          if each stylesheet module were inserted textually in
          place of the <a href=
          "#element-include"><code>xsl:include</code></a> element
          that references it.</p>
        </dd>

        <dt><a href="#dt-default-collation">default
        collation</a></dt>

        <dd>
          <p>In this specification the term <b>default
          collation</b> means the collation that is used by XPath
          operators such as <code>eq</code> and <code>lt</code>
          appearing in XPath expressions within the stylesheet.</p>
        </dd>

        <dt><a href="#dt-default-mode">default mode</a></dt>

        <dd>
          <p>There is always a <b>default mode</b> available. The
          default mode is an unnamed <a title="mode" href=
          "#dt-mode">mode</a>, and it is used when no
          <code>mode</code> attribute is specified on an <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction.</p>
        </dd>

        <dt><a href="#dt-default-priority">default
        priority</a></dt>

        <dd>
          <p>If no <code>priority</code> attribute is specified on
          the <a href=
          "#element-template"><code>xsl:template</code></a>
          element, a <b>default priority</b> is computed, based on
          the syntax of the pattern supplied in the
          <code>match</code> attribute.</p>
        </dd>

        <dt><a href="#dt-defining-element">defining
        element</a></dt>

        <dd>
          <p><span>A string in the form of a lexical QName</span>
          may occur as the value of an attribute node in a
          stylesheet module, or within an XPath <a title=
          "expression" href="#dt-expression">expression</a>
          contained in such an attribute node, or as the result of
          evaluating an XPath expression contained in such an
          attribute node. The element containing this attribute
          node is referred to as the <b>defining element</b> of the
          QName.</p>
        </dd>

        <dt><a href="#dt-deprecated">deprecated</a></dt>

        <dd>
          <p>Some constructs defined in this specification are
          described as being <b>deprecated</b>. The use of this
          term implies that stylesheet authors <span class=
          "verb">should not</span> use the construct, and that the
          construct may be removed in a later version of this
          specification.</p>
        </dd>

        <dt><a href="#dt-dynamic-error">dynamic error</a></dt>

        <dd>
          <p>An error that is not detected until a source document
          is being transformed is referred to as a <b>dynamic
          error</b>.</p>
        </dd>

        <dt><a href="#dt-effective-value">effective value</a></dt>

        <dd>
          <p>The result of evaluating an attribute value template
          is referred to as the <b>effective value</b> of the
          attribute.</p>
        </dd>

        <dt><a href="#dt-embedded-stylesheet-module">embedded
        stylesheet module</a></dt>

        <dd>
          <p>An <b>embedded stylesheet module</b> is a stylesheet
          module that is embedded within another XML document,
          typically the source document that is being
          transformed.</p>
        </dd>

        <dt><a href="#dt-expanded-qname">expanded-QName</a></dt>

        <dd>
          <p>An <b>expanded-QName</b> <span>contains a pair of
          values, namely a local name and an optional namespace
          URI. It may also contain a namespace prefix.</span> Two
          expanded-QNames are equal if the namespace URIs are the
          same (or both absent) and the local names are the same.
          <span>The prefix plays no part in the comparison, but is
          used only if the expanded-QName needs to be converted
          back to a string.</span></p>
        </dd>

        <dt><a href="#dt-expression">expression</a></dt>

        <dd>
          <p>Within this specification, the term <b>XPath
          expression</b>, or simply <b>expression</b>, means a
          string that matches the production <span><a href=
          "http://www.w3.org/TR/xpath20/#doc-xpath-Expr">Expr</a><sup>
          <small>XP</small></sup></span> defined in <a href=
          "#xpath20">[XPath 2.0]</a>.</p>
        </dd>

        <dt><a href="#dt-extension-attribute">extension
        attribute</a></dt>

        <dd>
          <p>An element from the XSLT namespace may have any
          attribute not from the XSLT namespace, provided that the
          <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> (see <a href=
          "#xpath20">[XPath 2.0]</a>) of the attribute has a
          non-null namespace URI. These attributes are referred to
          as <b>extension attributes</b>.</p>
        </dd>

        <dt><a href="#dt-extension-function">extension
        function</a></dt>

        <dd>
          <p>An <b>extension function</b> is a function that is
          available for use within an XPath <a title="expression"
          href="#dt-expression">expression</a>, other than a
          <a title="core function" href="#dt-core-function">core
          function</a> defined in <a href=
          "#xpath-functions">[Functions and Operators]</a>, an
          additional function defined in this XSLT specification,
          <span>a constructor function named after an atomic
          type,</span> or a <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a> defined
          using an <a href=
          "#element-function"><code>xsl:function</code></a>
          declaration.</p>
        </dd>

        <dt><a href="#dt-extension-instruction">extension
        instruction</a></dt>

        <dd>
          <p>An <b>extension instruction</b> is an element within a
          <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> that
          is in a namespace (not the <a title="XSLT namespace"
          href="#dt-xslt-namespace">XSLT namespace</a>) designated
          as an extension namespace.</p>
        </dd>

        <dt><a href="#dt-extension-namespace">extension
        namespace</a></dt>

        <dd>
          <p>The <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>
          mechanism allows namespaces to be designated as
          <b>extension namespaces</b>. When a namespace is
          designated as an extension namespace and an element with
          a name from that namespace occurs in a <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, then
          the element is treated as an <a title="instruction" href=
          "#dt-instruction">instruction</a> rather than as a
          <a title="literal result element" href=
          "#dt-literal-result-element">literal result
          element</a>.</p>
        </dd>

        <dt><a href="#dt-final-output-state">final output
        state</a></dt>

        <dd>
          <p>The first of the two <a title="output state" href=
          "#dt-output-state">output states</a> is called <b>final
          output</b> state. This state applies when instructions
          are writing to a <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a>.</p>
        </dd>

        <dt><a href="#dt-final-result-tree">final result
        tree</a></dt>

        <dd>
          <p>A <b>final result tree</b> is a <a title="result tree"
          href="#dt-result-tree">result tree</a> that forms part of
          the final output of a transformation. Once created, the
          contents of a final result tree are not accessible within
          the stylesheet itself.</p>
        </dd>

        <dt><a href="#dt-focus">focus</a></dt>

        <dd>
          <p>When a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> is
          evaluated, the <a title="processor" href=
          "#dt-processor">processor</a> keeps track of which items
          are being processed by means of a set of implicit
          variables referred to collectively as the
          <b>focus</b>.</p>
        </dd>

        <dt><a href=
        "#dt-forwards-compatible-behavior">forwards-compatible
        behavior</a></dt>

        <dd>
          <p>An element enables <b>forwards-compatible behavior</b>
          for itself, its attributes, its descendants and their
          attributes if it has an <code>[xsl:]version</code>
          attribute (see <a href="#standard-attributes"><i>3.5
          Standard Attributes</i></a>) whose value is greater than
          <code>2.0</code>.</p>
        </dd>

        <dt><a href="#dt-function-conversion-rules">function
        conversion rules</a></dt>

        <dd>
          <p>Except where otherwise indicated, the actual value of
          an <a title="expression" href=
          "#dt-expression">expression</a> is converted to the
          <a title="required type" href=
          "#dt-required-type">required type</a> using the
          <b>function conversion rules</b>. These are the rules
          defined in <a href="#xpath20">[XPath 2.0]</a> for
          converting the supplied argument of a function call to
          the required type of that argument, as defined in the
          function signature. The relevant rules are those that
          apply when <a title="XPath 1.0 compatibility mode" href=
          "#dt-compatibility-mode">XPath 1.0 compatibility mode</a>
          is set to <code>false</code>.</p>
        </dd>

        <dt><a href="#dt-function-parameter">function
        parameter</a></dt>

        <dd>
          <p>An <a href="#element-param"><code>xsl:param</code></a>
          element may appear as a child of an <a href=
          "#element-function"><code>xsl:function</code></a>
          element, before any non-<a href=
          "#element-param"><code>xsl:param</code></a> children of
          that element. Such a parameter is known as a <b>function
          parameter</b>. A function parameter is a <a title=
          "local variable" href="#dt-local-variable">local
          variable</a> with the additional property that its value
          can be set when the function is called, using a function
          call in an XPath <a title="expression" href=
          "#dt-expression">expression</a>.</p>
        </dd>

        <dt><a href="#dt-global-variable">global variable</a></dt>

        <dd>
          <p>A top-level <a title="variable-binding element" href=
          "#dt-variable-binding-element">variable-binding
          element</a> declares a <b>global variable</b> that is
          visible everywhere (except where it is <a title="shadows"
          href="#dt-shadows">shadowed</a> by another binding).</p>
        </dd>

        <dt><a href="#dt-group">group</a></dt>

        <dd>
          <p>The <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          instruction <span>allocates the items in an input
          sequence</span> into <b>groups</b> of items (that is, it
          establishes a collection of sequences) based either on
          common values of a grouping key, or on a <a title=
          "pattern" href="#dt-pattern">pattern</a> that the initial
          or final node in a group must match.</p>
        </dd>

        <dt><a href="#dt-grouping-key">grouping key</a></dt>

        <dd>
          <p>If either of the <code>group-by</code> attribute or
          <code>group-adjacent</code> attributes is present, then
          <b>grouping keys</b> are calculated for each item in the
          <a title="population" href=
          "#dt-population">population</a>. <span>The grouping keys
          are the items in the sequence obtained by evaluating the
          expression contained in the <code>group-by</code>
          attribute or <code>group-adjacent</code> attribute,
          atomizing the result, and then casting an
          <code>xs:untypedAtomic</code> value to
          <code>xs:string</code>.</span></p>
        </dd>

        <dt><a href="#dt-implementation">implementation</a></dt>

        <dd>
          <p>A specific product that performs the functions of an
          <a title="processor" href="#dt-processor">XSLT
          processor</a> is referred to as an
          <b>implementation</b></p>
        </dd>

        <dt><a href=
        "#dt-implementation-defined">implementation-defined</a></dt>

        <dd>
          <p>In this specification, the term
          <b>implementation-defined</b> refers to a feature where
          the implementation is allowed some flexibility, and where
          the choices made by the implementation <span class=
          "verb">must</span> be described in documentation that
          accompanies any conformance claim.</p>
        </dd>

        <dt><a href=
        "#dt-implementation-dependent">implementation-dependent</a></dt>

        <dd>
          <p>The term <b>implementation-dependent</b> refers to a
          feature where the behavior <span class="verb">may</span>
          vary from one implementation to another, and where the
          vendor is not expected to provide a full specification of
          the behavior.</p>
        </dd>

        <dt><a href="#dt-import-precedence">import
        precedence</a></dt>

        <dd>
          <p>A <a title="declaration" href=
          "#dt-declaration">declaration</a> <var>D</var> in the
          stylesheet is defined to have lower <b>import
          precedence</b> than another declaration <var>E</var> if
          the stylesheet level containing <var>D</var> would be
          visited before the stylesheet level containing
          <var>E</var> in a post-order traversal of the import tree
          (that is, a traversal of the import tree in which a
          stylesheet level is visited after its children). Two
          declarations within the same stylesheet level have the
          same import precedence.</p>
        </dd>

        <dt><a href="#dt-import-tree">import tree</a></dt>

        <dd>
          <p>The <a title="stylesheet level" href=
          "#dt-stylesheet-level">stylesheet levels</a> making up a
          <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> are treated as forming an
          <b>import tree</b>. In the import tree, each stylesheet
          level has one child for each <a href=
          "#element-import"><code>xsl:import</code></a> declaration
          that it contains.</p>
        </dd>

        <dt><a href="#dt-in-scope-schema-component">in-scope schema
        component</a></dt>

        <dd>
          <p>The <a title="schema component" href=
          "#dt-schema-component">schema components</a> that may be
          referenced by name in a <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> are referred to as the
          <b>in-scope schema components</b>. This set is the same
          throughout all the modules of a stylesheet.</p>
        </dd>

        <dt><a href="#dt-initial-context-node">initial context
        node</a></dt>

        <dd>
          <p>A node that acts as the <b>initial context node</b>
          for the transformation. This node is accessible within
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> as the initial value of
          the XPath <a title="expression" href=
          "#dt-expression">expressions</a> <code>.</code> (dot) and
          <code>self::node()</code>, as described in <a href=
          "#focus"><i>5.4.3.1 Maintaining Position: the
          Focus</i></a></p>
        </dd>

        <dt><a href="#dt-initial-item">initial item</a></dt>

        <dd>
          <p>For each <a title="group" href="#dt-group">group</a>,
          the item within the group that is first in <a title=
          "population order" href="#dt-population-order">population
          order</a> is known as the <b>initial item</b> of the
          group.</p>
        </dd>

        <dt><a href="#dt-initial-sequence">initial
        sequence</a></dt>

        <dd>
          <p>The sequence to be sorted is referred to as the
          <b>initial sequence</b>.</p>
        </dd>

        <dt><a href="#dt-initial-template">initial
        template</a></dt>

        <dd>
          <p>The transformation is performed by evaluating an
          <b>initial template</b>. If a <a title="named template"
          href="#dt-named-template">named template</a> is supplied
          when the transformation is initiated, then this is the
          initial template; <span>otherwise, the initial template
          is the <a title="template rule" href=
          "#dt-template-rule">template rule</a> selected according
          to the rules of the <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction for processing the <a title=
          "initial context node" href=
          "#dt-initial-context-node">initial context node</a> in
          the initial <a title="mode" href=
          "#dt-mode">mode</a>.</span></p>
        </dd>

        <dt><a href="#dt-instruction">instruction</a></dt>

        <dd>
          <p>An <b>instruction</b> is either an <a title=
          "XSLT instruction" href="#dt-xslt-instruction">XSLT
          instruction</a> or an <a title="extension instruction"
          href="#dt-extension-instruction">extension
          instruction</a>.</p>
        </dd>

        <dt><a href="#dt-key">key</a></dt>

        <dd>
          <p>A <b>key</b> is defined as a set of <a href=
          "#element-key"><code>xsl:key</code></a> declarations in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that share the same
          name.</p>
        </dd>

        <dt><a href="#dt-key-specifier">key specifier</a></dt>

        <dd>
          <p>The expression in the <code>use</code> attribute and
          the <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>
          within an <a href="#element-key"><code>xsl:key</code></a>
          declaration are referred to collectively as the <b>key
          specifier</b>. The key specifier determines the values
          that may be used to find a node using this <a title="key"
          href="#dt-key">key</a>.</p>
        </dd>

        <dt><a href="#dt-lexical-qname">lexical QName</a></dt>

        <dd>
          <p>A <b>lexical QName</b> is a string representing a
          <a title="QName" href="#dt-qname">QName</a> in the form
          <code>(NCName ":")? NCName</code>, that is, a local name
          optionally preceded by a namespace prefix.</p>
        </dd>

        <dt><a href="#dt-literal-namespace-uri">literal namespace
        URI</a></dt>

        <dd>
          <p>A namespace URI in the stylesheet tree that is being
          used to specify a namespace URI in the <a title=
          "result tree" href="#dt-result-tree">result tree</a> is
          called a <b>literal namespace URI</b>.</p>
        </dd>

        <dt><a href="#dt-literal-result-element">literal result
        element</a></dt>

        <dd>
          <p>In a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, an
          element in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that does not belong to
          the <a title="XSLT namespace" href=
          "#dt-xslt-namespace">XSLT namespace</a> and that is not
          an <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>
          (see <a href="#extension-instruction"><i>18.2 Extension
          Instructions</i></a>) is classified as a <b>literal
          result element</b>.</p>
        </dd>

        <dt><a href="#dt-local-variable">local variable</a></dt>

        <dd>
          <p>As well as being allowed as <a title="declaration"
          href="#dt-declaration">declaration</a> elements, the
          <a href="#element-variable"><code>xsl:variable</code></a>
          element is also allowed in <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructors</a>.
          Such a variable is known as a <b>local variable</b>.</p>
        </dd>

        <dt><a href="#dt-mode">mode</a></dt>

        <dd>
          <p><b>Modes</b> allow a node in a <a title="source tree"
          href="#dt-source-tree">source tree</a> to be processed
          multiple times, each time producing a different result.
          They also allow different sets of <a title=
          "template rule" href="#dt-template-rule">template
          rules</a> to be active when processing different trees,
          for example when processing documents loaded using the
          <a href="#function-document"><code>document</code></a>
          function (see <a href="#document"><i>16.1 Multiple Source
          Documents</i></a>) or when processing <a title=
          "temporary tree" href="#dt-temporary-tree">temporary
          trees</a>.</p>
        </dd>

        <dt><a href="#dt-named-template">named template</a></dt>

        <dd>
          <p>Templates can be invoked by name. An <a href=
          "#element-template"><code>xsl:template</code></a> element
          with a <code>name</code> attribute defines a <b>named
          template</b>.</p>
        </dd>

        <dt><a href="#dt-namespace-fixup">namespace fixup</a></dt>

        <dd>
          <p>The rules for the individual XSLT instructions that
          construct a <a title="result tree" href=
          "#dt-result-tree">result tree</a> (see <a href=
          "#creating-new-nodes"><i>11 Creating Nodes and
          Sequences</i></a>) prescribe some of the situations in
          which namespace nodes are written to the tree. These
          rules, however, are not sufficient to ensure that the
          prescribed constraints are always satisfied. The XSLT
          processor <span class="verb">must</span> therefore add
          additional namespace nodes to satisfy these constraints.
          This process is referred to as <b>namespace
          fixup</b>.</p>
        </dd>

        <dt><a href="#dt-nonrec-dynamic-error">non-recoverable
        dynamic error</a></dt>

        <dd>
          <p>A <a title="dynamic error" href=
          "#dt-dynamic-error">dynamic error</a> that is not
          recoverable is referred to as a <b>non-recoverable
          dynamic error</b>. When a non-recoverable dynamic error
          occurs, the <a title="processor" href=
          "#dt-processor">processor</a> <span class=
          "verb">must</span> signal the error, and the
          transformation fails.</p>
        </dd>

        <dt><a href="#dt-optional-recovery-action">optional
        recovery action</a></dt>

        <dd>
          <p>If an implementation chooses to recover from a
          <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a>, it
          <span class="verb">must</span> take the <b>optional
          recovery action</b> defined for that error condition in
          this specification.</p>
        </dd>

        <dt><a href="#dt-first-appearance">order of first
        appearance</a></dt>

        <dd>
          <p>There is an ordering among <a title="group" href=
          "#dt-group">groups</a> referred to as the <b>order of
          first appearance</b>. A group <var>G</var> is defined to
          precede a group <var>H</var> in order of first appearance
          if the <a title="initial item" href=
          "#dt-initial-item">initial item</a> of <var>G</var>
          precedes the initial item of <var>H</var> in population
          order. <span>If two groups <var>G</var> and <var>H</var>
          have the same initial item (because the item is in both
          groups) then <var>G</var> precedes <var>H</var> if the
          <a title="grouping key" href="#dt-grouping-key">grouping
          key</a> of <var>G</var> precedes the grouping key of
          <var>H</var> in the sequence that results from evaluating
          the <code>group-by</code> expression of this initial
          item.</span></p>
        </dd>

        <dt><a href="#dt-output-definition">output
        definition</a></dt>

        <dd>
          <p>All the <a href=
          "#element-output"><code>xsl:output</code></a>
          declarations in a stylesheet that share the same name are
          grouped into a named <b>output definition</b>; those that
          have no name are grouped into a single unnamed output
          definition.</p>
        </dd>

        <dt><a href="#dt-output-state">output state</a></dt>

        <dd>
          <p>Each instruction in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> is evaluated in one of
          two possible <b>output states</b>: <a title=
          "final output state" href="#dt-final-output-state">final
          output state</a> or <a title="temporary output state"
          href="#dt-temporary-output-state">temporary output
          state</a></p>
        </dd>

        <dt><a href="#dt-parameter">parameter</a></dt>

        <dd>
          <p>The <a href=
          "#element-param"><code>xsl:param</code></a> element
          declares a <b>parameter</b>, which may be a <a title=
          "stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameter</a>, a
          <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a>, or a
          <a title="function parameter" href=
          "#dt-function-parameter">function parameter</a>. A
          parameter is a <a title="variable" href=
          "#dt-variable">variable</a> with the additional property
          that its value can be set by the caller when the
          stylesheet, the template, or the function is invoked.</p>
        </dd>

        <dt><a href="#dt-pattern">pattern</a></dt>

        <dd>
          <p>A <b>pattern</b> specifies a set of conditions on a
          node. A node that satisfies the conditions matches the
          pattern; a node that does not satisfy the conditions does
          not match the pattern. The syntax for patterns is a
          subset of the syntax for <a title="expression" href=
          "#dt-expression">expressions</a>.</p>
        </dd>

        <dt><a href="#dt-picture-string">picture string</a></dt>

        <dd>
          <p>The formatting of a number is controlled by a
          <b>picture string</b>. The picture string is a sequence
          of characters, in which the characters assigned to the
          variables <var>decimal-separator-sign</var>,
          <var>grouping-sign</var>, <var>zero-digit-sign</var>,
          <var>digit-sign</var> and
          <var>pattern-separator-sign</var> are classified as
          active characters, and all other characters (including
          the <var>percent-sign</var> and
          <var>per-mille-sign</var>) are classified as passive
          characters.</p>
        </dd>

        <dt><a href="#dt-place-marker">place marker</a></dt>

        <dd>
          <p>The <a href=
          "#element-number"><code>xsl:number</code></a> instruction
          performs two tasks: firstly, determining a <b>place
          marker</b> (this is a sequence of integers, to allow for
          hierarchic numbering schemes such as <code>1.12.2</code>
          or <code>3(c)ii</code>), and secondly, formatting the
          place marker for output as a text node in the result
          sequence.</p>
        </dd>

        <dt><a href="#dt-population">population</a></dt>

        <dd>
          <p>The sequence of items to be grouped, which is referred
          to as the <b>population</b>, is determined by evaluating
          the XPath <a title="expression" href=
          "#dt-expression">expression</a> contained in the
          <code>select</code> attribute.</p>
        </dd>

        <dt><a href="#dt-population-order">population
        order</a></dt>

        <dd>
          <p>The population is treated as a sequence; the order of
          items in this sequence is referred to as <b>population
          order</b></p>
        </dd>

        <dt><a href="#dt-principal-stylesheet-module">principal
        stylesheet module</a></dt>

        <dd>
          <p>A <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> may consist of several
          <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a>, contained
          in different XML documents. For a given transformation,
          one of these functions as the <b>principal stylesheet
          module</b>. The complete <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> is assembled by finding
          the <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a> referenced
          directly or indirectly from the principal stylesheet
          module using <a href=
          "#element-include"><code>xsl:include</code></a> and
          <a href="#element-import"><code>xsl:import</code></a>
          elements: see <a href="#include"><i>3.10.2 Stylesheet
          Inclusion</i></a> and <a href="#import"><i>3.10.3
          Stylesheet Import</i></a>.</p>
        </dd>

        <dt><a href="#dt-processing-order">processing
        order</a></dt>

        <dd>
          <p>There is another ordering among groups referred to as
          <b>processing order</b>. <span>If group <var>R</var>
          precedes group <var>S</var> in processing order, then in
          the result sequence returned by the <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          instruction the items generated by processing group
          <var>R</var> will precede the items generated by
          processing group <var>S</var>.</span></p>
        </dd>

        <dt><a href="#dt-processor">processor</a></dt>

        <dd>
          <p>The software responsible for transforming source trees
          into result trees using an XSLT stylesheet is referred to
          as the <b>processor</b>. This is sometimes expanded to
          <em>XSLT processor</em> to avoid any confusion with other
          processors, for example an XML processor.</p>
        </dd>

        <dt><a href="#dt-recoverable-error">recoverable
        error</a></dt>

        <dd>
          <p>Some dynamic errors are classed as <b>recoverable
          errors</b>. When a recoverable error occurs, this
          specification allows the processor either to signal the
          error (by reporting the error condition and terminating
          execution) or to take a defined recovery action and
          continue processing.</p>
        </dd>

        <dt><a href="#dt-required-type">required type</a></dt>

        <dd>
          <p>The context within a <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> where an XPath <a title=
          "expression" href="#dt-expression">expression</a>
          <span>appears may specify</span> the <b>required type</b>
          of the expression. The required type indicates the type
          of the value that the expression is expected to
          return.</p>
        </dd>

        <dt><a href="#dt-reserved-namespace">reserved
        namespace</a></dt>

        <dd>
          <p>The XSLT namespace, together with certain other
          namespaces recognized by an XSLT processor, are
          classified as <b>reserved namespaces</b> and <span class=
          "verb">must</span> be used only as specified in this and
          related specifications.</p>
        </dd>

        <dt><a href="#dt-result-tree">result tree</a></dt>

        <dd>
          <p>The term <b>result tree</b> is used to refer to any
          tree constructed by <a title="instruction" href=
          "#dt-instruction">instructions</a> in the stylesheet. A
          result tree is either a <a title="final result tree"
          href="#dt-final-result-tree">final result tree</a> or a
          <a title="temporary tree" href=
          "#dt-temporary-tree">temporary tree</a>.</p>
        </dd>

        <dt><a href="#dt-schema-component">schema
        component</a></dt>

        <dd>
          <p>Type definitions and element and attribute
          declarations are referred to collectively as <b>schema
          components</b>.</p>
        </dd>

        <dt><a href="#dt-schema-instance-namespace">schema instance
        namespace</a></dt>

        <dd>
          <p>The <b>schema instance namespace</b>
          <code>http://www.w3.org/2001/XMLSchema-instance</code> is
          used as defined in <a href="#xmlschema-1">[XML Schema
          Part 1]</a></p>
        </dd>

        <dt><a href="#dt-schema-namespace">schema
        namespace</a></dt>

        <dd>
          <p>The <b>schema namespace</b>
          <code>http://www.w3.org/2001/XMLSchema</code> is used as
          defined in <a href="#xmlschema-1">[XML Schema Part
          1]</a></p>
        </dd>

        <dt><a href="#dt-schema-aware-xslt-processor">schema-aware
        XSLT processor</a></dt>

        <dd>
          <p>A <b>schema-aware XSLT processor</b> is an XSLT
          processor that implements all the mandatory requirements
          of this specification, including those features that a
          <a title="basic XSLT processor" href=
          "#dt-basic-xslt-processor">basic XSLT processor</a>
          signals as an error. The mandatory requirements of this
          specification are taken to include the mandatory
          requirements of XPath 2.0, as described in <a href=
          "#xpath20">[XPath 2.0]</a>. A requirement is mandatory
          unless the specification includes wording (such as the
          use of the words <span class="verb">should</span> or
          <span class="verb">may</span>) that clearly indicates
          that it is optional.</p>
        </dd>

        <dt><a href="#dt-sequence-constructor">sequence
        constructor</a></dt>

        <dd>
          <p>A <b>sequence constructor</b> is a sequence of zero or
          more sibling nodes in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that can be evaluated to
          return a sequence of nodes and atomic values. The way
          that the resulting sequence is used depends on the
          containing instruction.</p>
        </dd>

        <dt><a href="#dt-serialization">serialization</a></dt>

        <dd>
          <p>A frequent requirement is to output a <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> as an XML document (or in other formats
          such as HTML). This process is referred to as
          <b>serialization</b>.</p>
        </dd>

        <dt><a href="#dt-serialization-error">serialization
        error</a></dt>

        <dd>
          <p>If a transformation has successfully produced a
          <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a>, it is
          still possible that errors may occur in serializing the
          result tree. For example, it may be impossible to
          serialize the result tree using the encoding selected by
          the user. Such an error is referred to as a
          <b>serialization error</b>.</p>
        </dd>

        <dt><a href="#dt-serialization-feature">serialization
        feature</a></dt>

        <dd>
          <p>A processor that claims conformance with the
          <b>serialization feature</b> <span class=
          "verb">must</span> support the conversion of a <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a> to a sequence of <span>octets</span>
          following the rules defined in <a href=
          "#serialization"><i>20 Serialization</i></a>.</p>
        </dd>

        <dt><a href="#dt-shadows">shadows</a></dt>

        <dd>
          <p>A binding <b>shadows</b> another binding if the
          binding occurs at a point where the other binding is
          visible, and the bindings have the same name.</p>
        </dd>

        <dt><a href="#dt-simplified-stylesheet-module">simplified
        stylesheet module</a></dt>

        <dd>
          <p>A <b>simplified stylesheet module</b> is a tree, or
          part of a tree, consisting of a <a title=
          "literal result element" href=
          "#dt-literal-result-element">literal result element</a>
          together with its descendant nodes and associated
          attributes and namespaces. This element is not itself in
          the XSLT namespace, but it <span class="verb">must</span>
          have an <code>xsl:version</code> attribute, which implies
          that it <span class="verb">must</span> have a namespace
          node that declares a binding for the XSLT namespace. For
          further details see <a href=
          "#simplified-stylesheet"><i>3.7 Simplified Stylesheet
          Modules</i></a>.</p>
        </dd>

        <dt><a href="#dt-singleton-focus">singleton focus</a></dt>

        <dd>
          <p>A <b>singleton focus</b> based on a node <var>N</var>
          has the <a title="context item" href=
          "#dt-context-item">context item</a> (and therefore the
          <a title="context node" href="#dt-context-node">context
          node</a>) set to <var>N</var>, and the <a title=
          "context position" href="#dt-context-position">context
          position</a> and <a title="context size" href=
          "#dt-context-size">context size</a> both set to 1
          (one).</p>
        </dd>

        <dt><a href="#dt-sort-key-component">sort key
        component</a></dt>

        <dd>
          <p>Within a <a title="sort key specification" href=
          "#dt-sort-key-specification">sort key specification</a>,
          each <a href="#element-sort"><code>xsl:sort</code></a>
          element defines one <b>sort key component</b>.</p>
        </dd>

        <dt><a href="#dt-sort-key-specification">sort key
        specification</a></dt>

        <dd>
          <p>A <b>sort key specification</b> is a sequence of one
          or more adjacent <a href=
          "#element-sort"><code>xsl:sort</code></a> elements which
          together define rules for sorting the items in an input
          sequence to form a sorted sequence.</p>
        </dd>

        <dt><a href="#dt-sort-key-value">sort key value</a></dt>

        <dd>
          <p>For each item in the <a title="initial sequence" href=
          "#dt-initial-sequence">initial sequence</a>, a value is
          computed for each <a title="sort key component" href=
          "#dt-sort-key-component">sort key component</a> within
          the <a title="sort key specification" href=
          "#dt-sort-key-specification">sort key specification</a>.
          The value computed for an item by using the
          <var>N</var>th sort key component is referred to as the
          <var>N</var>th <b>sort key value</b> of that item.</p>
        </dd>

        <dt><a href="#dt-sorted-sequence">sorted sequence</a></dt>

        <dd>
          <p>The sequence after sorting as defined by the <a href=
          "#element-sort"><code>xsl:sort</code></a> elements is
          referred to as the <b>sorted sequence</b>.</p>
        </dd>

        <dt><a href="#dt-source-tree">source tree</a></dt>

        <dd>
          <p>The term <b>source tree</b> means any tree provided as
          input to the transformation. This includes the document
          containing the <a title="initial context node" href=
          "#dt-initial-context-node">initial context node</a> if
          any, documents containing nodes supplied as the values of
          <a title="stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameters</a>,
          documents obtained from the results of functions such as
          <a href="#function-document"><code>document</code></a>,
          <a href=
          "http://www.w3.org/TR/xpath-functions/#func-doc"><code>doc</code></a><sup>
          <small>FO</small></sup>, and <a href=
          "http://www.w3.org/TR/xpath-functions/#func-collection"><code>
          collection</code></a><sup><small>FO</small></sup>, and
          documents returned by extension functions or extension
          instructions. In the context of a particular XSLT
          instruction, the term <b>source tree</b> means any tree
          provided as input to that instruction; this may be a
          source tree of the transformation as a whole, or it may
          be a <a title="temporary tree" href=
          "#dt-temporary-tree">temporary tree</a> produced during
          the course of the transformation.</p>
        </dd>

        <dt><a href="#dt-stable">stable</a></dt>

        <dd>
          <p>A <a title="sort key specification" href=
          "#dt-sort-key-specification">sort key specification</a>
          is said to be <b>stable</b> if its first <a href=
          "#element-sort"><code>xsl:sort</code></a> element has no
          <code>stable</code> attribute, or has a
          <code>stable</code> attribute whose <a title=
          "effective value" href="#dt-effective-value">effective
          value</a> is <code>yes</code>.</p>
        </dd>

        <dt><a href="#dt-standalone-stylesheet-module">standalone
        stylesheet module</a></dt>

        <dd>
          <p>A <b>standalone stylesheet module</b> is a stylesheet
          module that comprises the whole of an XML document.</p>
        </dd>

        <dt><a href="#dt-standard-attributes">standard
        attributes</a></dt>

        <dd>
          <p>There are a number of <b>standard attributes</b> that
          may appear on any <a title="XSLT element" href=
          "#dt-xslt-element">XSLT element</a>: specifically
          <code>version</code>,
          <code>exclude-result-prefixes</code>,
          <code>extension-element-prefixes</code>,
          <code>xpath-default-namespace</code><span>,
          <code>default-collation</code>, and
          <code>use-when</code>.</span></p>
        </dd>

        <dt><a href="#dt-standard-function-namespace">standard
        function namespace</a></dt>

        <dd>
          <p>The <b>standard function namespace</b>
          <code>http://www.w3.org/2005/xpath-functions</code> is
          used for functions in the function library defined in
          <a href="#xpath-functions">[Functions and Operators]</a>
          and standard functions defined in this specification.</p>
        </dd>

        <dt><a href="#dt-standard-stylesheet-module">standard
        stylesheet module</a></dt>

        <dd>
          <p>A <b>standard stylesheet module</b> is a tree, or part
          of a tree, consisting of an <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a> or
          <a href=
          "#element-transform"><code>xsl:transform</code></a>
          element (see <a href="#stylesheet-element"><i>3.6
          Stylesheet Element</i></a>) together with its descendant
          nodes and associated attributes and namespaces.</p>
        </dd>

        <dt><a href="#dt-static-error">static error</a></dt>

        <dd>
          <p>An error that is detected by examining a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> before
          execution starts (that is, before the source document and
          values of stylesheet parameters are available) is
          referred to as a <b>static error</b>.</p>
        </dd>

        <dt><a href="#dt-string-value">string value</a></dt>

        <dd>
          <p>The term <b>string value</b> is defined in <a href=
          "http://www.w3.org/TR/xpath-datamodel/#dm-string-value">Section
          5.13 string-value
          Accessor</a><sup><small>DM</small></sup>. Every node has
          a <a title="string value" href="#dt-string-value">string
          value</a>. For example, the <a title="string value" href=
          "#dt-string-value">string value</a> of an element is the
          concatenation of the <a title="string value" href=
          "#dt-string-value">string values</a> of all its
          descendant text nodes.</p>
        </dd>

        <dt><a href="#dt-stylesheet">stylesheet</a></dt>

        <dd>
          <p>A transformation in the XSLT language is expressed in
          the form of a <b>stylesheet</b>, whose syntax is
          well-formed XML <a href="#REC-xml">[XML 1.0]</a>
          conforming to the Namespaces in XML Recommendation
          <a href="#REC-xml-names">[Namespaces in XML 1.0]</a>.</p>
        </dd>

        <dt><a href="#dt-stylesheet-function">stylesheet
        function</a></dt>

        <dd>
          <p>An <a href=
          "#element-function"><code>xsl:function</code></a>
          declaration declares the name, parameters, and
          implementation of a <b>stylesheet function</b> that can
          be called from any XPath <a title="expression" href=
          "#dt-expression">expression</a> within the <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>.</p>
        </dd>

        <dt><a href="#dt-stylesheet-level">stylesheet
        level</a></dt>

        <dd>
          <p>A <b>stylesheet level</b> is a collection of <a title=
          "stylesheet module" href=
          "#dt-stylesheet-module">stylesheet modules</a> connected
          using <a href=
          "#element-include"><code>xsl:include</code></a>
          declarations: specifically, two stylesheet modules
          <var>A</var> and <var>B</var> are part of the same
          stylesheet level if one of them includes the other by
          means of an <a href=
          "#element-include"><code>xsl:include</code></a>
          declaration, or if there is a third stylesheet module
          <var>C</var> that is in the same stylesheet level as both
          <var>A</var> and <var>B</var>.</p>
        </dd>

        <dt><a href="#dt-stylesheet-module">stylesheet
        module</a></dt>

        <dd>
          <p>A <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> consists of one or more
          <b>stylesheet modules</b>, each one forming all or part
          of an XML document.</p>
        </dd>

        <dt><a href="#dt-stylesheet-parameter">stylesheet
        parameter</a></dt>

        <dd>
          <p>A top-level <a href=
          "#element-param"><code>xsl:param</code></a> element
          declares a <b>stylesheet parameter</b>. A stylesheet
          parameter is a global variable with the additional
          property that its value can be supplied by the caller
          when a transformation is initiated.</p>
        </dd>

        <dt><a href="#dt-supplied-value">supplied value</a></dt>

        <dd>
          <p>The value of the variable is computed using the
          <a title="expression" href=
          "#dt-expression">expression</a> given in the
          <code>select</code> attribute or the contained <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, as
          described in <a href="#variable-values"><i>9.3 Values of
          Variables and Parameters</i></a>. This value is referred
          to as the <b>supplied value</b> of the variable.</p>
        </dd>

        <dt><a href="#dt-target-namespace-uri">target namespace
        URI</a></dt>

        <dd>
          <p>The namespace URI that is to be used in the <a title=
          "result tree" href="#dt-result-tree">result tree</a> as a
          substitute for a <a title="literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> is
          called the <b>target namespace URI</b>.</p>
        </dd>

        <dt><a href="#dt-template">template</a></dt>

        <dd>
          <p>An <a href=
          "#element-template"><code>xsl:template</code></a>
          declaration defines a <b>template</b>, which contains a
          <span><a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence
          constructor</a></span> for creating nodes and/or atomic
          values. A template can serve either as a <a title=
          "template rule" href="#dt-template-rule">template
          rule</a>, invoked by matching nodes against a <a title=
          "pattern" href="#dt-pattern">pattern</a>, or as a
          <a title="named template" href="#dt-named-template">named
          template</a>, invoked explicitly by name. It is also
          possible for the same template to serve in both
          capacities.</p>
        </dd>

        <dt><a href="#dt-template-parameter">template
        parameter</a></dt>

        <dd>
          <p>An <a href="#element-param"><code>xsl:param</code></a>
          element may appear as a child of an <a href=
          "#element-template"><code>xsl:template</code></a>
          element, before any non-<a href=
          "#element-param"><code>xsl:param</code></a> children of
          that element. Such a parameter is known as a <b>template
          parameter</b>. A template parameter is a <a title=
          "local variable" href="#dt-local-variable">local
          variable</a> with the additional property that its value
          can be set when the template is called, using any of the
          instructions <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <span>or <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>.</p>
        </dd>

        <dt><a href="#dt-template-rule">template rule</a></dt>

        <dd>
          <p>A stylesheet contains a set of <b>template rules</b>
          (see <a href="#rules"><i>6 Template Rules</i></a>). A
          template rule has three parts: a <a title="pattern" href=
          "#dt-pattern">pattern</a> that is matched against nodes,
          a (possibly empty) set of <a title="template parameter"
          href="#dt-template-parameter">template parameters</a>,
          and a <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> that
          is evaluated to produce a sequence of items.</p>
        </dd>

        <dt><a href="#dt-temporary-output-state">temporary output
        state</a></dt>

        <dd>
          <p>The second of the two <a title="output state" href=
          "#dt-output-state">output states</a> is called
          <b>temporary output</b> state. This state applies when
          instructions are writing to a <a title="temporary tree"
          href="#dt-temporary-tree">temporary tree</a> or any other
          non-final destination.</p>
        </dd>

        <dt><a href="#dt-temporary-tree">temporary tree</a></dt>

        <dd>
          <p>The term <b>temporary tree</b> means any tree that is
          neither a <a title="source tree" href=
          "#dt-source-tree">source tree</a> nor a <a title=
          "final result tree" href="#dt-final-result-tree">final
          result tree</a>.</p>
        </dd>

        <dt><a href="#dt-top-level">top-level</a></dt>

        <dd>
          <p>An element occurring as a child of an <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element is called a <b>top-level</b> element.</p>
        </dd>

        <dt><a href="#dt-tunnel-parameter">tunnel
        parameter</a></dt>

        <dd>
          <p>A parameter passed to a template may be defined as a
          <b>tunnel parameter</b>. Tunnel parameters have the
          property that they are automatically passed on by the
          called template to any further templates that it calls,
          and so on recursively.</p>
        </dd>

        <dt><a href="#dt-annotation">type annotation</a></dt>

        <dd>
          <p>The term <b>type annotation</b> is used in this
          specification to refer to the value returned by the
          <code>dm:type-name</code> accessor of a node: see
          <a href="http://www.w3.org/TR/xpath-datamodel/#dm-type-name">
          Section 5.14 type-name
          Accessor</a><sup><small>DM</small></sup>.</p>
        </dd>

        <dt><a href="#dt-type-error">type errors</a></dt>

        <dd>
          <p>Certain errors are classified as <b>type errors</b>. A
          type error occurs when the value supplied as input to an
          operation is of the wrong type for that operation, for
          example when an integer is supplied to an operation that
          expects a node.</p>
        </dd>

        <dt><a href="#dt-typed-value">typed value</a></dt>

        <dd>
          <p>The term <b>typed value</b> is defined in <a href=
          "http://www.w3.org/TR/xpath-datamodel/#dm-typed-value">Section
          5.15 typed-value
          Accessor</a><sup><small>DM</small></sup>. Every node
          except an element defined in the schema with element-only
          content has a <a title="string value" href=
          "#dt-string-value">typed value</a>. For example, the
          <a title="typed value" href="#dt-typed-value">typed
          value</a> of an attribute of type <code>xs:IDREFS</code>
          is a sequence of zero or more <code>xs:IDREF</code>
          values.</p>
        </dd>

        <dt><a href="#dt-data-element">user-defined data
        element</a></dt>

        <dd>
          <p>In addition to <a title="declaration" href=
          "#dt-declaration">declarations</a>, the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element may contain any element not from the <a title=
          "XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, provided that the <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of the element
          has a non-null namespace URI. Such elements are referred
          to as <b>user-defined data elements</b>.</p>
        </dd>

        <dt><a href="#dt-value">value</a></dt>

        <dd>
          <p>A variable is a binding between a name and a value.
          The <b>value</b> of a variable is any sequence (of nodes
          and/or atomic values), as defined in <a href=
          "#xpath-datamodel">[Data Model]</a>.</p>
        </dd>

        <dt><a href="#dt-variable">variable</a></dt>

        <dd>
          <p>The <a href=
          "#element-variable"><code>xsl:variable</code></a> element
          declares a <b>variable</b>, which may be a <a title=
          "global variable" href="#dt-global-variable">global
          variable</a> or a <a title="local variable" href=
          "#dt-local-variable">local variable</a>.</p>
        </dd>

        <dt><a href="#dt-variable-binding-element">variable-binding
        element</a></dt>

        <dd>
          <p>The two elements <a href=
          "#element-variable"><code>xsl:variable</code></a> and
          <a href="#element-param"><code>xsl:param</code></a> are
          referred to as <b>variable-binding elements</b></p>
        </dd>

        <dt><a href="#dt-whitespace-text-node">whitespace text
        node</a></dt>

        <dd>
          <p>A <b>whitespace text node</b> is a text node whose
          content consists entirely of whitespace characters (that
          is, #x09, #x0A, #x0D, or #x20).</p>
        </dd>
      </dl>
    </div>

    <div class="div1">
      <h2><a name="element-syntax-summary" id=
      "element-syntax-summary"></a>D Element Syntax Summary
      (Non-Normative)</h2>

      <p>The syntax of each XSLT element is summarized below,
      together with the context in the stylesheet where the element
      may appear. Some elements (specifically, instructions) are
      allowed as a child of any element that is allowed to contain
      a sequence constructor. These elements are:</p>

      <ul>
        <li>Literal result elements</li>

        <li>Extension instructions, if so defined</li>
      </ul>

      <p><b><a href=
      "#element-analyze-string">xsl:analyze-string</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:analyze-string<br />
            &#160;&#160;<b>select</b> = <var>expression</var><br />
            &#160;&#160;<b>regex</b> = { <var>string</var> }<br />
            &#160;&#160;flags? = { <var>string</var> }&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-matching-substring">xsl:matching-substring</a>?,
            <a href=
            "#element-non-matching-substring">xsl:non-matching-substring</a>?,
            <a href="#element-fallback">xsl:fallback</a>*)
            --&gt;<br />
            &lt;/xsl:analyze-string&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-apply-imports">xsl:apply-imports</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:apply-imports&gt;<br />
            &#160;&#160;&lt;!-- Content: <a href=
            "#element-with-param">xsl:with-param</a>* --&gt;<br />
            &lt;/xsl:apply-imports&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-apply-templates">xsl:apply-templates</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:apply-templates<br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;mode? = <var>token</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-sort">xsl:sort</a> | <a href=
            "#element-with-param">xsl:with-param</a>)* --&gt;<br />
            &lt;/xsl:apply-templates&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-attribute">xsl:attribute</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:attribute<br />
            &#160;&#160;<b>name</b> = { <var>qname</var> }<br />
            &#160;&#160;namespace? = { <var>uri-reference</var>
            }<br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;separator? = { <var>string</var> }<br />
            &#160;&#160;type? = <var>qname</var><br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:attribute&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:attribute-set</code></li>

              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-attribute-set">xsl:attribute-set</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:attribute-set<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;use-attribute-sets? =
            <var>qnames</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: <a href=
            "#element-attribute">xsl:attribute</a>* --&gt;<br />
            &lt;/xsl:attribute-set&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-call-template">xsl:call-template</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:call-template<br />
            &#160;&#160;<b>name</b> = <var>qname</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: <a href=
            "#element-with-param">xsl:with-param</a>* --&gt;<br />
            &lt;/xsl:call-template&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-character-map">xsl:character-map</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:character-map<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;use-character-maps? =
            <var>qnames</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-output-character">xsl:output-character</a>*)
            --&gt;<br />
            &lt;/xsl:character-map&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-choose">xsl:choose</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:choose&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-when">xsl:when</a>+, <a href=
            "#element-otherwise">xsl:otherwise</a>?) --&gt;<br />
            &lt;/xsl:choose&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-comment">xsl:comment</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:comment<br />
            &#160;&#160;select? = <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:comment&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-copy">xsl:copy</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:copy<br />
            &#160;&#160;copy-namespaces? = "yes" | "no"<br />
            &#160;&#160;inherit-namespaces? = "yes" | "no"<br />
            &#160;&#160;use-attribute-sets? =
            <var>qnames</var><br />
            &#160;&#160;type? = <var>qname</var><br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:copy&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-copy-of">xsl:copy-of</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:copy-of<br />
            &#160;&#160;<b>select</b> = <var>expression</var><br />
            &#160;&#160;copy-namespaces? = "yes" | "no"<br />
            &#160;&#160;type? = <var>qname</var><br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-decimal-format">xsl:decimal-format</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:decimal-format<br />
            &#160;&#160;name? = <var>qname</var><br />
            &#160;&#160;decimal-separator? = <var>char</var><br />
            &#160;&#160;grouping-separator? = <var>char</var><br />
            &#160;&#160;infinity? = <var>string</var><br />
            &#160;&#160;minus-sign? = <var>char</var><br />
            &#160;&#160;NaN? = <var>string</var><br />
            &#160;&#160;percent? = <var>char</var><br />
            &#160;&#160;per-mille? = <var>char</var><br />
            &#160;&#160;zero-digit? = <var>char</var><br />
            &#160;&#160;digit? = <var>char</var><br />
            &#160;&#160;pattern-separator? =
            <var>char</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-document">xsl:document</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:document<br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"<br />
            &#160;&#160;type? = <var>qname</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:document&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-element">xsl:element</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:element<br />
            &#160;&#160;<b>name</b> = { <var>qname</var> }<br />
            &#160;&#160;namespace? = { <var>uri-reference</var>
            }<br />
            &#160;&#160;inherit-namespaces? = "yes" | "no"<br />
            &#160;&#160;use-attribute-sets? =
            <var>qnames</var><br />
            &#160;&#160;type? = <var>qname</var><br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:element&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-fallback">xsl:fallback</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:fallback&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:fallback&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-for-each">xsl:for-each</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:for-each<br />
            &#160;&#160;<b>select</b> =
            <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-sort">xsl:sort</a>*,
            <var>sequence-constructor</var>) --&gt;<br />
            &lt;/xsl:for-each&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-for-each-group">xsl:for-each-group</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:for-each-group<br />
            &#160;&#160;<b>select</b> = <var>expression</var><br />
            &#160;&#160;group-by? = <var>expression</var><br />
            &#160;&#160;group-adjacent? =
            <var>expression</var><br />
            &#160;&#160;group-starting-with? =
            <var>pattern</var><br />
            &#160;&#160;group-ending-with? =
            <var>pattern</var><br />
            &#160;&#160;collation? = { <var>uri</var> }&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-sort">xsl:sort</a>*,
            <var>sequence-constructor</var>) --&gt;<br />
            &lt;/xsl:for-each-group&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-function">xsl:function</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:function<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;as? = <var>sequence-type</var><br />
            &#160;&#160;override? = "yes" | "no"&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-param">xsl:param</a>*,
            <var>sequence-constructor</var>) --&gt;<br />
            &lt;/xsl:function&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-if">xsl:if</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:if<br />
            &#160;&#160;<b>test</b> =
            <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:if&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-import">xsl:import</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:import<br />
            &#160;&#160;<b>href</b> =
            <var>uri-reference</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-import-schema">xsl:import-schema</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:import-schema<br />
            &#160;&#160;namespace? = <var>uri-reference</var><br />
            &#160;&#160;schema-location? =
            <var>uri-reference</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: xs:schema? --&gt;<br />
            &lt;/xsl:import-schema&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-include">xsl:include</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:include<br />
            &#160;&#160;<b>href</b> =
            <var>uri-reference</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-key">xsl:key</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:key<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;<b>match</b> = <var>pattern</var><br />
            &#160;&#160;use? = <var>expression</var><br />
            &#160;&#160;collation? = <var>uri</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:key&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-matching-substring">xsl:matching-substring</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:matching-substring&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:matching-substring&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:analyze-string</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-message">xsl:message</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:message<br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;terminate? = { "yes" | "no" }&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:message&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>

              <li><code>xsl:function</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-namespace">xsl:namespace</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:namespace<br />
            &#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
            &#160;&#160;select? = <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:namespace&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-namespace-alias">xsl:namespace-alias</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:namespace-alias<br />
            &#160;&#160;<b>stylesheet-prefix</b> =
            <var>prefix</var> | "#default"<br />
            &#160;&#160;<b>result-prefix</b> = <var>prefix</var> |
            "#default"&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-next-match">xsl:next-match</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:next-match&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-with-param">xsl:with-param</a> | <a href=
            "#element-fallback">xsl:fallback</a>)* --&gt;<br />
            &lt;/xsl:next-match&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-non-matching-substring">xsl:non-matching-substring</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:non-matching-substring&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:non-matching-substring&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:analyze-string</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-number">xsl:number</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:number<br />
            &#160;&#160;value? = <var>expression</var><br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;level? = "single" | "multiple" |
            "any"<br />
            &#160;&#160;count? = <var>pattern</var><br />
            &#160;&#160;from? = <var>pattern</var><br />
            &#160;&#160;format? = { <var>string</var> }<br />
            &#160;&#160;lang? = { <var>nmtoken</var> }<br />
            &#160;&#160;letter-value? = { "alphabetic" |
            "traditional" }<br />
            &#160;&#160;ordinal? = { <var>string</var> }<br />
            &#160;&#160;grouping-separator? = { <var>char</var>
            }<br />
            &#160;&#160;grouping-size? = { <var>number</var>
            }&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-otherwise">xsl:otherwise</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:otherwise&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:otherwise&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:choose</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-output">xsl:output</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:output<br />
            &#160;&#160;name? = <var>qname</var><br />
            &#160;&#160;method? = "xml" | "html" | "xhtml" | "text"
            | <var>qname-but-not-ncname</var><br />
            &#160;&#160;byte-order-mark? = "yes" | "no"<br />
            &#160;&#160;cdata-section-elements? =
            <var>qnames</var><br />
            &#160;&#160;doctype-public? = <var>string</var><br />
            &#160;&#160;doctype-system? = <var>string</var><br />
            &#160;&#160;encoding? = <var>string</var><br />
            &#160;&#160;escape-uri-attributes? = "yes" | "no"<br />
            &#160;&#160;include-content-type? = "yes" | "no"<br />
            &#160;&#160;indent? = "yes" | "no"<br />
            &#160;&#160;media-type? = <var>string</var><br />
            &#160;&#160;normalization-form? = "NFC" | "NFD" |
            "NFKC" | "NFKD" | "fully-normalized" | "none" |
            <var>nmtoken</var><br />
            &#160;&#160;omit-xml-declaration? = "yes" | "no"<br />
            &#160;&#160;standalone? = "yes" | "no" | "omit"<br />
            &#160;&#160;undeclare-prefixes? = "yes" | "no"<br />
            &#160;&#160;use-character-maps? =
            <var>qnames</var><br />
            &#160;&#160;version? =
            <var>nmtoken</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-output-character">xsl:output-character</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:output-character<br />
            &#160;&#160;<b>character</b> = <var>char</var><br />
            &#160;&#160;<b>string</b> =
            <var>string</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:character-map</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-param">xsl:param</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:param<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;as? = <var>sequence-type</var><br />
            &#160;&#160;required? = "yes" | "no"<br />
            &#160;&#160;tunnel? = "yes" | "no"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:param&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>

              <li><code>xsl:function</code></li>

              <li><code>xsl:template</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-perform-sort">xsl:perform-sort</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:perform-sort<br />
            &#160;&#160;select? = <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-sort">xsl:sort</a>+,
            <var>sequence-constructor</var>) --&gt;<br />
            &lt;/xsl:perform-sort&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-preserve-space">xsl:preserve-space</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:preserve-space<br />
            &#160;&#160;<b>elements</b> =
            <var>tokens</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-processing-instruction">xsl:processing-instruction</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:processing-instruction<br />
            &#160;&#160;<b>name</b> = { <var>ncname</var> }<br />
            &#160;&#160;select? = <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:processing-instruction&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-result-document">xsl:result-document</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:result-document<br />
            &#160;&#160;format? = { <var>qname</var> }<br />
            &#160;&#160;href? = { <var>uri-reference</var> }<br />
            &#160;&#160;validation? = "strict" | "lax" | "preserve"
            | "strip"<br />
            &#160;&#160;type? = <var>qname</var><br />
            &#160;&#160;method? = { "xml" | "html" | "xhtml" |
            "text" | <var>qname-but-not-ncname</var> }<br />
            &#160;&#160;byte-order-mark? = { "yes" | "no" }<br />
            &#160;&#160;cdata-section-elements? = {
            <var>qnames</var> }<br />
            &#160;&#160;doctype-public? = { <var>string</var>
            }<br />
            &#160;&#160;doctype-system? = { <var>string</var>
            }<br />
            &#160;&#160;encoding? = { <var>string</var> }<br />
            &#160;&#160;escape-uri-attributes? = { "yes" | "no"
            }<br />
            &#160;&#160;include-content-type? = { "yes" | "no"
            }<br />
            &#160;&#160;indent? = { "yes" | "no" }<br />
            &#160;&#160;media-type? = { <var>string</var> }<br />
            &#160;&#160;normalization-form? = { "NFC" | "NFD" |
            "NFKC" | "NFKD" | "fully-normalized" | "none" |
            <var>nmtoken</var> }<br />
            &#160;&#160;omit-xml-declaration? = { "yes" | "no"
            }<br />
            &#160;&#160;standalone? = { "yes" | "no" | "omit"
            }<br />
            &#160;&#160;undeclare-prefixes? = { "yes" | "no"
            }<br />
            &#160;&#160;use-character-maps? =
            <var>qnames</var><br />
            &#160;&#160;output-version? = { <var>nmtoken</var>
            }&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:result-document&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-sequence">xsl:sequence</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:sequence<br />
            &#160;&#160;<b>select</b> =
            <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: <a href=
            "#element-fallback">xsl:fallback</a>* --&gt;<br />
            &lt;/xsl:sequence&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-sort">xsl:sort</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:sort<br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;lang? = { <var>nmtoken</var> }<br />
            &#160;&#160;order? = { "ascending" | "descending"
            }<br />
            &#160;&#160;collation? = { <var>uri</var> }<br />
            &#160;&#160;stable? = { "yes" | "no" }<br />
            &#160;&#160;case-order? = { "upper-first" |
            "lower-first" }<br />
            &#160;&#160;data-type? = { "text" | "number" |
            <var>qname-but-not-ncname</var> }&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:sort&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:apply-templates</code></li>

              <li><code>xsl:for-each</code></li>

              <li><code>xsl:for-each-group</code></li>

              <li><code>xsl:perform-sort</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-strip-space">xsl:strip-space</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:strip-space<br />
            &#160;&#160;<b>elements</b> =
            <var>tokens</var>&#160;/&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-stylesheet">xsl:stylesheet</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:stylesheet<br />
            &#160;&#160;id? = <var>id</var><br />
            &#160;&#160;extension-element-prefixes? =
            <var>tokens</var><br />
            &#160;&#160;exclude-result-prefixes? =
            <var>tokens</var><br />
            &#160;&#160;<b>version</b> = <var>number</var><br />
            &#160;&#160;xpath-default-namespace? =
            <var>uri</var><br />
            &#160;&#160;default-validation? = "preserve" |
            "strip"<br />
            &#160;&#160;default-collation? =
            <var>uri-list</var><br />
            &#160;&#160;input-type-annotations? = "preserve" |
            "strip" | "unspecified"&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-import">xsl:import</a>*,
            <var>other-declarations</var>) --&gt;<br />
            &lt;/xsl:stylesheet&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>None</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-template">xsl:template</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:template<br />
            &#160;&#160;match? = <var>pattern</var><br />
            &#160;&#160;name? = <var>qname</var><br />
            &#160;&#160;priority? = <var>number</var><br />
            &#160;&#160;mode? = <var>tokens</var><br />
            &#160;&#160;as? = <var>sequence-type</var>&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-param">xsl:param</a>*,
            <var>sequence-constructor</var>) --&gt;<br />
            &lt;/xsl:template&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-text">xsl:text</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:text<br />
            &#160;&#160;<span class=
            "grayed">[disable-output-escaping]?</span> = "yes" |
            "no"&gt;<br />
            &#160;&#160;&lt;!-- Content: #PCDATA --&gt;<br />
            &lt;/xsl:text&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-transform">xsl:transform</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:transform<br />
            &#160;&#160;id? = <var>id</var><br />
            &#160;&#160;extension-element-prefixes? =
            <var>tokens</var><br />
            &#160;&#160;exclude-result-prefixes? =
            <var>tokens</var><br />
            &#160;&#160;<b>version</b> = <var>number</var><br />
            &#160;&#160;xpath-default-namespace? =
            <var>uri</var><br />
            &#160;&#160;default-validation? = "preserve" |
            "strip"<br />
            &#160;&#160;default-collation? =
            <var>uri-list</var><br />
            &#160;&#160;input-type-annotations? = "preserve" |
            "strip" | "unspecified"&gt;<br />
            &#160;&#160;&lt;!-- Content: (<a href=
            "#element-import">xsl:import</a>*,
            <var>other-declarations</var>) --&gt;<br />
            &lt;/xsl:transform&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>None</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-value-of">xsl:value-of</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:value-of<br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;separator? = { <var>string</var> }<br />
            &#160;&#160;<span class=
            "grayed">[disable-output-escaping]?</span> = "yes" |
            "no"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:value-of&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-variable">xsl:variable</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Category:</i> declaration instruction</p>

            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:variable<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;as? = <var>sequence-type</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:variable&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:stylesheet</code></li>

              <li><code>xsl:transform</code></li>

              <li><code>xsl:function</code></li>

              <li>any XSLT element whose content model is
              <i>sequence constructor</i></li>

              <li>any literal result element</li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href="#element-when">xsl:when</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:when<br />
            &#160;&#160;<b>test</b> =
            <var>expression</var>&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:when&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:choose</code></li>
            </ul>
          </td>
        </tr>
      </table>

      <p><b><a href=
      "#element-with-param">xsl:with-param</a></b></p>

      <table width="100%">
        <tr>
          <td width="10%">&#160;</td>

          <td>
            <p><i>Model:</i></p>

            <p class="element-syntax-summary">
            <code>&lt;xsl:with-param<br />
            &#160;&#160;<b>name</b> = <var>qname</var><br />
            &#160;&#160;select? = <var>expression</var><br />
            &#160;&#160;as? = <var>sequence-type</var><br />
            &#160;&#160;tunnel? = "yes" | "no"&gt;<br />
            &#160;&#160;&lt;!-- Content:
            <var>sequence-constructor</var> --&gt;<br />
            &lt;/xsl:with-param&gt;</code></p>

            <p><i>Permitted parent elements:</i></p>

            <ul>
              <li><code>xsl:apply-templates</code></li>

              <li><code>xsl:apply-imports</code></li>

              <li><code>xsl:call-template</code></li>

              <li><code>xsl:next-match</code></li>
            </ul>
          </td>
        </tr>
      </table>
    </div>

    <div class="div1">
      <h2><a name="error-summary" id="error-summary"></a>E Summary
      of Error Conditions (Non-Normative)</h2>

      <p>This appendix provides a summary of error conditions that
      a processor may signal. This list is not exhaustive or
      definitive. The errors are numbered for ease of reference,
      but there is no implication that an implementation
      <span class="verb">must</span> signal errors using these
      error codes, or that applications can test for these codes.
      Moreover, implementations are not <span class=
      "verb">required</span> to signal errors using the descriptive
      text used here.</p>

      <p><b>Static errors</b></p>

      <dl>
        <dt><a href="#err-XTSE0010"><span class="error">ERR
        XTSE0010</span></a></dt>

        <dd>
          <p>A <a title="static error" href=
          "#dt-static-error">static error</a> is signaled if an
          XSLT-defined element is used in a context where it is not
          permitted, if a <span class="verb">required</span>
          attribute is omitted, or if the content of the element
          does not correspond to the content that is allowed for
          the element.</p>
        </dd>

        <dt><a href="#err-XTSE0020"><span class="error">ERR
        XTSE0020</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an attribute
          (other than an attribute written using curly brackets in
          a position where an <a title="attribute value template"
          href="#dt-attribute-value-template">attribute value
          template</a> is permitted) contains a value that is not
          one of the permitted values for that attribute.</p>
        </dd>

        <dt><a href="#err-XTSE0080"><span class="error">ERR
        XTSE0080</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> to use a <a title=
          "reserved namespace" href=
          "#dt-reserved-namespace">reserved namespace</a> in the
          name of a <a title="named template" href=
          "#dt-named-template">named template</a>, a <a title=
          "mode" href="#dt-mode">mode</a>, an <a title=
          "attribute set" href="#dt-attribute-set">attribute
          set</a>, a <a title="key" href="#dt-key">key</a>, a
          <a title="decimal format" href=
          "#dt-decimal-format">decimal-format</a>, a <a title=
          "variable" href="#dt-variable">variable</a> or <a title=
          "parameter" href="#dt-parameter">parameter</a>, a
          <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a>, a
          named <a title="output definition" href=
          "#dt-output-definition">output definition</a>, or a
          <a title="character map" href=
          "#dt-character-map">character map</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0090"><span class="error">ERR
        XTSE0090</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> for an element from
          the XSLT namespace to have an attribute whose namespace
          is either null (that is, an attribute with an unprefixed
          name) or the XSLT namespace, other than attributes
          defined for the element in this document.</p>
        </dd>

        <dt><a href="#err-XTSE0110"><span class="error">ERR
        XTSE0110</span></a></dt>

        <dd>
          <p>The value of the <code>version</code> attribute
          <span class="verb">must</span> be a number: specifically,
          it <span class="verb">must</span> be a <span>a valid
          instance of the type <code>xs:decimal</code> as defined
          in <a href="#xmlschema-2">[XML Schema Part
          2]</a></span>.</p>
        </dd>

        <dt><a href="#err-XTSE0120"><span class="error">ERR
        XTSE0120</span></a></dt>

        <dd>
          <p>An <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element <span class="verb">must not</span> have any text
          node children.</p>
        </dd>

        <dt><a href="#err-XTSE0125"><span class="error">ERR
        XTSE0125</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of an
          <code>[xsl:]default-collation</code> attribute<span>,
          after resolving against the base URI,</span> contains no
          URI that the implementation recognizes as a collation
          URI.</p>
        </dd>

        <dt><a href="#err-XTSE0130"><span class="error">ERR
        XTSE0130</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element has a child element whose name has a null
          namespace URI.</p>
        </dd>

        <dt><a href="#err-XTSE0150"><span class="error">ERR
        XTSE0150</span></a></dt>

        <dd>
          <p>A <a title="literal result element" href=
          "#dt-literal-result-element">literal result element</a>
          that is used as the outermost element of a simplified
          stylesheet module <span class="verb">must</span> have an
          <code>xsl:version</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTSE0165"><span class="error">ERR
        XTSE0165</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the processor is
          not able to retrieve the resource identified by the URI
          reference [ in the <code>href</code> attribute of
          <a href="#element-include"><code>xsl:include</code></a>
          or <a href="#element-import"><code>xsl:import</code></a>]
          , or if the resource that is retrieved does not contain a
          stylesheet module conforming to this specification.</p>
        </dd>

        <dt><a href="#err-XTSE0170"><span class="error">ERR
        XTSE0170</span></a></dt>

        <dd>
          <p>An <a href=
          "#element-include"><code>xsl:include</code></a> element
          <span class="verb">must</span> be a <a title="top-level"
          href="#dt-top-level">top-level</a> element.</p>
        </dd>

        <dt><a href="#err-XTSE0180"><span class="error">ERR
        XTSE0180</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a stylesheet
          module directly or indirectly includes itself.</p>
        </dd>

        <dt><a href="#err-XTSE0190"><span class="error">ERR
        XTSE0190</span></a></dt>

        <dd>
          <p>An <a href=
          "#element-import"><code>xsl:import</code></a> element
          <span class="verb">must</span> be a <a title="top-level"
          href="#dt-top-level">top-level</a> element.</p>
        </dd>

        <dt><a href="#err-XTSE0200"><span class="error">ERR
        XTSE0200</span></a></dt>

        <dd>
          <p>The <a href=
          "#element-import"><code>xsl:import</code></a> element
          children <span class="verb">must</span> precede all other
          element children of an <a href=
          "#element-stylesheet"><code>xsl:stylesheet</code></a>
          element, including any <a href=
          "#element-include"><code>xsl:include</code></a> element
          children and any <a title="user-defined data element"
          href="#dt-data-element">user-defined data
          elements</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0210"><span class="error">ERR
        XTSE0210</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a stylesheet
          module directly or indirectly imports itself.</p>
        </dd>

        <dt><a href="#err-XTSE0215"><span class="error">ERR
        XTSE0215</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          element that contains an <code>xs:schema</code> element
          has a <code>schema-location</code> attribute, or if it
          has a <code>namespace</code> attribute that conflicts
          with the target namespace of the contained schema.</p>
        </dd>

        <dt><a href="#err-XTSE0220"><span class="error">ERR
        XTSE0220</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the synthetic
          schema document does not satisfy the constraints
          described in <a href="#xmlschema-1">[XML Schema Part
          1]</a> (section 5.1, <em>Errors in Schema Construction
          and Structure</em>). This includes, without loss of
          generality, conflicts such as multiple definitions of the
          same name.</p>
        </dd>

        <dt><a href="#err-XTSE0260"><span class="error">ERR
        XTSE0260</span></a></dt>

        <dd>
          <p>Within an <a title="XSLT element" href=
          "#dt-xslt-element">XSLT element</a> that is <span class=
          "verb">required</span> to be empty, any content other
          than comments or processing instructions, including any
          <a title="whitespace text node" href=
          "#dt-whitespace-text-node">whitespace text node</a>
          preserved using the <code>xml:space="preserve"</code>
          attribute, is a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0265"><span class="error">ERR
        XTSE0265</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if there is a
          <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a> in the
          <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> that specifies
          <code>input-type-annotations="strip"</code> and another
          <a title="stylesheet module" href=
          "#dt-stylesheet-module">stylesheet module</a> that
          specifies
          <code>input-type-annotations="preserve"</code>.</p>
        </dd>

        <dt><a href="#err-XTSE0280"><span class="error">ERR
        XTSE0280</span></a></dt>

        <dd>
          <p>In the case of a <span>prefixed</span> <a title=
          "QName" href="#dt-qname">QName</a> used as the value of
          an attribute in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>, or appearing within an
          XPath <a title="expression" href=
          "#dt-expression">expression</a> in the stylesheet, it is
          a <a title="static error" href="#dt-static-error">static
          error</a> if the <a title="defining element" href=
          "#dt-defining-element">defining element</a> has no
          namespace node whose name matches the prefix of the
          <a title="QName" href="#dt-qname">QName</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0340"><span class="error">ERR
        XTSE0340</span></a></dt>

        <dd>
          <p>Where an attribute is defined to contain a <a title=
          "pattern" href="#dt-pattern">pattern</a>, it is a
          <a title="static error" href="#dt-static-error">static
          error</a> if the pattern does not match the production
          <a href="#NT-Pattern">Pattern</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0350"><span class="error">ERR
        XTSE0350</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an unescaped left
          curly bracket appears in a fixed part of an attribute
          value template without a matching right curly
          bracket.</p>
        </dd>

        <dt><a href="#err-XTSE0370"><span class="error">ERR
        XTSE0370</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an unescaped right
          curly bracket occurs in a fixed part of an attribute
          value template.</p>
        </dd>

        <dt><a href="#err-XTSE0500"><span class="error">ERR
        XTSE0500</span></a></dt>

        <dd>
          <p>An <a href=
          "#element-template"><code>xsl:template</code></a> element
          <span class="verb">must</span> have either a
          <code>match</code> attribute or a <code>name</code>
          attribute, or both. An <a href=
          "#element-template"><code>xsl:template</code></a> element
          that has no <code>match</code> attribute <span class=
          "verb">must</span> have no <code>mode</code> attribute
          and no <code>priority</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTSE0530"><span class="error">ERR
        XTSE0530</span></a></dt>

        <dd>
          <p>The value of this attribute [the <code>priority</code>
          attribute of the <a href=
          "#element-template"><code>xsl:template</code></a>
          element] <span class="verb">must</span> <span>conform to
          the rules for the <code>xs:decimal</code> type defined in
          <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative
          values are permitted.</span>.</p>
        </dd>

        <dt><a href="#err-XTSE0550"><span class="error">ERR
        XTSE0550</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the list [of modes
          in the <code>mode</code> attribute of <a href=
          "#element-template"><code>xsl:template</code></a>] is
          empty, if the same token is included more than once in
          the list, if the list contains an invalid token, or if
          the token <code>#all</code> appears together with any
          other value.</p>
        </dd>

        <dt><a href="#err-XTSE0580"><span class="error">ERR
        XTSE0580</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if two parameters of
          a template or of a stylesheet function have the same
          name.</p>
        </dd>

        <dt><a href="#err-XTSE0620"><span class="error">ERR
        XTSE0620</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a <a title=
          "variable-binding element" href=
          "#dt-variable-binding-element">variable-binding
          element</a> has a <code>select</code> attribute and has
          non-empty content.</p>
        </dd>

        <dt><a href="#err-XTSE0630"><span class="error">ERR
        XTSE0630</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>
          contains more than one binding of a global variable with
          the same name and same <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a><span>,
          unless it also contains another binding with the same
          name and higher import precedence</span>.</p>
        </dd>

        <dt><a href="#err-XTSE0650"><span class="error">ERR
        XTSE0650</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>
          contains an <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          instruction whose <code>name</code> attribute does not
          match the <code>name</code> attribute of any <a href=
          "#element-template"><code>xsl:template</code></a> in the
          <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>.</p>
        </dd>

        <dt><a href="#err-XTSE0660"><span class="error">ERR
        XTSE0660</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>
          contains more than one <a title="template" href=
          "#dt-template">template</a> with the same name and the
          same <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a><span>,
          unless it also contains a <a title="template" href=
          "#dt-template">template</a> with the same name and higher
          <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a></span>.</p>
        </dd>

        <dt><a href="#err-XTSE0670"><span class="error">ERR
        XTSE0670</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a single <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          <span>or <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>
          element contains two or more <a href=
          "#element-with-param"><code>xsl:with-param</code></a>
          elements with <span>matching <code>name</code>
          attributes</span>.</p>
        </dd>

        <dt><a href="#err-XTSE0680"><span class="error">ERR
        XTSE0680</span></a></dt>

        <dd>
          <p>In the case of <a href=
          "#element-call-template"><code>xsl:call-template</code></a>,
          it is a <a title="static error" href=
          "#dt-static-error">static error</a> to pass a
          <span>non-tunnel</span> parameter named <var>x</var> to a
          template that does not have a <a title=
          "template parameter" href=
          "#dt-template-parameter">template parameter</a> named
          <var>x</var><span>, unless <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled for the <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          instruction</span>.</p>
        </dd>

        <dt><a href="#err-XTSE0690"><span class="error">ERR
        XTSE0690</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a template that is
          invoked using <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          declares a <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a>
          specifying <code>required="yes"</code> <span>and not
          specifying <code>tunnel="yes"</code></span>, if no value
          for this parameter is supplied by the calling
          instruction.</p>
        </dd>

        <dt><a href="#err-XTSE0710"><span class="error">ERR
        XTSE0710</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of the
          <code>use-attribute-sets</code> attribute of an <a href=
          "#element-copy"><code>xsl:copy</code></a>, <a href=
          "#element-element"><code>xsl:element</code></a>, or
          <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a>
          element, or the <code>xsl:use-attribute-sets</code>
          attribute of a <a title="literal result element" href=
          "#dt-literal-result-element">literal result element</a>,
          is not a <span>whitespace-separated</span> sequence of
          <a title="QName" href="#dt-qname">QNames</a>, or if it
          contains a QName that does not match the
          <code>name</code> attribute of any <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a>
          declaration in the stylesheet.</p>
        </dd>

        <dt><a href="#err-XTSE0720"><span class="error">ERR
        XTSE0720</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-attribute-set"><code>xsl:attribute-set</code></a>
          element directly or indirectly references itself via the
          names contained in the <code>use-attribute-sets</code>
          attribute.</p>
        </dd>

        <dt><a href="#err-XTSE0740"><span class="error">ERR
        XTSE0740</span></a></dt>

        <dd>
          <p>A <a title="stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a>
          <span class="verb">must</span> have a prefixed name, to
          remove any risk of a clash with a function in the default
          function namespace. It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the name has no
          prefix.</p>
        </dd>

        <dt><a href="#err-XTSE0760"><span class="error">ERR
        XTSE0760</span></a></dt>

        <dd>
          <p>Because arguments to a stylesheet function call
          <span class="verb">must</span> all be specified, the
          <a href="#element-param"><code>xsl:param</code></a>
          elements within an <a href=
          "#element-function"><code>xsl:function</code></a> element
          <span class="verb">must not</span> specify a default
          value: this means they <span class="verb">must</span> be
          empty, and <span class="verb">must not</span> have a
          <code>select</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTSE0770"><span class="error">ERR
        XTSE0770</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> for a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> to
          contain two or more functions with the same <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a>, the same
          <a title="arity" href="#dt-arity">arity</a>, and the same
          <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a>, unless
          there is another function with the same <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> and arity, and a
          higher import precedence.</p>
        </dd>

        <dt><a href="#err-XTSE0805"><span class="error">ERR
        XTSE0805</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an attribute on a
          literal result element is in the <a title=
          "XSLT namespace" href="#dt-xslt-namespace">XSLT
          namespace</a>, unless it is one of the attributes
          explicitly defined in this specification.</p>
        </dd>

        <dt><a href="#err-XTSE0808"><span class="error">ERR
        XTSE0808</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a namespace prefix
          is used within the
          <code>[xsl:]exclude-result-prefixes</code> attribute and
          there is no namespace binding in scope for that
          prefix.</p>
        </dd>

        <dt><a href="#err-XTSE0809"><span class="error">ERR
        XTSE0809</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value
          <code>#default</code> is used within the
          <code>[xsl:]exclude-result-prefixes</code> attribute and
          the parent element of the
          <code>[xsl:]exclude-result-prefixes</code> attribute has
          no default namespace.</p>
        </dd>

        <dt><a href="#err-XTSE0810"><span class="error">ERR
        XTSE0810</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if there is more than
          one such declaration [more than one <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          declaration] with the same <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> and
          the same <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a> and
          different values for the <a title="target namespace URI"
          href="#dt-target-namespace-uri">target namespace URI</a>,
          unless there is also an <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          declaration with the same <a title=
          "literal namespace URI" href=
          "#dt-literal-namespace-uri">literal namespace URI</a> and
          a higher import precedence.</p>
        </dd>

        <dt><a href="#err-XTSE0812"><span class="error">ERR
        XTSE0812</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a value other than
          <code>#default</code> is specified for either the
          <code>stylesheet-prefix</code> or the
          <code>result-prefix</code> attributes of the <a href=
          "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
          element when there is no in-scope binding for that
          namespace prefix.</p>
        </dd>

        <dt><a href="#err-XTSE0840"><span class="error">ERR
        XTSE0840</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>select</code> attribute of the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          element is present unless the element has empty
          content.</p>
        </dd>

        <dt><a href="#err-XTSE0870"><span class="error">ERR
        XTSE0870</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>select</code> attribute of the <a href=
          "#element-value-of"><code>xsl:value-of</code></a> element
          is present when the content of the element is non-empty,
          or if the <code>select</code> attribute is absent when
          the content is empty.</p>
        </dd>

        <dt><a href="#err-XTSE0880"><span class="error">ERR
        XTSE0880</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>select</code> attribute of the <a href=
          "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
          element is present unless the element has empty
          content.</p>
        </dd>

        <dt><a href="#err-XTSE0910"><span class="error">ERR
        XTSE0910</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>select</code> attribute of the <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          element is present when the element has content other
          than one or more <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          instructions, or if the <code>select</code> attribute is
          absent when the element has empty content.</p>
        </dd>

        <dt><a href="#err-XTSE0940"><span class="error">ERR
        XTSE0940</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>select</code> attribute of the <a href=
          "#element-comment"><code>xsl:comment</code></a> element
          is present unless the element has empty content.</p>
        </dd>

        <dt><a href="#err-XTTE0950"><span class="error">ERR
        XTTE0950</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> to use the <a href=
          "#element-copy"><code>xsl:copy</code></a> or <a href=
          "#element-copy-of"><code>xsl:copy-of</code></a>
          instruction to copy a node that has namespace-sensitive
          content if the <code>copy-namespaces</code> attribute has
          the value <code>no</code> and its explicit or implicit
          <code>validation</code> attribute has the value
          <code>preserve</code>. It is also a type error if either
          of these instructions (with
          <code>validation="preserve"</code>) is used to copy an
          attribute having namespace-sensitive content, unless the
          parent element is also copied. A node has
          namespace-sensitive content if its typed value contains
          an item of type <code>xs:QName</code> or
          <code>xs:NOTATION</code> or a type derived therefrom. The
          reason this is an error is because the validity of the
          content depends on the namespace context being
          preserved.</p>
        </dd>

        <dt><a href="#err-XTSE0975"><span class="error">ERR
        XTSE0975</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the
          <code>value</code> attribute of <a href=
          "#element-number"><code>xsl:number</code></a> is present
          unless the <code>select</code>, <code>level</code>,
          <code>count</code>, and <code>from</code> attributes are
          all absent.</p>
        </dd>

        <dt><a href="#err-XTSE1015"><span class="error">ERR
        XTSE1015</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-sort"><code>xsl:sort</code></a> element with a
          <code>select</code> attribute has non-empty content.</p>
        </dd>

        <dt><a href="#err-XTSE1017"><span class="error">ERR
        XTSE1017</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-sort"><code>xsl:sort</code></a> element other
          than the first in a sequence of sibling <a href=
          "#element-sort"><code>xsl:sort</code></a> elements has a
          <code>stable</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTSE1040"><span class="error">ERR
        XTSE1040</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-perform-sort"><code>xsl:perform-sort</code></a>
          instruction with a <code>select</code> attribute has any
          content other than <a href=
          "#element-sort"><code>xsl:sort</code></a> and <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          instructions.</p>
        </dd>

        <dt><a href="#err-XTSE1060"><span class="error">ERR
        XTSE1060</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the <a href=
          "#function-current-group"><code>current-group</code></a>
          function is used within a <a title="pattern" href=
          "#dt-pattern">pattern</a>.</p>
        </dd>

        <dt><a href="#err-XTSE1070"><span class="error">ERR
        XTSE1070</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the <a href=
          "#function-current-grouping-key"><code>current-grouping-key</code></a>
          function is used within a <a title="pattern" href=
          "#dt-pattern">pattern</a>.</p>
        </dd>

        <dt><a href="#err-XTSE1080"><span class="error">ERR
        XTSE1080</span></a></dt>

        <dd>
          <p>These four attributes [the <code>group-by</code>,
          <code>group-adjacent</code>,
          <code>group-starting-with</code>, and
          <code>group-ending-with</code> attributes of <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          ] are mutually exclusive: it is a <a title="static error"
          href="#dt-static-error">static error</a> if none of these
          four attributes is present, or if more than one of them
          is present.</p>
        </dd>

        <dt><a href="#err-XTSE1090"><span class="error">ERR
        XTSE1090</span></a></dt>

        <dd>
          <p>It is an error to specify the <code>collation</code>
          attribute if neither the <code>group-by</code> attribute
          nor <code>group-adjacent</code> attribute is
          specified.</p>
        </dd>

        <dt><a href="#err-XTSE1130"><span class="error">ERR
        XTSE1130</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          instruction contains neither an <a href=
          "#element-matching-substring"><code>xsl:matching-substring</code></a>
          nor an <a href=
          "#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
          element.</p>
        </dd>

        <dt><a href="#err-XTSE1205"><span class="error">ERR
        XTSE1205</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if an <a href=
          "#element-key"><code>xsl:key</code></a> declaration has a
          <code>use</code> attribute and has non-empty content, or
          if it has empty content and no <code>use</code>
          attribute.</p>
        </dd>

        <dt><a href="#err-XTSE1210"><span class="error">ERR
        XTSE1210</span></a></dt>

        <dd>
          <p>It is a static error if the <a href=
          "#element-key"><code>xsl:key</code></a> declaration has a
          <code>collation</code> attribute whose value <span>(after
          resolving against the base URI)</span> is not a URI
          recognized by the implementation as referring to a
          collation.</p>
        </dd>

        <dt><a href="#err-XTSE1220"><span class="error">ERR
        XTSE1220</span></a></dt>

        <dd>
          <p>It is a static error if there are several <a href=
          "#element-key"><code>xsl:key</code></a> declarations in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> with the same key name
          and different effective collations. Two collations are
          the same if their URIs are equal under the rules for
          comparing <code>xs:anyURI</code> values, or if the
          implementation can determine that they are different URIs
          referring to the same collation.</p>
        </dd>

        <dt><a href="#err-XTSE1290"><span class="error">ERR
        XTSE1290</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a named or unnamed
          <a title="decimal format" href=
          "#dt-decimal-format">decimal format</a> contains two
          conflicting values for the same attribute in different
          <a href=
          "#element-decimal-format"><code>xsl:decimal-format</code></a>
          declarations having the same <a title="import precedence"
          href="#dt-import-precedence">import precedence</a>,
          unless there is another definition of the same attribute
          with higher import precedence.</p>
        </dd>

        <dt><a href="#err-XTSE1295"><span class="error">ERR
        XTSE1295</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the character
          specified in the <code>zero-digit</code> attribute is not
          a digit or is a digit that does not have the numeric
          value zero.</p>
        </dd>

        <dt><a href="#err-XTSE1300"><span class="error">ERR
        XTSE1300</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if, for any named or
          unnamed decimal format, the variables representing
          characters used in a <a title="picture string" href=
          "#dt-picture-string">picture string</a> do not each have
          distinct values. These variables are
          <var>decimal-separator-sign</var>,
          <var>grouping-sign</var>, <var>percent-sign</var>,
          <var>per-mille-sign</var>, <var>digit-zero-sign</var>,
          <var>digit-sign</var>, and
          <var>pattern-separator-sign</var>.</p>
        </dd>

        <dt><a href="#err-XTSE1430"><span class="error">ERR
        XTSE1430</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if there is no
          namespace bound to the prefix on the element bearing the
          <code>[xsl:]extension-element-prefixes</code> attribute
          <span>or, when <code>#default</code> is specified, if
          there is no default namespace</span>.</p>
        </dd>

        <dt><a href="#err-XTSE1505"><span class="error">ERR
        XTSE1505</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if both the
          <code>[xsl:]type</code> and <code>[xsl:]validation</code>
          attributes are present on the <a href=
          "#element-element"><code>xsl:element</code></a>, <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>,
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          <span><a href=
          "#element-document"><code>xsl:document</code></a></span>,
          or <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instructions, or on a <a title="literal result element"
          href="#dt-literal-result-element">literal result
          element</a>.</p>
        </dd>

        <dt><a href="#err-XTSE1520"><span class="error">ERR
        XTSE1520</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of the
          <code>type</code> attribute of an <a href=
          "#element-element"><code>xsl:element</code></a>, <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>,
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          <span><a href=
          "#element-document"><code>xsl:document</code></a>,</span>
          or <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction, or the <code>xsl:type</code> attribute of a
          literal result element, is not a valid
          <code>QName</code>, or if it uses a prefix that is not
          defined in an in-scope namespace declaration, or if the
          QName is not the name of a type definition included in
          the <a title="in-scope schema component" href=
          "#dt-in-scope-schema-component">in-scope schema
          components</a> for the stylesheet.</p>
        </dd>

        <dt><a href="#err-XTSE1530"><span class="error">ERR
        XTSE1530</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of the
          <code>type</code> attribute of an <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction refers to a complex type definition</p>
        </dd>

        <dt><a href="#err-XTSE1560"><span class="error">ERR
        XTSE1560</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if two <a href=
          "#element-output"><code>xsl:output</code></a>
          declarations within an <a title="output definition" href=
          "#dt-output-definition">output definition</a> specify
          explicit values for the same attribute (other than
          <code>cdata-section-elements</code> and
          <code>use-character-maps</code>), with the values of the
          attributes being not equal, unless there is another
          <a href="#element-output"><code>xsl:output</code></a>
          declaration within the same <a title="output definition"
          href="#dt-output-definition">output definition</a> that
          has higher import precedence and that specifies an
          explicit value for the same attribute.</p>
        </dd>

        <dt><a href="#err-XTSE1570"><span class="error">ERR
        XTSE1570</span></a></dt>

        <dd>
          <p>The value [of the <code>method</code> attribute on
          <a href="#element-output"><code>xsl:output</code></a> ]
          <span class="verb">must</span> <span>(if present)</span>
          be a valid <a title="QName" href="#dt-qname">QName</a>.
          If the <a title="QName" href="#dt-qname">QName</a> does
          not have a prefix, then it identifies a method specified
          in <a href="#xslt-xquery-serialization">[XSLT and XQuery
          Serialization]</a> and <span class="verb">must</span> be
          one of <code>xml</code>, <code>html</code>,
          <code>xhtml</code>, or <code>text</code>.</p>
        </dd>

        <dt><a href="#err-XTSE1580"><span class="error">ERR
        XTSE1580</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if the <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a>
          contains two or more character maps with the same name
          and the same <a title="import precedence" href=
          "#dt-import-precedence">import precedence</a><span>,
          unless it also contains another character map with the
          same name and higher import precedence.</span></p>
        </dd>

        <dt><a href="#err-XTSE1590"><span class="error">ERR
        XTSE1590</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a name in the
          <code>use-character-maps</code> attribute <span>of the
          <a href="#element-output"><code>xsl:output</code></a> or
          <a href=
          "#element-character-map"><code>xsl:character-map</code></a>
          elements</span> does not match the <code>name</code>
          attribute of any <a href=
          "#element-character-map"><code>xsl:character-map</code></a>
          in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>.</p>
        </dd>

        <dt><a href="#err-XTSE1600"><span class="error">ERR
        XTSE1600</span></a></dt>

        <dd>
          <p>It is a <a title="static error" href=
          "#dt-static-error">static error</a> if a character map
          references itself, directly or indirectly, via a name in
          the <code>use-character-maps</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTSE1650"><span class="error">ERR
        XTSE1650</span></a></dt>

        <dd>
          <p>A <a title="basic XSLT processor" href=
          "#dt-basic-xslt-processor">basic XSLT processor</a>
          <span class="verb">must</span> signal a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> includes an <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          declaration.</p>
        </dd>

        <dt><a href="#err-XTSE1660"><span class="error">ERR
        XTSE1660</span></a></dt>

        <dd>
          <p>A <a title="basic XSLT processor" href=
          "#dt-basic-xslt-processor">basic XSLT processor</a>
          <span class="verb">must</span> signal a <a title=
          "static error" href="#dt-static-error">static error</a>
          if the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> includes an
          <code>[xsl:]type</code> attribute, or an
          <code>[xsl:]validation</code> or
          <code>default-validation</code> attribute with a value
          other than <code>strip</code>.</p>
        </dd>
      </dl>

      <p><b>Type errors</b></p>

      <dl>
        <dt><a href="#err-XTTE0505"><span class="error">ERR
        XTTE0505</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the result of
          evaluating the <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>
          cannot be converted to the required type.</p>
        </dd>

        <dt><a href="#err-XTTE0510"><span class="error">ERR
        XTTE0510</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if an <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>
          instruction with no <code>select</code> attribute is
          evaluated when the <a title="context item" href=
          "#dt-context-item">context item</a> is not a node.</p>
        </dd>

        <dt><a href="#err-XTTE0520"><span class="error">ERR
        XTTE0520</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the sequence returned
          by the <code>select</code> expression [of <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>]
          contains an item that is not a node.</p>
        </dd>

        <dt><a href="#err-XTTE0570"><span class="error">ERR
        XTTE0570</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the <a title=
          "supplied value" href="#dt-supplied-value">supplied
          value</a> of a variable cannot be converted to the
          required type.</p>
        </dd>

        <dt><a href="#err-XTTE0590"><span class="error">ERR
        XTTE0590</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the conversion of the
          <a title="supplied value" href=
          "#dt-supplied-value">supplied value</a> of a parameter to
          its required type fails.</p>
        </dd>

        <dt><a href="#err-XTTE0600"><span class="error">ERR
        XTTE0600</span></a></dt>

        <dd>
          <p>If a default value is given explicitly, that is, if
          there is either a <code>select</code> attribute or a
          non-empty <a title="sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, then
          it is a <a title="type errors" href="#dt-type-error">type
          error</a> if the default value cannot be converted to the
          required type, using the <a title=
          "function conversion rules" href=
          "#dt-function-conversion-rules">function conversion
          rules</a>.</p>
        </dd>

        <dt><a href="#err-XTTE0780"><span class="error">ERR
        XTTE0780</span></a></dt>

        <dd>
          <p>If the <code>as</code> attribute [of <a href=
          "#element-function"><code>xsl:function</code></a> ] is
          specified, then the result evaluated by the <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> (see
          <a href="#sequence-constructors"><i>5.7 Sequence
          Constructors</i></a>) is converted to the required type,
          using the <a title="function conversion rules" href=
          "#dt-function-conversion-rules">function conversion
          rules</a>. It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if this conversion
          fails.</p>
        </dd>

        <dt><a href="#err-XTTE0790"><span class="error">ERR
        XTTE0790</span></a></dt>

        <dd>
          <p>If the value of a parameter to a <a title=
          "stylesheet function" href=
          "#dt-stylesheet-function">stylesheet function</a> cannot
          be converted to the required type, a <a title=
          "type errors" href="#dt-type-error">type error</a> is
          signaled.</p>
        </dd>

        <dt><a href="#err-XTTE0990"><span class="error">ERR
        XTTE0990</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the <a href=
          "#element-number"><code>xsl:number</code></a> instruction
          is evaluated, with no <code>value</code> or
          <code>select</code> attribute, when the <a title=
          "context item" href="#dt-context-item">context item</a>
          is not a node.</p>
        </dd>

        <dt><a href="#err-XTTE1000"><span class="error">ERR
        XTTE1000</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the result of
          evaluating the <code>select</code> attribute of the
          <a href="#element-number"><code>xsl:number</code></a>
          instruction is anything other than a single node.</p>
        </dd>

        <dt><a href="#err-XTTE1020"><span class="error">ERR
        XTTE1020</span></a></dt>

        <dd>
          <p>If any <a title="sort key value" href=
          "#dt-sort-key-value">sort key value</a>, after <a title=
          "atomize" href="#dt-atomization">atomization</a> and any
          type conversion <span class="verb">required</span> by the
          <code>data-type</code> attribute, is a sequence
          containing more than one item, then the effect depends on
          whether the <a href=
          "#element-sort"><code>xsl:sort</code></a> element is
          evaluated with <a title="backwards compatible behavior"
          href="#dt-backwards-compatible-behavior">backwards
          compatible behavior</a>. With backwards compatible
          behavior, the effective sort key value is the first item
          in the sequence. In other cases, this is a <a title=
          "type errors" href="#dt-type-error">type error</a>.</p>
        </dd>

        <dt><a href="#err-XTTE1100"><span class="error">ERR
        XTTE1100</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if the <span>grouping key
          evaluated using</span> the <code>group-adjacent</code>
          attribute is an empty sequence, or a sequence containing
          more than one item.</p>
        </dd>

        <dt><a href="#err-XTTE1120"><span class="error">ERR
        XTTE1120</span></a></dt>

        <dd>
          <p>When the <code>group-starting-with</code> or
          <code>group-ending-with</code> attribute [of the <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          instruction] is used, it is a <a title="type errors"
          href="#dt-type-error">type error</a> if the result of
          evaluating the <code>select</code> expression contains an
          item that is not a node.</p>
        </dd>

        <dt><a href="#err-XTTE1510"><span class="error">ERR
        XTTE1510</span></a></dt>

        <dd>
          <p>If the <code>validation</code> attribute of an
          <a href="#element-element"><code>xsl:element</code></a>,
          <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>,
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          or <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction, or the <code>xsl:validation</code> attribute
          of a literal result element, has the effective value
          <code>strict</code>, and schema validity assessment
          concludes that the validity of the element or attribute
          is invalid or unknown, a type error occurs. As with other
          type errors, the error <span class="verb">may</span> be
          signaled statically if it can be detected statically.</p>
        </dd>

        <dt><a href="#err-XTTE1512"><span class="error">ERR
        XTTE1512</span></a></dt>

        <dd>
          <p>If the <code>validation</code> attribute of an
          <a href="#element-element"><code>xsl:element</code></a>,
          <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>,
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          or <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction, or the <code>xsl:validation</code> attribute
          of a literal result element, has the effective value
          <code>strict</code>, and there is no matching top-level
          declaration in the schema, then a type error occurs. As
          with other type errors, the error <span class=
          "verb">may</span> be signaled statically if it can be
          detected statically.</p>
        </dd>

        <dt><a href="#err-XTTE1515"><span class="error">ERR
        XTTE1515</span></a></dt>

        <dd>
          <p>If the <code>validation</code> attribute of an
          <a href="#element-element"><code>xsl:element</code></a>,
          <a href=
          "#element-attribute"><code>xsl:attribute</code></a>,
          <a href="#element-copy"><code>xsl:copy</code></a>,
          <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
          or <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction, or the <code>xsl:validation</code> attribute
          of a literal result element, has the effective value
          <code>lax</code>, and schema validity assessment
          concludes that the element or attribute is invalid, a
          type error occurs. As with other type errors, the error
          <span class="verb">may</span> be signaled statically if
          it can be detected statically.</p>
        </dd>

        <dt><a href="#err-XTTE1540"><span class="error">ERR
        XTTE1540</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if an
          <code>[xsl:]type</code> attribute is defined for a
          constructed element or attribute, and the outcome of
          schema validity assessment against that type is that the
          <code>validity</code> property of that element or
          attribute information item is other than
          <code>valid</code>.</p>
        </dd>

        <dt><a href="#err-XTTE1545"><span class="error">ERR
        XTTE1545</span></a></dt>

        <dd>
          <p>A <a title="type errors" href="#dt-type-error">type
          error</a> occurs if a <code>type</code> or
          <code>validation</code> attribute is defined (explicitly
          or implicitly) for an instruction that constructs a new
          attribute node, if the effect of this is to cause the
          attribute value to be validated against a type that is
          derived from, or constructed by list or union from, the
          primitive types <code>xs:QName</code> or
          <code>xs:NOTATION</code>.</p>
        </dd>

        <dt><a href="#err-XTTE1550"><span class="error">ERR
        XTTE1550</span></a></dt>

        <dd>
          <p>A <a title="type errors" href="#dt-type-error">type
          error</a> occurs [when a document node is validated]
          unless the children of the document node comprise exactly
          one element node, no text nodes, and zero or more comment
          and processing instruction nodes, in any order.</p>
        </dd>

        <dt><a href="#err-XTTE1555"><span class="error">ERR
        XTTE1555</span></a></dt>

        <dd>
          <p>It is a <a title="type errors" href=
          "#dt-type-error">type error</a> if, when validating a
          document node, document-level constraints are not
          satisfied. These constraints include identity constraints
          (<code>xs:unique</code>, <code>xs:key</code>, and
          <code>xs:keyref</code>) and ID/IDREF constraints.</p>
        </dd>
      </dl>

      <p><b>Dynamic errors</b></p>

      <dl>
        <dt><a href="#err-XTDE0030"><span class="error">ERR
        XTDE0030</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of an attribute
          written using curly brackets, in a position where an
          <a title="attribute value template" href=
          "#dt-attribute-value-template">attribute value
          template</a> is permitted, is a value that is not one of
          the permitted values for that attribute. If the processor
          is able to detect the error statically (for example, when
          any XPath expressions within the curly brackets can be
          evaluated statically), then the processor may optionally
          signal this as a static error.</p>
        </dd>

        <dt><a href="#err-XTDE0040"><span class="error">ERR
        XTDE0040</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the invocation of the <a title="stylesheet"
          href="#dt-stylesheet">stylesheet</a> specifies a template
          name that does not match the <a title="expanded-QName"
          href="#dt-expanded-qname">expanded-QName</a> of a named
          template defined in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0045"><span class="error">ERR
        XTDE0045</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the invocation of the <a title="stylesheet"
          href="#dt-stylesheet">stylesheet</a> specifies an initial
          <a title="mode" href="#dt-mode">mode</a> (other than the
          default mode) that does not match the <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> in the
          <code>mode</code> attribute of any template defined in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0047"><span class="error">ERR
        XTDE0047</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the invocation of the <a title="stylesheet"
          href="#dt-stylesheet">stylesheet</a> specifies both an
          initial <a title="mode" href="#dt-mode">mode</a> and an
          initial template.</p>
        </dd>

        <dt><a href="#err-XTDE0050"><span class="error">ERR
        XTDE0050</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the stylesheet that is invoked declares a
          visible <a title="stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameter</a> with
          <code>required="yes"</code> and no value for this
          parameter is supplied during the invocation of the
          stylesheet. A stylesheet parameter is visible if it is
          not masked by another global variable or parameter with
          the same name and higher <a title="import precedence"
          href="#dt-import-precedence">import precedence</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0060"><span class="error">ERR
        XTDE0060</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="initial template" href=
          "#dt-initial-template">initial template</a> defines a
          <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a> that
          specifies <code>required="yes"</code>.</p>
        </dd>

        <dt><a href="#err-XTDE0160"><span class="error">ERR
        XTDE0160</span></a></dt>

        <dd>
          <p>If an implementation does not support
          backwards-compatible behavior, then it is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if any element is evaluated that enables
          backwards-compatible behavior.</p>
        </dd>

        <dt><a href="#err-XTRE0270"><span class="error">ERR
        XTRE0270</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          this [the process of finding an <a href=
          "#element-strip-space"><code>xsl:strip-space</code></a>
          or <a href=
          "#element-preserve-space"><code>xsl:preserve-space</code></a>
          declaration to match an element in the source document]
          leaves more than one match<span>, unless all the matched
          declarations are equivalent (that is, they are all
          <a href=
          "#element-strip-space"><code>xsl:strip-space</code></a>
          or they are all <a href=
          "#element-preserve-space"><code>xsl:preserve-space</code></a>)</span>.<br />

          <i>&#160;&#160;&#160;&#160;Action:</i> <span>The
          <a title="optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to select, from the matches that are left,
          the one that occurs last in <a title="declaration order"
          href="#dt-declaration-order">declaration
          order</a>.</span></p>
        </dd>

        <dt><a href="#err-XTDE0290"><span class="error">ERR
        XTDE0290</span></a></dt>

        <dd>
          <p>Where the result of evaluating an XPath expression (or
          an attribute value template) is required to be a
          <a title="lexical QName" href="#dt-lexical-qname">lexical
          QName</a>, <span>then unless otherwise specified</span>
          it is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="defining element" href=
          "#dt-defining-element">defining element</a> has no
          namespace node whose name matches the prefix of the
          <a title="lexical QName" href="#dt-lexical-qname">lexical
          QName</a>. <span>This error <span class="verb">may</span>
          be signaled as a <a title="static error" href=
          "#dt-static-error">static error</a> if the value of the
          expression can be determined statically.</span></p>
        </dd>

        <dt><a href="#err-XTDE0410"><span class="error">ERR
        XTDE0410</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the result sequence used to construct the
          content of an element node contains a namespace node or
          attribute node that is preceded in the sequence by a node
          that is neither a namespace node nor an attribute
          node.</p>
        </dd>

        <dt><a href="#err-XTDE0420"><span class="error">ERR
        XTDE0420</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the result sequence used to construct the
          content of a document node contains a namespace node or
          attribute node.</p>
        </dd>

        <dt><a href="#err-XTDE0430"><span class="error">ERR
        XTDE0430</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the result sequence contains two or more
          namespace nodes having the same name but different
          <a title="string value" href="#dt-string-value">string
          values</a> (that is, namespace nodes that map the same
          prefix to different namespace URIs).</p>
        </dd>

        <dt><a href="#err-XTDE0440"><span class="error">ERR
        XTDE0440</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the result sequence contains a namespace
          node with no name and the element node being constructed
          has a null namespace URI (that is, it is an error to
          define a default namespace when the element is in no
          namespace).</p>
        </dd>

        <dt><a href="#err-XTDE0485"><span class="error">ERR
        XTDE0485</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if namespace fixup is performed on an element
          that contains among the typed values of the element and
          its attributes two values of type <code>xs:QName</code>
          or <code>xs:NOTATION</code> containing conflicting
          namespace prefixes, that is, two values that use the same
          prefix to refer to different namespace URIs.</p>
        </dd>

        <dt><a href="#err-XTRE0540"><span class="error">ERR
        XTRE0540</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          the conflict resolution algorithm for template rules
          leaves more than one matching template rule.<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to select, from the matching template rules
          that are left, the one that occurs last in <a title=
          "declaration order" href=
          "#dt-declaration-order">declaration order</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0560"><span class="error">ERR
        XTDE0560</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>
          <span>or <a href=
          "#element-next-match"><code>xsl:next-match</code></a></span>
          is evaluated when the <a title="current template rule"
          href="#dt-current-template-rule">current template
          rule</a> is null.</p>
        </dd>

        <dt><a href="#err-XTDE0610"><span class="error">ERR
        XTDE0610</span></a></dt>

        <dd>
          <p>If an optional parameter has no <code>select</code>
          attribute and has an empty <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a>, and
          if there is an <code>as</code> attribute, then the
          default value of the parameter is an empty sequence. If
          the empty sequence is not a valid instance of the
          required type defined in the <code>as</code> attribute,
          then the parameter is treated as a required parameter,
          which means that it is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the caller supplies no value for the
          parameter.</p>
        </dd>

        <dt><a href="#err-XTDE0640"><span class="error">ERR
        XTDE0640</span></a></dt>

        <dd>
          <p>In general, a <a title="circularity" href=
          "#dt-circularity">circularity</a> in a <a title=
          "stylesheet" href="#dt-stylesheet">stylesheet</a> is a
          <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0700"><span class="error">ERR
        XTDE0700</span></a></dt>

        <dd>
          <p>In other cases, [with <a href=
          "#element-apply-templates"><code>xsl:apply-templates</code></a>,
          <a href=
          "#element-apply-imports"><code>xsl:apply-imports</code></a>,
          and <a href=
          "#element-next-match"><code>xsl:next-match</code></a>, or
          <a href=
          "#element-call-template"><code>xsl:call-template</code></a>
          with <a title="tunnel parameter" href=
          "#dt-tunnel-parameter">tunnel parameters</a>] it is a
          <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the template that is invoked declares a
          <a title="template parameter" href=
          "#dt-template-parameter">template parameter</a> with
          <code>required="yes"</code> and no value for this
          parameter is supplied by the calling instruction.</p>
        </dd>

        <dt><a href="#err-XTRE0795"><span class="error">ERR
        XTRE0795</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          the name of a constructed attribute is
          <code>xml:space</code> and the value is not either
          <code>default</code> or <code>preserve</code>.<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to construct the attribute with the value
          as requested.</p>
        </dd>

        <dt><a href="#err-XTDE0820"><span class="error">ERR
        XTDE0820</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute [of the <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction] is not a <a title="lexical QName" href=
          "#dt-lexical-qname">lexical QName</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0830"><span class="error">ERR
        XTDE0830</span></a></dt>

        <dd>
          <p>In the case of an <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction with no <code>namespace</code> attribute, it
          is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute is a <a title="QName" href=
          "#dt-qname">QName</a> whose prefix is not declared in an
          in-scope namespace declaration for the <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction.</p>
        </dd>

        <dt><a href="#err-XTDE0835"><span class="error">ERR
        XTDE0835</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>namespace</code> attribute [of the <a href=
          "#element-element"><code>xsl:element</code></a>
          instruction] is not in the lexical space of the
          <code>xs:anyURI</code> data type.</p>
        </dd>

        <dt><a href="#err-XTDE0850"><span class="error">ERR
        XTDE0850</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute [of an <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction] is not a <a title="lexical QName" href=
          "#dt-lexical-qname">lexical QName</a>.</p>
        </dd>

        <dt><a href="#err-XTDE0855"><span class="error">ERR
        XTDE0855</span></a></dt>

        <dd>
          <p>In the case of an <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction with no <code>namespace</code> attribute, it
          is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute is the string
          <code>xmlns</code>.</p>
        </dd>

        <dt><a href="#err-XTDE0860"><span class="error">ERR
        XTDE0860</span></a></dt>

        <dd>
          <p>In the case of an <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction with no <code>namespace</code> attribute, it
          is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute is a <a title="lexical QName"
          href="#dt-lexical-qname">lexical QName</a> whose prefix
          is not declared in an in-scope namespace declaration for
          the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction.</p>
        </dd>

        <dt><a href="#err-XTDE0865"><span class="error">ERR
        XTDE0865</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>namespace</code> attribute [of the <a href=
          "#element-attribute"><code>xsl:attribute</code></a>
          instruction] is not in the lexical space of the
          <code>xs:anyURI</code> data type.</p>
        </dd>

        <dt><a href="#err-XTDE0890"><span class="error">ERR
        XTDE0890</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute [of the <a href=
          "#element-processing-instruction"><code>xsl:processing-instruction</code></a>
          instruction] is not both an <a href=
          "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
          <small>Names</small></sup> and a <a href=
          "http://www.w3.org/TR/2000/REC-xml-20001006#NT-PITarget">PITarget</a><sup>
          <small>XML</small></sup>.</p>
        </dd>

        <dt><a href="#err-XTDE0905"><span class="error">ERR
        XTDE0905</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the string value of the new namespace node
          [created using <a href=
          "#element-namespace"><code>xsl:namespace</code></a>] is
          not valid in the lexical space of the data type
          <code>xs:anyURI</code>. <span class="error">[see <a href=
          "#err-XTDE0835">ERR XTDE0835</a>]</span></p>
        </dd>

        <dt><a href="#err-XTDE0920"><span class="error">ERR
        XTDE0920</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>name</code> attribute [of the <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction] is neither a zero-length string nor an
          <a href=
          "http://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup>
          <small>Names</small></sup>, or if it is
          <code>xmlns</code>.</p>
        </dd>

        <dt><a href="#err-XTDE0925"><span class="error">ERR
        XTDE0925</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction generates a namespace node whose name is
          <code>xml</code> and whose string value is not
          <code>http://www.w3.org/XML/1998/namespace</code>, or a
          namespace node whose string value is
          <code>http://www.w3.org/XML/1998/namespace</code> and
          whose name is not <code>xml</code>.</p>
        </dd>

        <dt><a href="#err-XTDE0930"><span class="error">ERR
        XTDE0930</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if evaluating the <span><code>select</code>
          attribute or the contained <a title=
          "sequence constructor" href=
          "#dt-sequence-constructor">sequence constructor</a> of an
          <a href=
          "#element-namespace"><code>xsl:namespace</code></a>
          instruction</span> results in a zero-length string.</p>
        </dd>

        <dt><a href="#err-XTDE0980"><span class="error">ERR
        XTDE0980</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if any undiscarded item in the atomized
          sequence supplied as the value of the <code>value</code>
          attribute of <a href=
          "#element-number"><code>xsl:number</code></a> cannot be
          converted to an integer, or if the resulting integer is
          less than 0 (zero).</p>
        </dd>

        <dt><a href="#err-XTDE1030"><span class="error">ERR
        XTDE1030</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if, for any <a title="sort key component" href=
          "#dt-sort-key-component">sort key component</a>, the set
          of <a title="sort key value" href=
          "#dt-sort-key-value">sort key values</a> evaluated for
          all the items in the <a title="initial sequence" href=
          "#dt-initial-sequence">initial sequence</a>, after any
          type conversion requested, contains a pair of ordinary
          values for which the result of the XPath <code>lt</code>
          operator is an error.</p>
        </dd>

        <dt><a href="#err-XTDE1035"><span class="error">ERR
        XTDE1035</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <code>collation</code> attribute of
          <a href="#element-sort"><code>xsl:sort</code></a> (after
          resolving against the base URI) is not a URI that is
          recognized by the implementation as referring to a
          collation.</p>
        </dd>

        <dt><a href="#err-XTDE1110"><span class="error">ERR
        XTDE1110</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the collation URI specified to <a href=
          "#element-for-each-group"><code>xsl:for-each-group</code></a>
          <span>(after resolving against the base URI)</span> is a
          collation that is not recognized by the implementation.
          (For notes, <span class="error">[see <a href=
          "#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
        </dd>

        <dt><a href="#err-XTDE1140"><span class="error">ERR
        XTDE1140</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>regex</code> attribute [of the <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          instruction] does not conform to the <span class=
          "verb">required</span> syntax for regular expressions, as
          specified in <a href="#xpath-functions">[Functions and
          Operators]</a>. If the regular expression is known
          statically (for example, if the attribute does not
          contain any <a title="expression" href=
          "#dt-expression">expressions</a> enclosed in curly
          brackets) then the processor <span class=
          "verb">may</span> signal the error as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1145"><span class="error">ERR
        XTDE1145</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>flags</code> attribute [of the <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          instruction] has a value other than the values defined in
          <a href="#xpath-functions">[Functions and Operators]</a>.
          If the value of the attribute is known statically (for
          example, if the attribute does not contain any <a title=
          "expression" href="#dt-expression">expressions</a>
          enclosed in curly brackets) then the processor
          <span class="verb">may</span> signal the error as a
          <a title="static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1150"><span class="error">ERR
        XTDE1150</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>regex</code> attribute [of the <a href=
          "#element-analyze-string"><code>xsl:analyze-string</code></a>
          instruction] is a regular expression that matches a
          zero-length string: or more specifically, if the regular
          expression <code>$r</code> and flags <code>$f</code> are
          such that <code>matches("", $r, $f)</code> returns true.
          If the regular expression is known statically (for
          example, if the attribute does not contain any <a title=
          "expression" href="#dt-expression">expressions</a>
          enclosed in curly brackets) then the processor
          <span class="verb">may</span> signal the error as a
          <a title="static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTRE1160"><span class="error">ERR
        XTRE1160</span></a></dt>

        <dd>
          <p>When a URI reference [supplied to the <a href=
          "#function-document"><code>document</code></a> function]
          contains a fragment identifier, it is a <a title=
          "recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          the media type is not one that is recognized by the
          processor, or if the fragment identifier does not conform
          to the rules for fragment identifiers for that media
          type, or if the fragment identifier selects something
          other than a sequence of nodes (for example, if it
          selects a range of characters within a text node).<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to ignore the fragment identifier and
          return the document node.</p>
        </dd>

        <dt><a href="#err-XTDE1170"><span class="error">ERR
        XTDE1170</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if a URI [supplied in the first argument to the
          <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function] <span>contains a fragment identifier,</span> or
          if it cannot be used to retrieve a resource containing
          text.</p>
        </dd>

        <dt><a href="#err-XTDE1190"><span class="error">ERR
        XTDE1190</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if a resource [retrieved using the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function] contains octets that cannot be decoded into
          Unicode characters using the specified encoding, or if
          the resulting characters are not permitted XML
          characters. This includes the case where the <a title=
          "processor" href="#dt-processor">processor</a> does not
          support the requested encoding.</p>
        </dd>

        <dt><a href="#err-XTDE1200"><span class="error">ERR
        XTDE1200</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the second argument of the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function is omitted and the <a title="processor" href=
          "#dt-processor">processor</a> cannot infer the encoding
          using external information and the encoding is not
          UTF-8.</p>
        </dd>

        <dt><a href="#err-XTDE1260"><span class="error">ERR
        XTDE1260</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the value [of the first argument to the
          <a href="#function-key"><code>key</code></a> function] is
          not a valid QName, or if there is no namespace
          declaration in scope for the prefix of the QName, or if
          the name obtained by expanding the QName is not the same
          as the expanded name of any <a href=
          "#element-key"><code>xsl:key</code></a> declaration in
          the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>. If the processor is able
          to detect the error statically (for example, when the
          argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1270"><span class="error">ERR
        XTDE1270</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> to call the <a href=
          "#function-key"><code>key</code></a> function with two
          arguments if there is no <a title="context node" href=
          "#dt-context-node">context node</a>, <span>or if the root
          of the tree containing the context node is not a document
          node</span>; or to call the function with three arguments
          if the root of the tree containing the node supplied in
          the third argument is not a document node.</p>
        </dd>

        <dt><a href="#err-XTDE1280"><span class="error">ERR
        XTDE1280</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the name specified as the
          <code>$decimal-format-name</code> argument [ to the
          <a href=
          "#function-format-number"><code>format-number</code></a>
          function] <span>is not a valid <a title="QName" href=
          "#dt-qname">QName</a>, or if its prefix has not been
          declared in an in-scope namespace declaration</span>, or
          if the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> does not contain a
          declaration of a decimal-format with a matching <a title=
          "expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a>. If the processor
          is able to detect the error statically (for example, when
          the argument is supplied as a string literal), then the
          processor <span class="verb">may</span> optionally signal
          this as a <a title="static error" href=
          "#dt-static-error">static error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1310"><span class="error">ERR
        XTDE1310</span></a></dt>

        <dd>
          <p>The <a title="picture string" href=
          "#dt-picture-string">picture string</a> [supplied to the
          <a href=
          "#function-format-number"><code>format-number</code></a>
          function] <span class="verb">must</span> conform to the
          following rules. [ See full specification.] It is a
          <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the picture string does not satisfy these
          rules.</p>
        </dd>

        <dt><a href="#err-XTDE1340"><span class="error">ERR
        XTDE1340</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the syntax of the picture [used for
          date/time formatting] is incorrect.</p>
        </dd>

        <dt><a href="#err-XTDE1350"><span class="error">ERR
        XTDE1350</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if a component specifier within the picture
          [used for date/time formatting] refers to components that
          are not available in the given type of
          <code>$value</code>, for example if the picture supplied
          to the <a href=
          "#function-format-time"><code>format-time</code></a>
          refers to the year, month, or day component.</p>
        </dd>

        <dt><a href="#err-XTDE1360"><span class="error">ERR
        XTDE1360</span></a></dt>

        <dd>
          <p>If the <a href=
          "#function-current"><code>current</code></a> function is
          evaluated within an expression that is evaluated when the
          context item is undefined, a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> occurs.</p>
        </dd>

        <dt><a href="#err-XTDE1370"><span class="error">ERR
        XTDE1370</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a href=
          "#function-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
          function is called when there is no <a title=
          "context node" href="#dt-context-node">context node</a>,
          or when the root of the tree containing the context node
          is not a document node.</p>
        </dd>

        <dt><a href="#err-XTDE1380"><span class="error">ERR
        XTDE1380</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a href=
          "#function-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a>
          function is called when there is no <a title=
          "context node" href="#dt-context-node">context node</a>,
          or when the root of the tree containing the context node
          is not a document node.</p>
        </dd>

        <dt><a href="#err-XTDE1390"><span class="error">ERR
        XTDE1390</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the value [supplied as the
          <code>$property-name</code> argument to the <a href=
          "#function-system-property"><code>system-property</code></a>
          function] is not a valid QName, or if there is no
          namespace declaration in scope for the prefix of the
          QName. If the processor is able to detect the error
          statically (for example, when the argument is supplied as
          a string literal), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTMM9000"><span class="error">ERR
        XTMM9000</span></a></dt>

        <dd>
          <p>When a transformation is terminated by use of
          <code>xsl:message terminate="yes"</code>, the effect is
          the same as when a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> occurs during the transformation.</p>
        </dd>

        <dt><a href="#err-XTDE1400"><span class="error">ERR
        XTDE1400</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument [passed to the <a href=
          "#function-function-available"><code>function-available</code></a>
          function] does not evaluate to a string that is a valid
          <a title="QName" href="#dt-qname">QName</a>, or if there
          is no namespace declaration in scope for the prefix of
          the <a title="QName" href="#dt-qname">QName</a>. If the
          processor is able to detect the error statically (for
          example, when the argument is supplied as a string
          literal), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1420"><span class="error">ERR
        XTDE1420</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the arguments supplied to a call on an
          extension function do not satisfy the rules defined for
          that particular extension function, or if the extension
          function reports an error, or if the result of the
          extension function cannot be converted to an XPath
          value.</p>
        </dd>

        <dt><a href="#err-XTDE1425"><span class="error">ERR
        XTDE1425</span></a></dt>

        <dd>
          <p>When <a title="backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled, it is a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> to evaluate an extension function call if no
          implementation of the extension function is
          available.</p>
        </dd>

        <dt><a href="#err-XTDE1428"><span class="error">ERR
        XTDE1428</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument [passed to the <a href=
          "#function-type-available"><code>type-available</code></a>
          function] does not evaluate to a string that is a valid
          <a title="QName" href="#dt-qname">QName</a>, or if there
          is no namespace declaration in scope for the prefix of
          the <a title="QName" href="#dt-qname">QName</a>. If the
          processor is able to detect the error statically (for
          example, when the argument is supplied as a string
          literal), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1440"><span class="error">ERR
        XTDE1440</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the argument [passed to the <a href=
          "#function-element-available"><code>element-available</code></a>
          function] does not evaluate to a string that is a valid
          <a title="QName" href="#dt-qname">QName</a>, or if there
          is no namespace declaration in scope for the prefix of
          the <a title="QName" href="#dt-qname">QName</a>. If the
          processor is able to detect the error statically (for
          example, when the argument is supplied as a string
          literal), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1450"><span class="error">ERR
        XTDE1450</span></a></dt>

        <dd>
          <p>When a <a title="processor" href=
          "#dt-processor">processor</a> performs fallback for an
          <a title="extension instruction" href=
          "#dt-extension-instruction">extension instruction</a>
          that is not recognized, if the instruction element has
          one or more <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children, then the content of each of the <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children <span class="verb">must</span> be evaluated; it
          is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if it has no <a href=
          "#element-fallback"><code>xsl:fallback</code></a>
          children.</p>
        </dd>

        <dt><a href="#err-XTDE1460"><span class="error">ERR
        XTDE1460</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the <a title="effective value" href=
          "#dt-effective-value">effective value</a> of the
          <code>format</code> attribute [of an <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          element] is not a valid <a title="lexical QName" href=
          "#dt-lexical-qname">lexical QName</a>, or if it does not
          match the <a title="expanded-QName" href=
          "#dt-expanded-qname">expanded-QName</a> of an <a title=
          "output definition" href="#dt-output-definition">output
          definition</a> in the <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a>. If the processor is able
          to detect the error statically (for example, when the
          <code>format</code> attribute contains no curly
          brackets), then the processor <span class=
          "verb">may</span> optionally signal this as a <a title=
          "static error" href="#dt-static-error">static
          error</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1480"><span class="error">ERR
        XTDE1480</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> to evaluate the <a href=
          "#element-result-document"><code>xsl:result-document</code></a>
          instruction in <a title="temporary output state" href=
          "#dt-temporary-output-state">temporary output
          state</a>.</p>
        </dd>

        <dt><a href="#err-XTDE1490"><span class="error">ERR
        XTDE1490</span></a></dt>

        <dd>
          <p>It is a <a title="non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> for a transformation to generate two or more
          <a title="final result tree" href=
          "#dt-final-result-tree">final result trees</a> with the
          same URI.</p>
        </dd>

        <dt><a href="#err-XTRE1495"><span class="error">ERR
        XTRE1495</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> for
          a transformation to generate two or more <a title=
          "final result tree" href="#dt-final-result-tree">final
          result trees</a> with URIs that identify the same
          physical resource. The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is <a title="implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>,
          since it may be impossible for the processor to detect
          the error.</p>
        </dd>

        <dt><a href="#err-XTRE1500"><span class="error">ERR
        XTRE1500</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> for
          a <a title="stylesheet" href=
          "#dt-stylesheet">stylesheet</a> to write to an external
          resource and read from the same resource during a single
          transformation, whether or not the same URI is used to
          access the resource in both cases.<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is <a title="implementation-dependent" href=
          "#dt-implementation-dependent">implementation-dependent</a>:
          implementations are not <span class=
          "verb">required</span> to detect the error condition.
          <span>Note that if the error is not detected, it is
          undefined whether the document that is read from the
          resource reflects its state before or after the result
          tree is written.</span></p>
        </dd>

        <dt><a href="#err-XTRE1620"><span class="error">ERR
        XTRE1620</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          an <a href=
          "#element-value-of"><code>xsl:value-of</code></a> or
          <a href="#element-text"><code>xsl:text</code></a>
          instruction specifies that output escaping is to be
          disabled and the implementation does not support
          this.<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to ignore the
          <code>disable-output-escaping</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTRE1630"><span class="error">ERR
        XTRE1630</span></a></dt>

        <dd>
          <p>It is a <a title="recoverable error" href=
          "#dt-recoverable-error">recoverable dynamic error</a> if
          an <a href=
          "#element-value-of"><code>xsl:value-of</code></a> or
          <a href="#element-text"><code>xsl:text</code></a>
          instruction specifies that output escaping is to be
          disabled when writing to a <a title="final result tree"
          href="#dt-final-result-tree">final result tree</a> that
          is not being serialized.<br />
          <i>&#160;&#160;&#160;&#160;Action:</i> The <a title=
          "optional recovery action" href=
          "#dt-optional-recovery-action">optional recovery
          action</a> is to ignore the
          <code>disable-output-escaping</code> attribute.</p>
        </dd>

        <dt><a href="#err-XTDE1665"><span class="error">ERR
        XTDE1665</span></a></dt>

        <dd>
          <p>A <a title="basic XSLT processor" href=
          "#dt-basic-xslt-processor">basic XSLT processor</a>
          <span class="verb">must</span> raise a <a title=
          "non-recoverable dynamic error" href=
          "#dt-nonrec-dynamic-error">non-recoverable dynamic
          error</a> if the input to the processor includes a node
          with a <a title="type annotation" href=
          "#dt-annotation">type annotation</a> other than
          <span><code>xs:untyped</code></span> or
          <span><code>xs:untypedAtomic</code></span>, or an atomic
          value of a type other than those which a basic XSLT
          processor supports.</p>
        </dd>
      </dl>
    </div>

    <div class="div1">
      <h2><a name="implementation-defined-features" id=
      "implementation-defined-features"></a>F Checklist of
      Implementation-Defined Features (Non-Normative)</h2>

      <p>This appendix provides a summary of XSLT language features
      whose effect is explicitly <a title="implementation-defined"
      href="#dt-implementation-defined">implementation-defined</a>.
      The conformance rules (see <a href="#conformance"><i>21
      Conformance</i></a>) require vendors to provide documentation
      that explains how these choices have been exercised.</p>

      <ol>
        <li>
          <p>The way in which an XSLT processor is invoked, and the
          way in which values are supplied for the source document,
          starting node, <a title="stylesheet parameter" href=
          "#dt-stylesheet-parameter">stylesheet parameters</a>, and
          <a title="base output URI" href=
          "#dt-base-output-uri">base output URI</a>, are
          implementation-defined. (See <a href="#initiating"><i>2.3
          Initiating a Transformation</i></a>)</p>
        </li>

        <li>
          <p>The mechanisms for creating new extension instructions
          and extension functions are implementation-defined. (See
          <a href="#extensibility"><i>2.7
          Extensibility</i></a>)</p>
        </li>

        <li>
          <p>Where the specification provides a choice between
          signaling a dynamic error or recovering, the decision
          that is made (but not the recovery action itself) is
          implementation-defined. (See <a href="#errors"><i>2.9
          Error Handling</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined whether type errors are
          signaled statically. (See <a href="#errors"><i>2.9 Error
          Handling</i></a>)</p>
        </li>

        <li>
          <p>The set of namespaces that are specially recognized by
          the implementation (for example, for user-defined data
          elements, and <a title="extension attribute" href=
          "#dt-extension-attribute">extension attributes</a>) is
          implementation-defined. (See <a href=
          "#user-defined-top-level"><i>3.6.2 User-defined Data
          Elements</i></a>)</p>
        </li>

        <li>
          <p>The effect of user-defined data elements whose name is
          in a namespace recognized by the implementation is
          implementation-defined. (See <a href=
          "#user-defined-top-level"><i>3.6.2 User-defined Data
          Elements</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined whether an XSLT 2.0
          processor supports backwards-compatible behavior. (See
          <a href="#backwards"><i>3.8 Backwards-Compatible
          Processing</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined what forms of URI
          reference are acceptable in the <code>href</code>
          attribute of the <a href=
          "#element-include"><code>xsl:include</code></a> and
          <a href="#element-import"><code>xsl:import</code></a>
          elements, for example, the URI schemes that may be used,
          the forms of fragment identifier that may be used, and
          the media types that are supported. (See <a href=
          "#locating-modules"><i>3.10.1 Locating Stylesheet
          Modules</i></a>)</p>
        </li>

        <li>
          <p>An implementation may define mechanisms, above and
          beyond <a href=
          "#element-import-schema"><code>xsl:import-schema</code></a>
          that allow <a title="schema component" href=
          "#dt-schema-component">schema components</a> such as type
          definitions to be made available within a stylesheet.
          (See <a href="#built-in-types"><i>3.13 Built-in
          Types</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined which versions of XML and
          XML Namespaces (1.0 and/or 1.1) are supported. (See
          <a href="#xml-versions"><i>4.1 XML Versions</i></a>)</p>
        </li>

        <li>
          <p>Limits on the value space of primitive data types,
          where not fixed by <a href="#xmlschema-2">[XML Schema
          Part 2]</a>, are implementation-defined. (See <a href=
          "#limits"><i>4.6 Limits</i></a>)</p>
        </li>

        <li>
          <p>The implicit timezone for a transformation is
          implementation-defined. (See <a href=
          "#evaluation-context"><i>5.4.3.2 Other components of the
          XPath Dynamic Context</i></a>)</p>
        </li>

        <li>
          <p>If an <code>xml:id</code> attribute that has not been
          subjected to attribute value normalization is copied from
          a source tree to a result tree, it is
          implementation-defined whether attribute value
          normalization will be applied during the copy process.
          (See <a href="#shallow-copy"><i>11.9.1 Shallow
          Copy</i></a>)</p>
        </li>

        <li>
          <p>The numbering sequences supported by the <a href=
          "#element-number"><code>xsl:number</code></a>
          instructions, beyond those defined in this specification,
          are implementation-defined. (See <a href=
          "#convert"><i>12.3 Number to String Conversion
          Attributes</i></a>)</p>
        </li>

        <li>
          <p>There <span class="verb">may</span> be
          implementation-defined upper bounds on the numbers that
          can be formatted by <a href=
          "#element-number"><code>xsl:number</code></a> using any
          particular numbering sequence. (See <a href=
          "#convert"><i>12.3 Number to String Conversion
          Attributes</i></a>)</p>
        </li>

        <li>
          <p>The set of languages for which numbering is supported
          by <a href="#element-number"><code>xsl:number</code></a>,
          and the method of choosing a default language, are
          implementation-defined. (See <a href="#convert"><i>12.3
          Number to String Conversion Attributes</i></a>)</p>
        </li>

        <li>
          <p>If the <code>data-type</code> attribute of the
          <a href="#element-sort"><code>xsl:sort</code></a> element
          has a value other than <code>text</code> or
          <code>number</code>, the effect is
          implementation-defined. (See <a href=
          "#comparing-sort-keys"><i>13.1.2 Comparing Sort Key
          Values</i></a>)</p>
        </li>

        <li>
          <p>The facilities for defining collations and allocating
          URIs to identify them are implementation-defined. (See
          <a href="#collating-sequences"><i>13.1.3 Sorting Using
          Collations</i></a>)</p>
        </li>

        <li>
          <p>The algorithm used by <a href=
          "#element-sort"><code>xsl:sort</code></a> to locate a
          collation, given the values of the <code>lang</code> and
          <code>case-order</code> attributes, is
          implementation-defined. (See <a href=
          "#collating-sequences"><i>13.1.3 Sorting Using
          Collations</i></a>)</p>
        </li>

        <li>
          <p>The set of media types recognized by the processor,
          for the purpose of interpreting fragment identifiers in
          URI references passed to the <a href=
          "#function-document"><code>document</code></a> function,
          is implementation-defined. (See <a href=
          "#document"><i>16.1 Multiple Source
          Documents</i></a>)</p>
        </li>

        <li>
          <p>The set of encodings recognized by the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function, other than <code>utf-8</code> and
          <code>utf-16</code>, is <a title="implementation-defined"
          href=
          "#dt-implementation-defined">implementation-defined</a>.
          (See <a href="#unparsed-text"><i>16.2 Reading Text
          Files</i></a>)</p>
        </li>

        <li>
          <p>If no encoding is specified on a call to the <a href=
          "#function-unparsed-text"><code>unparsed-text</code></a>
          function, the processor <span class="verb">may</span> use
          <a title="implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>
          heuristics to determine the likely encoding. (See
          <a href="#unparsed-text"><i>16.2 Reading Text
          Files</i></a>)</p>
        </li>

        <li>
          <p>The set of languages, calendars, and countries that
          are supported in the <a title="date formatting function"
          href="#dt-date-formatting-function">date formatting
          functions</a> is implementation-defined. If any of these
          arguments is omitted or set to an empty sequence, the
          default is implementation-defined. (See <a href=
          "#lang-cal-country"><i>16.5.2 The Language, Calendar, and
          Country Arguments</i></a>)</p>
        </li>

        <li>
          <p>The choice of the names and abbreviations used in any
          given language for calendar units such as days of the
          week and months of the year is <a title=
          "implementation-defined" href=
          "#dt-implementation-defined">implementation-defined</a>.
          (See <a href="#lang-cal-country"><i>16.5.2 The Language,
          Calendar, and Country Arguments</i></a>)</p>
        </li>

        <li>
          <p>The values returned by the <a href=
          "#function-system-property"><code>system-property</code></a>
          function, and the names of the additional properties that
          are recognized, are implementation-defined. (See <a href=
          "#system-property"><i>16.6.5 system-property</i></a>)</p>
        </li>

        <li>
          <p>The destination and formatting of messages written
          using the <a href=
          "#element-message"><code>xsl:message</code></a>
          instruction are implementation-defined. (See <a href=
          "#message"><i>17 Messages</i></a>)</p>
        </li>

        <li>
          <p>The effect of an extension function returning a string
          containing characters that are not legal in XML is
          implementation-defined. (See <a href=
          "#calling-extension-functions"><i>18.1.2 Calling
          Extension Functions</i></a>)</p>
        </li>

        <li>
          <p>The way in which external objects are represented in
          the type system is implementation-defined. (See <a href=
          "#external-objects"><i>18.1.3 External
          Objects</i></a>)</p>
        </li>

        <li>
          <p>The way in which a final result tree is delivered to
          an application is implementation-defined. (See <a href=
          "#result-trees"><i>19 Final Result Trees</i></a>)</p>
        </li>

        <li>
          <p>Implementations <span class="verb">may</span> provide
          additional mechanisms allowing users to define the way in
          which <a title="final result tree" href=
          "#dt-final-result-tree">final result trees</a> are
          processed. (See <a href="#creating-result-trees"><i>19.1
          Creating Final Result Trees</i></a>)</p>
        </li>

        <li>
          <p>If serialization is supported, then the location to
          which a <a title="final result tree" href=
          "#dt-final-result-tree">final result tree</a> is
          serialized is implementation-defined, subject to the
          constraint that relative URIs used to reference one tree
          from another remain valid. (See <a href=
          "#serialization"><i>20 Serialization</i></a>)</p>
        </li>

        <li>
          <p>The default value of the <code>encoding</code>
          attribute of the <a href=
          "#element-output"><code>xsl:output</code></a> element is
          implementation-defined. (See <a href=
          "#serialization"><i>20 Serialization</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined which versions of XML,
          HTML, and XHTML are supported in the <code>version</code>
          attribute of the <a href=
          "#element-output"><code>xsl:output</code></a>
          declaration. (See <a href="#serialization"><i>20
          Serialization</i></a>)</p>
        </li>

        <li>
          <p>The default value of the <code>byte-order-mark</code>
          serialization parameter is implementation-defined in the
          case of UTF-8 encoding. (See <a href=
          "#serialization"><i>20 Serialization</i></a>)</p>
        </li>

        <li>
          <p>It is implementation-defined whether, and under what
          circumstances, disabling output escaping is supported.
          (See <a href="#disable-output-escaping"><i>20.2 Disabling
          Output Escaping</i></a>)</p>
        </li>
      </ol>
    </div>

    <div class="div1">
      <h2><a name="schema-for-xslt" id="schema-for-xslt"></a>G
      Schema for XSLT Stylesheets (Non-Normative)</h2>

      <p>The following schema describes the structure of an XSLT
      stylesheet module. It does not define all the constraints
      that apply to a stylesheet (for example, it does not attempt
      to define a data type that precisely represents attributes
      containing XPath <a title="expression" href=
      "#dt-expression">expressions</a>). <span>However, every valid
      stylesheet module conforms to this schema, unless it contains
      elements that invoke <a title="forwards-compatible behavior"
      href=
      "#dt-forwards-compatible-behavior">forwards-compatible-behavior</a>.</span></p>

      <p>A copy of this schema is available at <a href=
      "http://www.w3.org/2007/schema-for-xslt20.xsd">http://www.w3.org/2007/schema-for-xslt20.xsd</a></p>
      <pre>
&lt;?xml version="1.0"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
  
    This is a schema for XSLT 2.0 stylesheets.
    
    It defines all the elements that appear in the XSLT namespace; it also
    provides hooks that allow the inclusion of user-defined literal result elements,
    extension instructions, and top-level data elements.
    
    The schema is derived (with kind permission) from a schema for XSLT 1.0 stylesheets
    produced by Asir S Vedamuthu of WebMethods Inc.
    
    This schema is available for use under the conditions of the W3C Software License
    published at http://www.w3.org/Consortium/Legal/copyright-software-19980720
    
    The schema is organized as follows:
    
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
    PART B: definitions of individual XSLT elements
    PART C: definitions for literal result elements
    PART D: definitions of simple types used in attribute definitions
    
    This schema does not attempt to define all the constraints that apply to a valid
    XSLT 2.0 stylesheet module. It is the intention that all valid stylesheet modules 
    should conform to this schema; however, the schema is non-normative and in the event 
    of any conflict, the text of the Recommendation takes precedence.

    This schema does not implement the special rules that apply when a stylesheet
    has sections that use forwards-compatible-mode. In this mode, setting version="3.0"
    allows elements from the XSLT namespace to be used that are not defined in XSLT 2.0.

    Simplified stylesheets (those with a literal result element as the outermost element)
    will validate against this schema only if validation starts in lax mode.
    
    This version is dated 2005-02-11
    Authors: Michael H Kay, Saxonica Limited
             Jeni Tennison, Jeni Tennison Consulting Ltd.
    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
 
&lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;
      
&lt;xs:import namespace="http://www.w3.org/XML/1998/namespace" 
  schemaLocation="http://www.w3.org/2001/xml.xsd"/&gt;

&lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported
--&gt;
  
&lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
                  schemaLocation="http://www.w3.org/2001/XMLSchema.xsd"/&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART A: definitions of complex types and model groups used as the basis 
            for element definitions
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:complexType name="generic-element-type" mixed="true"&gt;
  &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
  &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
  &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
  &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
  &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
  &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="xsl:generic-element-type"&gt;    
      &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="xsl:versioned-element-type"&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:complexType name="sequence-constructor"&gt;
  &lt;xs:complexContent mixed="true"&gt;
    &lt;xs:extension base="xsl:versioned-element-type"&gt;    
      &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:group name="sequence-constructor-group"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="xsl:variable"/&gt;
    &lt;xs:element ref="xsl:instruction"/&gt;
    &lt;xs:group ref="xsl:result-elements"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;

&lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

&lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART B: definitions of individual XSLT elements    
    Elements are listed in alphabetical order.    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
          &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
          &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="regex" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:sort"/&gt;
          &lt;xs:element ref="xsl:with-param"/&gt;
        &lt;/xs:choice&gt;
        &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
        &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="separator" type="xsl:avt"/&gt;   
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;        

&lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:attribute"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames" default=""/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
          &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
        &lt;/xs:sequence&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="comment" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt;
        &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt;
        &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
        &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt;
        &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
        &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt;
        &lt;xs:attribute name="per-mille" type="xsl:char" default="&amp;#x2030;"/&gt;
        &lt;xs:attribute name="zero-digit" type="xsl:char" default="0"/&gt;
        &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
        &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType mixed="true"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
        &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="use-attribute-sets" type="xsl:QNames" default=""/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="required"/&gt;
        &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
        &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;            
        &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;            
        &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;            
        &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;            
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="import"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
        &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;                  
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="match" type="xsl:pattern" use="required"/&gt;
        &lt;xs:attribute name="use" type="xsl:expression"/&gt;
        &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;               
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default" use="required"/&gt;
        &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
          &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;xs:element ref="xsl:fallback"/&gt;
        &lt;/xs:choice&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:attribute name="value" type="xsl:expression"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
        &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
        &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
        &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
        &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;        
        &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
        &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="otherwise" type="xsl:sequence-constructor"/&gt;

&lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="method" type="xsl:method"/&gt;
        &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="cdata-section-elements" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
        &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
        &lt;xs:attribute name="encoding" type="xs:string"/&gt;
        &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="media-type" type="xs:string"/&gt;
        &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
        &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
        &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="output-character"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="character" type="xsl:char" use="required"/&gt;
        &lt;xs:attribute name="string" type="xs:string" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="param"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
        &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
        &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;        
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:avt" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="format" type="xsl:avt"/&gt;
        &lt;xs:attribute name="href" type="xsl:avt"/&gt;
        &lt;xs:attribute name="type" type="xsl:QName"/&gt;
        &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
        &lt;xs:attribute name="method" type="xsl:avt"/&gt;
        &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
        &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
        &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
        &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
        &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
        &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
        &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
        &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
        &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
        &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
        &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
        &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
        &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
        &lt;xs:attribute name="use-character-maps" type="xsl:QNames"/&gt;
        &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="sequence" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="sort"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;  
        &lt;xs:attribute name="lang" type="xsl:avt"/&gt;        
        &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt;        
        &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;        
        &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
        &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
        &lt;xs:attribute name="stable" type="xsl:yes-or-no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="elements" type="xsl:nametests" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

&lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
        &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
        &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
        &lt;xs:attribute name="name" type="xsl:QName"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="text-element-base-type"&gt;
  &lt;xs:simpleContent&gt;
    &lt;xs:restriction base="xsl:versioned-element-type"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:string"/&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:simpleContent&gt;
      &lt;xs:extension base="xsl:text-element-base-type"&gt;
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:simpleContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:complexType name="transform-element-base-type"&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
      &lt;xs:attribute name="version" type="xs:decimal" use="required"/&gt;
      &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;

&lt;xs:element name="transform"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:transform-element-base-type"&gt;
        &lt;xs:sequence&gt;
          &lt;xs:element ref="xsl:import" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:declaration"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;              
            &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;!-- weaker than XSLT 1.0 --&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute name="id" type="xs:ID"/&gt;
        &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt;
        &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type" default="unspecified"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="separator" type="xsl:avt"/&gt;            
        &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="variable"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type" use="optional"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="when"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="test" type="xsl:expression" use="required"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;xs:element name="with-param"&gt;
  &lt;xs:complexType&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="name" type="xsl:QName" use="required"/&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
        &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;   
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
&lt;/xs:element&gt;

&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART C: definition of literal result elements
    
    There are three ways to define the literal result elements
    permissible in a stylesheet.
    
    (a) do nothing. This allows any element to be used as a literal
        result element, provided it is not in the XSLT namespace
    
    (b) declare all permitted literal result elements as members
        of the xsl:literal-result-element substitution group
        
    (c) redefine the model group xsl:result-elements to accommodate
        all permitted literal result elements.
        
    Literal result elements are allowed to take certain attributes
    in the XSLT namespace. These are defined in the attribute group
    literal-result-element-attributes, which can be included in the
    definition of any literal result element.
    
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

&lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
  &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt;
  &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt;
  &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt;
  &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt;    
  &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt;
  &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:QNames" default=""/&gt;
  &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt;
  &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt;
  &lt;xs:attribute name="type" form="qualified" type="xsl:QName"/&gt;
  &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt;
&lt;/xs:attributeGroup&gt;

&lt;xs:group name="result-elements"&gt;
  &lt;xs:choice&gt;
    &lt;xs:element ref="xsl:literal-result-element"/&gt;
    &lt;xs:any namespace="##other" processContents="lax"/&gt;
    &lt;xs:any namespace="##local" processContents="lax"/&gt;
  &lt;/xs:choice&gt;
&lt;/xs:group&gt;


&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
&lt;xs:annotation&gt;
  &lt;xs:documentation&gt;
    PART D: definitions of simple types used in stylesheet attributes 
  &lt;/xs:documentation&gt;
&lt;/xs:annotation&gt;   
&lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

&lt;xs:simpleType name="avt"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      This type is used for all attributes that allow an attribute value template.
      The general rules for the syntax of attribute value templates, and the specific
      rules for each such attribute, are described in the XSLT 2.0 Recommendation.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:string"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="char"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A string containing exactly one character.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:string"&gt;
    &lt;xs:length value="1"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="expression"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      An XPath 2.0 expression.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value=".+"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="input-type-annotations-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes how type annotations in source documents are handled.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;   
    &lt;xs:enumeration value="unspecified"/&gt;        
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="level"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The level attribute of xsl:number: 
      one of single, multiple, or any.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:NCName"&gt;
    &lt;xs:enumeration value="single"/&gt;
    &lt;xs:enumeration value="multiple"/&gt;
    &lt;xs:enumeration value="any"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="mode"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The mode attribute of xsl:apply-templates: 
      either a QName, or #current, or #default.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union memberTypes="xsl:QName"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#default"/&gt;
        &lt;xs:enumeration value="#current"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="modes"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The mode attribute of xsl:template: 
      either a list, each member being either a QName or #default;
      or the value #all
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:union memberTypes="xsl:QName"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="#default"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:union&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:list&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="nametests"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A list of NameTests, as defined in the XPath 2.0 Recommendation.
      Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname"
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:list&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:union memberTypes="xsl:QName"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:enumeration value="*"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction base="xs:token"&gt;
            &lt;xs:pattern value="\i\c*:\*"/&gt;
            &lt;xs:pattern value="\*:\i\c*"/&gt;            
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:union&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:list&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefixes"&gt;
  &lt;xs:list itemType="xs:NCName"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefix-list-or-all"&gt;
  &lt;xs:union memberTypes="xsl:prefix-list"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#all"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;
      
&lt;xs:simpleType name="prefix-list"&gt;
  &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="method"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The method attribute of xsl:output:
      Either one of the recognized names "xml", "xhtml", "html", "text",
      or a QName that must include a prefix.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:NCName"&gt;
        &lt;xs:enumeration value="xml"/&gt;
        &lt;xs:enumeration value="xhtml"/&gt;
        &lt;xs:enumeration value="html"/&gt;
        &lt;xs:enumeration value="text"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xsl:QName"&gt;
        &lt;xs:pattern value="\c*:\c*"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="pattern"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A match pattern as defined in the XSLT 2.0 Recommendation.
      The syntax for patterns is a restricted form of the syntax for
      XPath 2.0 expressions.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xsl:expression"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="prefix-or-default"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Either a namespace prefix, or #default.
      Used in the xsl:namespace-alias element.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:union memberTypes="xs:NCName"&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:token"&gt;
        &lt;xs:enumeration value="#default"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:union&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="QNames"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A list of QNames.
      Used in the [xsl:]use-attribute-sets attribute of various elements,
      and in the cdata-section-elements attribute of xsl:output
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:list itemType="xsl:QName"/&gt;          
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="QName"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      A QName.
      This schema does not use the built-in type xs:QName, but rather defines its own
      QName type. Although xs:QName would define the correct validation on these attributes,
      a schema processor would expand unprefixed QNames incorrectly when constructing the PSVI,
      because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be in
      the default namespace, which is not the correct assumption for XSLT.
      The data type is defined as a restriction of the built-in type Name, restricted
      so that it can only contain one colon which must not be the first or last character.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:Name"&gt;
    &lt;xs:pattern value="([^:]+:)?[^:]+"/&gt;      
  &lt;/xs:restriction&gt;        
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="sequence-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      The description of a data type, conforming to the
      SequenceType production defined in the XPath 2.0 Recommendation
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:pattern value=".+"/&gt;      
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="uri-list"&gt;
  &lt;xs:list itemType="xs:anyURI"/&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="validation-strip-or-preserve"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes different ways of type-annotating an element or attribute.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xsl:validation-type"&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;    
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="validation-type"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      Describes different ways of type-annotating an element or attribute.
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="strict"/&gt;
    &lt;xs:enumeration value="lax"/&gt;
    &lt;xs:enumeration value="preserve"/&gt;
    &lt;xs:enumeration value="strip"/&gt;    
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="yes-or-no"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      One of the values "yes" or "no".
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="yes"/&gt;
    &lt;xs:enumeration value="no"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;xs:simpleType name="yes-or-no-or-omit"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      One of the values "yes" or "no" or "omit".
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:restriction base="xs:token"&gt;
    &lt;xs:enumeration value="yes"/&gt;
    &lt;xs:enumeration value="no"/&gt;
    &lt;xs:enumeration value="omit"/&gt;
  &lt;/xs:restriction&gt;
&lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</pre>
    </div>

    <div class="div1">
      <h2><a name="acknowledgements" id="acknowledgements"></a>H
      Acknowledgements (Non-Normative)</h2>

      <p>This specification was developed and approved for
      publication by the W3C XSL Working Group (WG). WG approval of
      this specification does not necessarily imply that all WG
      members voted for its approval.</p>

      <p>The chair of the XSL WG is Sharon Adler, IBM. The XSL
      Working Group includes two overlapping teams working on XSLT
      and XSL Formatting Objects. The members of the XSL WG
      currently engaged in XSLT activities are:</p>

      <table border="1" cellpadding="5">
        <thead>
          <tr>
            <th>Participant</th>

            <th>Affiliation</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>Colin Paul Adams</td>

            <td>Invited Expert</td>
          </tr>

          <tr>
            <td>Anders Berglund</td>

            <td>IBM</td>
          </tr>

          <tr>
            <td>Scott Boag</td>

            <td>IBM</td>
          </tr>

          <tr>
            <td>Michael Kay</td>

            <td>Invited Expert</td>
          </tr>

          <tr>
            <td>Alex Milowski</td>

            <td>Invited Expert</td>
          </tr>

          <tr>
            <td>William Peterson</td>

            <td>Novell, Inc</td>
          </tr>

          <tr>
            <td>Michael Sperberg-McQueen</td>

            <td>W3C</td>
          </tr>

          <tr>
            <td>Zarella Rendon</td>

            <td>Invited Expert</td>
          </tr>

          <tr>
            <td>Jeni Tennison</td>

            <td>Invited Expert</td>
          </tr>

          <tr>
            <td>Joanne Tong</td>

            <td>IBM</td>
          </tr>

          <tr>
            <td>Norm Walsh</td>

            <td>Sun Microsystems Inc.</td>
          </tr>

          <tr>
            <td>Mohamed Zergaoui</td>

            <td>Innovimax SARL</td>
          </tr>

          <tr>
            <td>(vacancy)</td>

            <td>Oracle</td>
          </tr>
        </tbody>
      </table>

      <p>Alternates are listed only where they have taken an active
      part in working group discussions. However, the group
      acknowledges the support that many members receive from
      colleagues in their organizations, whether or not they are
      officially appointed as alternates.</p>

      <p>The W3C representative on the XSL Working Group is Michael
      Sperberg-McQueen.</p>

      <p>The following individuals made significant contributions
      to XSLT 2.0 while they were members of the Working Group, and
      in some cases afterwards:</p>

      <blockquote>
        <p>James Clark, Invited Expert<br />
        Jonathan Marsh, Microsoft<br />
        Steve Muench, Oracle<br />
        Steve Zilles, Adobe<br />
        Evan Lenz, XYZFind<br />
        Mark Scardina, Oracle<br />
        Kristoffer Rose, IBM<br />
        Henry Zongaro, IBM<br />
        Henry Thompson, University of Edinburgh<br />
        K Karun, Oracle</p>
      </blockquote>

      <p>The working group wishes to acknowledge the contribution
      made by David Marston of IBM especially to the new
      specification of the <a href=
      "#function-format-number"><code>format-number</code></a>
      function.</p>

      <p>This specification builds on the success of the XSLT 1.0
      Recommendation. For a list of contributors to XSLT 1.0, see
      <a href="#xslt">[XSLT 1.0]</a>.</p>
    </div>

    <div class="div1">
      <h2><a name="requirements-checklist" id=
      "requirements-checklist"></a>I Checklist of Requirements
      (Non-Normative)</h2>

      <p>This section provides a checklist of progress against the
      published XSLT 2.0 Requirements document (see <a href=
      "#xslt20req">[XSLT 2.0 Requirements]</a>).</p>

      <p><b><i>Requirement 1</i></b></p>

      <p><span class="verb">must</span>&#160;Maintain Backwards
      Compatibility with XSLT 1.1 [Read this as "with XSLT
      1.0"]</p>

      <p>Any stylesheet whose behavior is fully defined in XSLT 1.0
      and which generates no errors will produce the same result
      tree under XSLT 2.0</p>

      <p><i>Response</i></p>

      <p>See <a href="#incompatibilities"><i>J.1 Incompatible
      Changes</i></a></p>

      <p><b><i>Requirement 2</i></b></p>

      <p><span class="verb">must</span> Match Elements with Null
      Values</p>

      <p>A stylesheet should be able to match elements and
      attributes whose value is explicitly null.</p>

      <p><i>Response</i></p>

      <p>This has been handled as an XPath 2.0 requirement. <span>A
      new function <a href=
      "http://www.w3.org/TR/xpath-functions/#func-nilled"><code>nilled</code></a><sup>
      <small>FO</small></sup> is available to test whether an
      element has been marked as nil after schema
      validation.</span></p>

      <p><b><i>Requirement 3</i></b></p>

      <p><span class="verb">should</span>&#160;Allow Included
      Documents to "Encapsulate" Local Stylesheets</p>

      <p>XSLT 2.0 <span class="verb">should</span> define a
      mechanism to allow the templates in a stylesheet associated
      with a secondary source document, to be imported and used to
      format the included fragment, taking precedence over any
      applicable templates in the current stylesheet.</p>

      <p><i>Response</i></p>

      <p>The facility to define modes has been generalized, making
      it easier to define a distinct set of template rules for
      processing a particular document.</p>

      <p><b><i>Requirement 4</i></b></p>

      <p>Could&#160;Support Accessing Infoset Items for XML
      Declaration</p>

      <p>A stylesheet COULD be able to access information like the
      version and encoding from the XML declaration of a
      document.</p>

      <p><i>Response</i></p>

      <p>No new facilities have been provided in this area, because
      this information is not available in the data model.</p>

      <p><b><i>Requirement 5</i></b></p>

      <p>Could&#160;Provide QName Aware String Functions</p>

      <p>Users manipulating documents (for example stylesheets,
      schemas) that have QName-valued element or attribute content
      need functions that take a string containing a QName as their
      argument, convert it to an <a title="expanded-QName" href=
      "#dt-expanded-qname">expanded-QName</a> using either the
      namespace declarations in scope at that point in the
      stylesheet, or the namespace declarations in scope for a
      specific source node, and return properties of the <a title=
      "expanded-QName" href="#dt-expanded-qname">expanded-QName</a>
      such as its namespace URI and local name.</p>

      <p><i>Response</i></p>

      <p>Functions operating on QNames are included in the XPath
      2.0 Functions and Operators document: see <a href=
      "#xpath-functions">[Functions and Operators]</a>.</p>

      <p><b><i>Requirement 6</i></b></p>

      <p>Could&#160;Enable Constructing a Namespace with Computed
      Name</p>

      <p>Provide an <a href=
      "#element-namespace"><code>xsl:namespace</code></a> analog to
      <a href="#element-element"><code>xsl:element</code></a> for
      constructing a namespace node with a computed prefix and
      URI.</p>

      <p><i>Response</i></p>

      <p>An <a href=
      "#element-namespace"><code>xsl:namespace</code></a>
      instruction has been added: see <a href=
      "#creating-namespace-nodes"><i>11.7 Creating Namespace
      Nodes</i></a>.</p>

      <p><b><i>Requirement 7</i></b></p>

      <p>Could&#160;Simplify Resolving Prefix Conflicts in
      QName-Valued Attributes</p>

      <p>XSLT 2.0 could simplify the renaming of conflicting
      namespace prefixes in result tree fragments, particularly for
      attributes declared in a schema as being QNames. Once the
      processor knows an attribute value is a QName, an XSLT
      processor <span class="verb">should</span> be able to rename
      prefixes and generate namespace declarations to preserve the
      semantics of that attribute value, just as it does for
      attribute names.</p>

      <p><i>Response</i></p>

      <p>If an attribute is typed as a QName in the schema, the new
      XPath 2.0 functions can be used to manipulate it as required
      at application level. This <span>is considered</span>
      sufficient to meet the requirement.</p>

      <p><b><i>Requirement 8</i></b></p>

      <p>Could&#160;Support XHTML Output Method</p>

      <p>Complementing the existing output methods for html, xml,
      and text, an xhtml output method could be provided to
      simplify transformations which target XHTML output.</p>

      <p><i>Response</i></p>

      <p>An XHTML output method is now provided: see <a href=
      "#xslt-xquery-serialization">[XSLT and XQuery
      Serialization]</a></p>

      <p><b><i>Requirement 9</i></b></p>

      <p><span class="verb">must</span>&#160;Allow Matching on
      Default Namespace Without Explicit Prefix</p>

      <p>Many users stumble trying to match an element with a
      default namespace.</p>

      <p><i>Response</i></p>

      <p>A new <code>[xsl:]xpath-default-namespace</code> attribute
      is provided for this purpose: see <a href=
      "#unprefixed-qnames"><i>5.2 Unprefixed QNames in Expressions
      and Patterns</i></a></p>

      <p><b><i>Requirement 10</i></b></p>

      <p><span class="verb">must</span>&#160;Add Date Formatting
      Functions</p>

      <p>One of the more frequent requests from XSLT 1.0 users is
      the ability to format date information with similar control
      to XSLT's format-number. XML Schema introduces several kinds
      of date and time datatypes which will further increase the
      demand for date formatting during transformations.
      Functionality similar to that provided by
      java.text.SimpleDateFormat. A date analog of XSLT's named
      xsl:decimal-format may be required to handle locale-specific
      date formatting issues.</p>

      <p><i>Response</i></p>

      <p>A set of date formatting functions has been specified: see
      <a href="#format-date"><i>16.5 Formatting Dates and
      Times</i></a></p>

      <p><b><i>Requirement 11</i></b></p>

      <p><span class="verb">must</span>&#160;Simplify Accessing
      Id's and Key's in Other Documents</p>

      <p>Currently it is cumbersome to lookup nodes by id() or
      key() in documents other than the source document. Users
      <span class="verb">must</span> first use an xsl:for-each
      instruction, selecting the desired document() to make it the
      current node, then relative XPath expressions within the
      scope of the xsl:for-each can refer to id() or key() as
      desired.</p>

      <p><i>Response</i></p>

      <p>The requirement is met by the generalization of path
      syntax in XPath 2.0. It is now possible to use a path
      expression such as
      <code>document('a.xml')/id('A001')</code>.</p>

      <p><b><i>Requirement 12</i></b></p>

      <p><span class="verb">should</span>&#160;Provide Function to
      Absolutize Relative URIs</p>

      <p>There <span class="verb">should</span> be a way in XSLT
      2.0 to create an absolute URI. The functionality <span class=
      "verb">should</span> allow passing a node-set and return a
      <a title="string value" href="#dt-string-value">string
      value</a> representing the absolute URI resolved with respect
      to the base URI of the current node.</p>

      <p><i>Response</i></p>

      <p>A function <a href=
      "http://www.w3.org/TR/xpath-functions/#func-resolve-uri"><code>
      resolve-uri</code></a><sup><small>FO</small></sup> is now
      defined in <a href="#xpath-functions">[Functions and
      Operators]</a>.</p>

      <p><b><i>Requirement 13</i></b></p>

      <p><span class="verb">should</span>&#160;Include Unparsed
      Text from an External Resource</p>

      <p>Frequently stylesheets <span class="verb">must</span>
      import text from external resources. Today users have to
      resort to <a title="extension function" href=
      "#dt-extension-function">extension functions</a> to
      accomplish this because XSLT 1.0 only provides the document()
      function which, while useful, can only read external
      resources that are well-formed XML documents.</p>

      <p><i>Response</i></p>

      <p>A function <a href=
      "#function-unparsed-text"><code>unparsed-text</code></a> has
      been added: see <a href="#unparsed-text"><i>16.2 Reading Text
      Files</i></a></p>

      <p><b><i>Requirement 14</i></b></p>

      <p><span class="verb">should</span>&#160;Allow Authoring
      Extension Functions in XSLT</p>

      <p>As part of the XSLT 1.1 work done on <a title=
      "extension function" href="#dt-extension-function">extension
      functions</a>, a proposal to author XSLT extension functions
      in XSLT itself was deferred for reconsideration in XSLT 2.0.
      This would allow the functions in an extension namespace to
      be implemented in "pure" XSLT, without resulting to external
      programming languages.</p>

      <p><i>Response</i></p>

      <p>A solution to this requirement, the <a href=
      "#element-function"><code>xsl:function</code></a> element, is
      included in this specification. See <a href=
      "#stylesheet-functions"><i>10.3 Stylesheet
      Functions</i></a>.</p>

      <p><b><i>Requirement 15</i></b></p>

      <p><span class="verb">should</span>&#160;Output Character
      Entity References Instead of Numeric Character Entities</p>

      <p>Users have frequently requested the ability to have the
      output of their transformation use (named) character
      references instead of the numeric character entity. The
      ability to control this preference as the level of the whole
      document is sufficient. For example, rather than seeing
      &amp;#160; in the output, the user could request to see the
      equivalent &amp;nbsp; instead.</p>

      <p><i>Response</i></p>

      <p>The serialization specification gives the implementation
      discretion on how special characters are output. A user who
      wishes to force the use of named character references can
      achieve this using the new <a href=
      "#element-character-map"><code>xsl:character-map</code></a>
      declaration.</p>

      <p><b><i>Requirement 16</i></b></p>

      <p><span class="verb">should</span>&#160;Construct Entity
      Reference by Name</p>

      <p>Analogous to the ability to create elements and
      attributes, users have expressed a desire to construct named
      entity references.</p>

      <p><i>Response</i></p>

      <p>No solution has been provided to this requirement; it is
      difficult, because entity references are not defined in the
      data model.</p>

      <p><b><i>Requirement 17</i></b></p>

      <p><span class="verb">should</span>&#160;Support for Unicode
      String Normalization</p>

      <p>For reliable string comparison of Unicode strings, users
      need the ability to apply Unicode normalization before
      comparing the strings.</p>

      <p><i>Response</i></p>

      <p>This requirement has been addressed by the provision of
      the <a href=
      "http://www.w3.org/TR/xpath-functions/#func-normalize-unicode">
      <code>normalize-unicode</code></a><sup><small>FO</small></sup>
      function described in <a href="#xpath-functions">[Functions
      and Operators]</a>. In addition, a serialization parameter
      <code>normalization-form</code> has been added.</p>

      <p><b><i>Requirement 18</i></b></p>

      <p><span class="verb">should</span>&#160;Standardize
      Extension Element Language Bindings</p>

      <p>XSLT 1.1 undertook the standardization of language
      bindings for XSLT <a title="extension function" href=
      "#dt-extension-function">extension functions</a>. For XSLT
      2.0, analogous bindings <span class="verb">should</span> be
      provided for extension elements [now renamed <a title=
      "extension instruction" href=
      "#dt-extension-instruction">extension instructions</a>].</p>

      <p><i>Response</i></p>

      <p>The XSL Working Group has decided not to pursue this
      requirement, and the attempt to standardize language bindings
      for extension functions that appeared in the XSLT 1.1 Working
      Draft has now been withdrawn. The Working Group decided that
      language bindings would be better published separately from
      the core XSLT specification.</p>

      <p><b><i>Requirement 19</i></b></p>

      <p>Could&#160;Improve Efficiency of Transformations on Large
      Documents</p>

      <p>Many useful transformations take place on large documents
      consisting of thousands of repeating "sub-documents". Today
      transformations over these documents are impractical due to
      the need to have the entire source tree in memory. Enabling
      "progressive" transformations, where the processor is able to
      produce progressively more output as more input is received,
      is tantamount to avoiding the need for XSLT processors to
      have random access to the entire source document. This might
      be accomplished by:</p>

      <p>Identifying a core subset of XPath that does not require
      random access to the source tree, or</p>

      <p>Consider a "transform all subtrees" mode where the
      stylesheet says, "Apply the transformation implied by this
      stylesheet to each node that matches XXX, considered as the
      root of a separate tree, and copy all the results of these
      mini-transformations as separate subtrees on to the final
      result tree."</p>

      <p><i>Response</i></p>

      <p>The Working Group observes that implementation techniques
      for XSLT processing have advanced considerably since this
      requirement was written, and that further research developing
      new approaches continues both in industry and academia. In
      the light of these developments, the Working Group has
      decided that it would be inappropriate at this stage to
      identify language features or subsets designed specifically
      to enable progressive transformations.</p>

      <p><b><i>Requirement 20</i></b></p>

      <p>Could&#160;Support Reverse IDREF attributes</p>

      <p>Given a particular value of an ID, produce a list of all
      elements that have an IDREF or IDREFS attribute which refers
      to this ID.</p>

      <p>This functionality can be accomplished using the current
      &lt;xsl:key&gt; and key() mechanism.</p>

      <p><i>Response</i></p>

      <p>The <a href=
      "http://www.w3.org/TR/xpath-functions/#func-idref"><code>idref</code></a><sup>
      <small>FO</small></sup> function defined in <a href=
      "#xpath-functions">[Functions and Operators]</a> has been
      introduced in response to this requirement.</p>

      <p><b><i>Requirement 21</i></b></p>

      <p>Could&#160;Support Case-Insensitive Comparisons</p>

      <p>XSLT 2.0 could expand its comparison functionality to
      include support for case-insensitive string comparison.</p>

      <p><i>Response</i></p>

      <p>This is an XPath 2.0 requirement. XPath 2.0 includes
      functions to convert strings to uppercase or lowercase, it
      also includes functions to compare strings using a named
      collating sequence, which provides the option of using a
      collating sequence that treats uppercase and lowercase as
      equal.</p>

      <p><b><i>Requirement 22</i></b></p>

      <p>Could&#160;Support Lexigraphic String Comparisons</p>

      <p>We don't let users compare strings like $x &gt; 'a'.</p>

      <p><i>Response</i></p>

      <p>This requirement has been addressed in XPath 2.0.</p>

      <p><b><i>Requirement 23</i></b></p>

      <p>Could&#160;Allow Comparing Nodes Based on Document
      Order</p>

      <p>Support the ability to test whether one node comes before
      another in document order.</p>

      <p><i>Response</i></p>

      <p>This requirement has been addressed in XPath 2.0, using
      the operators <code>&lt;&lt;</code> and
      <code>&gt;&gt;</code>.</p>

      <p><b><i>Requirement 24</i></b></p>

      <p>Could&#160;Improve Support for Unparsed Entities</p>

      <p>In XSLT 1.0 there is an asymmetry in support for unparsed
      entities. They can be handled on input but not on output. In
      particular, there is no way to do an identity transformation
      that preserves them. At a minimum we need the ability to
      retrieve the Public ID of an unparsed entity.</p>

      <p><i>Response</i></p>

      <p>A function to retrieve the public identifier of an
      unparsed entity has been added. However, no facilities have
      been provided to include unparsed entities in a result
      document.</p>

      <p><b><i>Requirement 25</i></b></p>

      <p>Could&#160;Allow Processing a Node with the "Next Best
      Matching" Template</p>

      <p>In the construction of large stylesheets for complex
      documents, it is often necessary to construct templates that
      implement special behavior for a particular instance of an
      element, and then apply the normal styling for that element.
      Currently this is not possible because <a href=
      "#element-apply-templates"><code>xsl:apply-templates</code></a>
      specifies that for any given node only a single template will
      be selected and instantiated.</p>

      <p>Currently the processor determines a list of matching
      templates and then discards all but the one with the highest
      priority. In order to support this requirement, the processor
      would retain the list of matching templates sorted in
      priority order. A new instruction, for example <a href=
      "#element-next-match"><code>xsl:next-match</code></a>, in a
      template would simply trigger the next template in the list
      of matching templates. This "next best match" recursion
      naturally bottoms out at the builtin template which can be
      seen as the lowest priority matching template for every match
      pattern.</p>

      <p><i>Response</i></p>

      <p>An <a href=
      "#element-next-match"><code>xsl:next-match</code></a>
      instruction has been added.</p>

      <p><b><i>Requirement 26</i></b></p>

      <p>Could&#160;Make Coercions Symmetric By Allowing Scalar to
      Nodeset Conversion</p>

      <p>Presently, no datatype can be coerced or cast to a
      node-set. By allowing a <a title="string value" href=
      "#dt-string-value">string value</a> to convert to a node-set,
      some user "gotchas" could be avoided.</p>

      <p><i>Response</i></p>

      <p>The availability of sequences of strings or numbers
      probably meets most of the use-cases envisaged by this
      requirement.</p>

      <p><b><i>Requirement 27</i></b></p>

      <p><span class="verb">must</span>&#160;Simplify Constructing
      and Copying Typed Content</p>

      <p>It <span class="verb">must</span> be possible to construct
      XML Schema-typed elements and attributes. In addition, when
      copying an element or an attribute to the result, it
      <span class="verb">should</span> be possible to preserve the
      type during the process.</p>

      <p><i>Response</i></p>

      <p>Facilities to validate constructed and copied element and
      attribute nodes are defined in this specification; these
      elements and attributes will carry a type annotation
      indicating their XML Schema type. In addition, it is possible
      to specify when copying nodes whether type annotations should
      be preserved or removed.</p>

      <p><b><i>Requirement 28</i></b></p>

      <p><span class="verb">must</span>&#160;Support Sorting Nodes
      Based on XML Schema Type</p>

      <p>XSLT 1.0 supports sorting based on string-valued and
      number-valued expressions. XML Schema: Datatypes introduces
      new scalar types (for example, date) with well-known sort
      orders. It <span class="verb">must</span> be possible to sort
      based on these extended set of scalar data types. Since XML
      Schema: Datatypes does not define an ordering for complex
      types, this sorting support <span class="verb">should</span>
      only be considered for simple types.</p>

      <p><span class="verb">should</span> be consistent with
      whatever we define for the matrix of conversion and
      comparisons.</p>

      <p><i>Response</i></p>

      <p>Sorting based on any schema-defined primitive data type
      with a total ordering is included in this specification.</p>

      <p><b><i>Requirement 29</i></b></p>

      <p>Could&#160;Support Scientific Notation in Number
      Formatting</p>

      <p>Several users have requested the ability to have the
      existing format-number() function extended to format numbers
      using Scientific Notation.</p>

      <p><i>Response</i></p>

      <p>Simple scientific formatting is now available through
      support for the schema-defined <code>xs:float</code> and
      <code>xs:double</code> data types; casting a large or small
      value of these types to a string produces a representation of
      the value in scientific notation. The Working Group believes
      that this will meet the requirement in most cases, and has
      therefore decided not to enhance the <a href=
      "#function-format-number"><code>format-number</code></a>
      further to introduce scientific notation. Users with more
      specialized requirements can write their own functions.</p>

      <p><b><i>Requirement 30</i></b></p>

      <p>Could&#160;Provide Ability to Detect Whether "Rich" Schema
      Information is Available</p>

      <p>A stylesheet that requires XML Schema type-related
      functionality could be able to test whether a "rich"
      Post-Schema-Validated Infoset is available from the XML
      Schema processor, so that the stylesheet can provide fallback
      behavior or choose to exit with <code>xsl:message
      abort="yes"</code>.</p>

      <p><i>Response</i></p>

      <p>This requirement is satisified through the <code>instance
      of</code> operator in XPath 2.0, which allows expressions to
      determine the type of element and attribute nodes, using
      information from the schema. The details of how these
      expressions behave when there is no schema are defined in the
      XPath specifications.</p>

      <p><b><i>Requirement 31</i></b></p>

      <p><span class="verb">must</span>&#160;Simplify Grouping</p>

      <p>Grouping is complicated in XSLT 1.0. It <span class=
      "verb">must</span> be possible for users to group nodes in a
      document based on common string-values, common names, or
      common values for any other expression</p>

      <p>In addition XSLT <span class="verb">must</span> allow
      grouping based on sequential position, for example selecting
      groups of adjacent &lt;P&gt; elements. Ideally it
      <span class="verb">should</span> also make it easier to do
      fixed-size grouping as well, for example groups of three
      adjacent nodes, for laying out data in multiple columns. For
      each group of nodes identified, it <span class=
      "verb">must</span> be possible to instantiate a template for
      the group. Grouping <span class="verb">must</span> be
      "nestable" to multiple levels so that groups of distinct
      nodes can be identified, then from among the distinct groups
      selected, further sub-grouping of distinct node in the
      current group can be done.</p>

      <p><i>Response</i></p>

      <p>A new <a href=
      "#element-for-each-group"><code>xsl:for-each-group</code></a>
      instruction is provided: see <a href="#grouping"><i>14
      Grouping</i></a>. In addition, many of the new functions and
      operators provided in XPath 2.0 make these algorithms easier
      to write.</p>
    </div>

    <div class="div1">
      <h2><a name="changes" id="changes"></a>J Changes from XSLT
      1.0 (Non-Normative)</h2>

      <div class="div2">
        <h3><a name="incompatibilities" id=
        "incompatibilities"></a>J.1 Incompatible Changes</h3>

        <p>This section lists all known cases where a stylesheet
        that was valid (produced no errors) under XSLT 1.0, and
        whose behavior was fully specified by XSLT 1.0, will
        produce different results under XSLT 2.0.</p>

        <p>Most of the discussion is concerned with compatibility
        in the absence of a schema: that is, it is assumed that the
        source document being transformed has no schema when
        processed using XSLT 1.0, and that no schema is added when
        moving to XSLT 2.0. Some additional factors that come into
        play when a schema is added are noted at the end of the
        section.</p>

        <div class="div3">
          <h4><a name="incompatibility-stripping" id=
          "incompatibility-stripping"></a>J.1.1 Tree construction:
          whitespace stripping</h4>

          <p>Both in XSLT 1.0 and in XSLT 2.0, the XSLT
          specification places no constraints on the way in which
          source trees are constructed. For XSLT 2.0, however, the
          <a href="#xpath-datamodel">[Data Model]</a> specification
          describes explicit processes for constructing a tree from
          an Infoset or a PSVI, while also permitting other
          processes to be used. The process described in <a href=
          "#xpath-datamodel">[Data Model]</a> has the effect of
          stripping <a title="whitespace text node" href=
          "#dt-whitespace-text-node">whitespace text nodes</a> from
          elements declared to have element-only content. Although
          the XSLT 1.0 specification did not preclude such
          behavior, it differs from the way that most existing XSLT
          1.0 implementations work. It is <span class=
          "verb">recommended</span> that an XSLT 2.0 implementation
          wishing to provide maximum interoperability and backwards
          compatibility should offer the user the option either to
          construct source trees using the processes described in
          <a href="#xpath-datamodel">[Data Model]</a>, or
          alternatively to retain or remove whitespace according to
          the common practice of previous XSLT 1.0
          implementations.</p>

          <p>To write transformations that give the same result
          regardless of the whitespace stripping applied during
          tree construction, stylesheet authors can:</p>

          <ul>
            <li>
              <p>use the <a href=
              "#element-strip-space"><code>xsl:strip-space</code></a>
              declaration to remove <a title="whitespace text node"
              href="#dt-whitespace-text-node">whitespace text
              nodes</a> from elements having element-only content
              (this has no effect if the whitespace has already
              been stripped)</p>
            </li>

            <li>
              <p>use instructions such as
              <code>&lt;xsl:apply-templates select="*"/&gt;</code>
              that cause only the element children of the context
              node to be processed, and not its text nodes.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="incompatibility-serialization" id=
          "incompatibility-serialization"></a>J.1.2 Changes in
          Serialization Behavior</h4>

          <p>The specification of the output of <a title=
          "serialization" href=
          "#dt-serialization">serialization</a> is more
          prescriptive than in XSLT 1.0. For example, the
          <code>html</code> output method is <span class=
          "verb">required</span> to detect invalid HTML characters.
          Also, certain combinations of serialization parameters
          are now defined to be errors. Furthermore, XSLT 1.0
          implementations were allowed to add additional <a href=
          "#element-output"><code>xsl:output</code></a> attributes
          that modified the behavior of the serializer. Some such
          extensions might be non-conformant under the stricter
          rules of XSLT 2.0. For example, some XSLT 1.0 processors
          provided an extension attribute to switch off the
          creation of <code>meta</code> elements by the
          <code>html</code> output method (a facility that is now
          provided as standard). A conformant XSLT 2.0 processor is
          not allowed to provide such extensions.</p>

          <p>Where necessary, implementations <span class=
          "verb">may</span> provide additional serialization
          methods designed to mimic more closely the behavior of
          specific XSLT 1.0 serializers.</p>
        </div>

        <div class="div3">
          <h4><a name="backwards-compatibility-behavior" id=
          "backwards-compatibility-behavior"></a>J.1.3 Backwards
          Compatibility Behavior</h4>

          <p>Some XSLT constructs behave differently under XSLT 2.0
          depending on whether <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled. In these cases, the behavior may
          be made compatible with XSLT 1.0 by ensuring that
          <a title="backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled (which is done using the
          <code>[xsl:]version</code> attribute).</p>

          <p>These constructs are as follows:</p>

          <ol class="enumar">
            <li>
              <p>If the <a href=
              "#element-value-of"><code>xsl:value-of</code></a>
              instruction has no <code>separator</code> attribute,
              and the value of the <code>select</code> expression
              is a sequence of more than one item, then under XSLT
              2.0 all items in the sequence will be output, space
              separated, while in XSLT 1.0, all items after the
              first will be discarded.</p>
            </li>

            <li>
              <p>If the <a title="effective value" href=
              "#dt-effective-value">effective value</a> of an
              <a title="attribute value template" href=
              "#dt-attribute-value-template">attribute value
              template</a> is a sequence of more than one item,
              then under XSLT 2.0 all items in the sequence will be
              output, space separated, while in XSLT 1.0, all items
              after the first will be discarded.</p>
            </li>

            <li>
              <p>If the expression in the <code>value</code>
              attribute of the <a href=
              "#element-number"><code>xsl:number</code></a>
              instruction returns a sequence of more than one item,
              then under XSLT 2.0 all items in the sequence will be
              output, as defined by the <code>format</code>
              attribute, but under XSLT 1.0, all items after the
              first will be discarded. If the sequence is empty,
              then under XSLT 2.0 nothing will be output (other
              than a prefix and suffix if requested), but under
              XSLT 1.0, the output is "NaN". If the first item in
              the sequence cannot be converted to a number, then
              XSLT 2.0 signals a non-recoverable error, while XSLT
              1.0 outputs "NaN".</p>

              <p>If the expression in the <code>value</code>
              attribute of <a href=
              "#element-number"><code>xsl:number</code></a> returns
              an empty sequence or a sequence including non-numeric
              values, an XSLT 2.0 processor may signal a
              recoverable error; but with backwards compatibility
              enabled, it outputs <code>NaN</code>.</p>
            </li>

            <li>
              <p>If the <a title="atomize" href=
              "#dt-atomization">atomized</a> value of the
              <code>select</code> attribute of the <a href=
              "#element-sort"><code>xsl:sort</code></a> element is
              a sequence of more than one item, then under XSLT 2.0
              an error will be signaled, while in XSLT 1.0, all
              items after the first will be discarded.</p>
            </li>

            <li>
              <p>If an <a href=
              "#element-call-template"><code>xsl:call-template</code></a>
              instruction supplies a parameter that does not
              correspond to any <a title="template parameter" href=
              "#dt-template-parameter">template parameter</a> in
              the template being called, then under XSLT 2.0 a
              <a title="static error" href=
              "#dt-static-error">static error</a> is signaled, but
              under XSLT 1.0 the extra parameter is ignored.</p>
            </li>

            <li>
              <p>It is normally a <a title="static error" href=
              "#dt-static-error">static error</a> if an XPath
              expression contains a call to an unknown function.
              But when backwards compatible behavior is enabled,
              this is a <a title="non-recoverable dynamic error"
              href="#dt-nonrec-dynamic-error">non-recoverable
              dynamic error</a>, which occurs only if the function
              call is actually evaluated.</p>
            </li>

            <li>
              <p>An XSLT 1.0 processor compared the value of the
              expression in the <code>use</code> attribute of
              <a href="#element-key"><code>xsl:key</code></a> to
              the value supplied in the second argument of the
              <a href="#function-key"><code>key</code></a> function
              by converting both to strings. An XSLT 2.0 processor
              normally compares the values as supplied. The XSLT
              1.0 behavior is retained if any of the <a href=
              "#element-key"><code>xsl:key</code></a> elements
              making up the <a title="key" href="#dt-key">key</a>
              definition enables backwards-compatible behavior.</p>
            </li>

            <li>
              <p>If no output method is explicitly requested, and
              the first element node output appears to be an XHTML
              document element, then under XSLT 2.0 the output
              method defaults to XHTML; with backwards
              compatibility enabled, the XML output method will be
              used.</p>
            </li>
          </ol>

          <p>Backwards compatible behavior also affects the results
          of certain XPath expressions, as defined in <a href=
          "#xpath20">[XPath 2.0]</a>.</p>
        </div>

        <div class="div3">
          <h4><a name="incompatibility-without-schema" id=
          "incompatibility-without-schema"></a>J.1.4
          Incompatibility in the Absence of a Schema</h4>

          <p>If the source documents supplied as input to a
          transformation contain no type information generated from
          a schema then the known areas of incompatibility are as
          follows. These apply whether or not <a title=
          "backwards compatible behavior" href=
          "#dt-backwards-compatible-behavior">backwards compatible
          behavior</a> is enabled.</p>

          <ol class="enumar">
            <li>
              <p>A stylesheet that specifies a version number other
              than 1.0 was defined in XSLT 1.0 to execute in
              forwards-compatible mode; if such a stylesheet uses
              features that are not defined in XSLT 2.0 then errors
              may be signaled by an XSLT 2.0 processor that would
              not be signaled by an XSLT 1.0 processor.</p>
            </li>

            <li>
              <p>At XSLT 1.0 the <a href=
              "#function-system-property"><code>system-property</code></a>
              function, when called with a first argument of
              <code>"xsl:version"</code>, returned 1.0 as a number.
              At XSLT 2.0 it returns "2.0" as a string. The
              <span class="verb">recommended</span> way of testing
              this property is, for example, <code>&lt;xsl:if
              test="number(system-property('xsl:version')) &amp;lt;
              2.0"&gt;</code>, which will work with either an XSLT
              1.0 or an XSLT 2.0 processor.</p>
            </li>

            <li>
              <p>At XSLT 2.0 it is an error to specify the
              <code>mode</code> or <code>priority</code> attribute
              on an <a href=
              "#element-template"><code>xsl:template</code></a>
              element having no <code>match</code> attribute. At
              XSLT 1.0 the attributes were silently ignored in this
              situation.</p>
            </li>

            <li>
              <p>When an <a href=
              "#element-apply-templates"><code>xsl:apply-templates</code></a>
              or <a href=
              "#element-apply-imports"><code>xsl:apply-imports</code></a>
              instruction causes a built-in template rule to be
              invoked, then any parameters that are supplied are
              automatically passed on to any further template
              rules. This did not happen in XSLT 1.0.</p>
            </li>

            <li>
              <p>In XSLT 1.0 it was a recoverable error to create
              any node other than a text node while constructing
              the value of an attribute, comment, or
              processing-instruction; the recovery action was to
              ignore the offending node and its content. In XSLT
              2.0 this is no longer an error, and the specified
              action is to atomize the node. An XSLT 2.0 processor
              will therefore not produce the same results as an
              XSLT 1.0 processor that took the error recovery
              action.</p>
            </li>

            <li>
              <p>XSLT 1.0 defined a number of recoverable error
              conditions which in XSLT 2.0 have become
              non-recoverable errors. Under XSLT 1.0, a stylesheet
              that triggered such errors would fail under some XSLT
              processors and succeed (or at any rate, continue to
              completion) under others. Under XSLT 2.0 such a
              stylesheet will fail under all processors. Notable
              examples of such errors are constructing an element
              or attribute with an invalid name, generating
              attributes as children of a document node, and
              generating an attribute of an element after
              generating one or more children for the element. This
              change has been made in the interests of
              interoperability. In classifying such errors as
              non-recoverable, the Working Group used the criterion
              that no stylesheet author would be likely to write
              code that deliberately triggered the error and relied
              on the recovery action.</p>
            </li>

            <li>
              <p>In XSLT 1.0, the semantics of tree construction
              were described as being top-down, in XSLT 2.0 they
              are described bottom up. In nearly all cases the end
              result is the same. One difference arises in the case
              of a tree that is constructed to contain an attribute
              node within a document node within an element node,
              using an instruction such as the following:</p>

              <div class="example">
                <div class="exampleHeader">
                  <a name="d5e31247" id="d5e31247"></a>Example:
                  Attribute within Document within Element
                </div>

                <div class="exampleInner">
                  <pre>
&lt;xsl:template match="/"&gt;
  &lt;e&gt;
    &lt;xsl:copy&gt;
      &lt;xsl:attribute name="a"&gt;5&lt;/xsl:attribute&gt;
    &lt;/xsl:copy&gt;
  &lt;/e&gt;
&lt;/xsl:template&gt;
</pre>
                </div>
              </div>

              <p>In XSLT 1.0, the <a href=
              "#element-copy"><code>xsl:copy</code></a> did
              nothing, and the attribute <code>a</code> was then
              attached to the element <code>e</code>. In XSLT 2.0,
              an error occurs when attaching the attribute
              <code>a</code> to the document node constructed by
              <a href="#element-copy"><code>xsl:copy</code></a>,
              because this happens before the resulting document
              node is copied to the content of the constructed
              element.</p>
            </li>

            <li>
              <p>In XSLT 1.0 it was not an error for the
              <code>namespace</code> attribute of <a href=
              "#element-element"><code>xsl:element</code></a> or
              <a href=
              "#element-attribute"><code>xsl:attribute</code></a>
              to evaluate to an invalid URI. Since many XML parsers
              accept any string as a namespace name, this rarely
              caused problems. The <a href="#xpath-datamodel">[Data
              Model]</a>, however, requires the name of a node to
              be an <code>xs:QName</code>, and the namespace part
              of an <code>xs:QName</code> is always an
              <code>xs:anyURI</code>. It is therefore now defined
              to be an error to create an element or attribute node
              in a namespace whose name is not a valid instance of
              <code>xs:anyURI</code>. <span>In practice, however,
              implementations have some flexibility in how
              rigorously they validate namespace URIs.</span></p>
            </li>

            <li>
              <p>It is now a static error for the stylesheet to
              contain two conflicting <a href=
              "#element-namespace-alias"><code>xsl:namespace-alias</code></a>
              declarations with the same import precedence.</p>
            </li>

            <li>
              <p>It is now a static error for an <a href=
              "#element-number"><code>xsl:number</code></a>
              instruction to contain both a <code>value</code>
              attribute and a <code>level</code>,
              <code>from</code>, or <code>count</code> attribute.
              In XSLT 1.0 the <code>value</code> attribute took
              precedence and the other attributes were silently
              ignored.</p>
            </li>

            <li>
              <p>When the <code>data-type</code> attribute of
              <a href="#element-sort"><code>xsl:sort</code></a> has
              the value <code>number</code>, an XSLT 1.0 processor
              would evaluate the sort key as a string, and convert
              the result to a number. An XSLT 2.0 processor
              evaluates the sort key as a number directly. This
              only affects the outcome in cases where <span>in XSLT
              1.0,</span> conversion of a number to a string and
              then back to a number does not produce the original
              number, as is the case for example with the number
              <span>positive infinity</span>.</p>
            </li>

            <li>
              <p>When the <code>data-type</code> attribute of
              <a href="#element-sort"><code>xsl:sort</code></a> is
              omitted, an XSLT 1.0 processor would convert the sort
              key values to strings, and sort them as strings. An
              XSLT 2.0 processor will sort them according to their
              actual dynamic type. This means, for example, that if
              the sort key component specifies <code>&lt;xsl:sort
              select="string-length(.)"/&gt;</code>, an XSLT 2.0
              processor will do a numeric sort where an XSLT 1.0
              processor would have done an alphabetic sort.</p>
            </li>

            <li>
              <p>When the <code>data-type</code> attribute of
              <a href="#element-sort"><code>xsl:sort</code></a> is
              omitted or has the value "text", an XSLT 1.0
              processor treats a sort key whose value is an empty
              node-set as being equal to a sort key whose value is
              a zero-length string. XSLT 2.0 sorts the empty
              sequence before the zero-length string. This means
              that if there are two sort keys, say
              <code>&lt;xsl:sort select="@a"/&gt;</code> and
              <code>&lt;xsl:sort select="@b"/&gt;</code>, then an
              XSLT 1.0 processor will sort the element <code>&lt;x
              b="2"/&gt;</code> after <code>&lt;x a=""
              b="1"/&gt;</code>, while an XSLT 2.0 processor will
              produce the opposite ordering.</p>
            </li>

            <li>
              <p>The specification of the <a href=
              "#function-format-number"><code>format-number</code></a>
              function has been rewritten to remove the normative
              dependency on the Java JDK 1.1 specification. The JDK
              1.1 specification left aspects of the behavior
              undefined; it is therefore likely that some cases
              will give different results.</p>

              <p>The ability to include literal text in the format
              picture enclosed in single quotes has been removed;
              any stylesheet that uses this feature will need to be
              modified, for example to display the literal text
              using the <a href=
              "http://www.w3.org/TR/xpath-functions/#func-concat"><code>
              concat</code></a><sup><small>FO</small></sup>
              function instead.</p>

              <p>One specific difference between the XSLT 2.0
              specification and a JDK-based implementation is in
              the handling of the negative sub-picture. JDK
              releases subsequent to JDK 1.1 have added the
              provision: <em>If there is an explicit negative
              subpattern [sub-picture], it serves only to specify
              the negative prefix and suffix; the number of digits,
              minimal digits, and other characteristics are all the
              same as the positive pattern [sub-picture].</em> This
              statement was not present in the JDK 1.1
              specification, and therefore it is not necessarily
              how every XSLT 1.0 implementation will behave, but it
              does describe the behavior of some XSLT 1.0
              implementations that use the JDK directly. This
              behavior is not correct in XSLT 2.0: the negative
              sub-picture <span class="verb">must</span> be used as
              written when the number is negative.</p>
            </li>

            <li>
              <p>The recovery action has changed for the error
              condition where the processor cannot handle the
              fragment identifier in a URI passed as an argument to
              the <a href=
              "#function-document"><code>document</code></a>
              function. XSLT 1.0 specified that the entire URI
              reference should be ignored. XSLT 2.0 specifies that
              the fragment identifier should be ignored.</p>
            </li>

            <li>
              <p>XSLT 1.0 allowed the URI returned by the <a href=
              "#function-unparsed-entity-uri"><code>unparsed-entity-uri</code></a>
              function to be derived from some combination of the
              system identifier and the public identifier in the
              source XML. XSLT 2.0 returns the system identifier as
              defined in the Infoset, resolved using the base URI
              of the source document. A new function is provided to
              return the public identifier.</p>
            </li>

            <li>
              <p>The default priority of the pattern
              <code>match="/"</code> has changed from +0.5 to -0.5.
              The effect of this is that if there are any template
              rules that specify <code>match="/"</code> with an
              explicit user-specified priority between -0.5 and
              +0.5, these will now be chosen in preference to a
              template rule that specifies <code>match="/"</code>
              with no explicit priority; previously such rules
              would never have been invoked.</p>
            </li>

            <li>
              <p>In XSLT 1.0 it was possible to create a processing
              instruction in the result tree whose string value
              contained a leading space. However, such leading
              spaces would be lost after serialization and parsing.
              In XSLT 2.0, any leading spaces in the string value
              of the processing instruction are removed at the time
              the node is created.</p>
            </li>

            <li>
              <p>At XSLT 1.0 there were no restrictions on the
              namespaces that could be used for the names of
              user-defined stylesheet objects such as keys,
              variables, and named templates. In XSLT 2.0, certain
              namespaces (for example the XSLT namespace and the
              XML Schema namespace) are reserved.</p>
            </li>

            <li>
              <p>An erratum to XSLT 1.0 specified what has become
              known as "sticky disable-output-escaping":
              specifically, that it should be possible to use
              <code>disable-output-escaping</code> when writing a
              node to a temporary tree, and that this information
              would be retained for use when the same node was
              later copied to a final result tree and serialized.
              XSLT 2.0 no longer specifies this behavior (though it
              permits it, at the discretion of the implementation).
              The use cases for this facility have been satisfied
              by a completely different mechanism, the concept of
              character maps (see <a href="#character-maps"><i>20.1
              Character Maps</i></a>).</p>
            </li>
          </ol>
        </div>

        <div class="div3">
          <h4><a name="compatibility-with-schema" id=
          "compatibility-with-schema"></a>J.1.5 Compatibility in
          the Presence of a Schema</h4>

          <p>An XSLT 1.0 processor ignored all information about
          data types that might be obtained from a schema
          associated with a source document. An XSLT 2.0 processor
          will take account of such information, <span>unless the
          <code>input-type-annotations</code> attribute is set to
          <code>strip</code></span>. This may lead to a number of
          differences in behavior. This section attempts only to
          give some examples of the kind of differences that might
          be expected when schema information is made
          available:</p>

          <ul>
            <li>
              <p>Operations such as sorting will be sensitive to
              the data type of the items being sorted. For example,
              if the data type of a sort key component is defined
              in the schema as a date, then in the absence of a
              <code>data-type</code> attribute on the <a href=
              "#element-sort"><code>xsl:sort</code></a> element,
              the sequence will be sorted in date order. With XSLT
              1.0, the dates would be compared and sorted as
              strings.</p>
            </li>

            <li>
              <p>Certain operations that are permitted on untyped
              data are not permitted on typed data, if the type of
              the data is inappropriate for the operation.
              <span>For example, the <a href=
              "http://www.w3.org/TR/xpath-functions/#func-substring">
              <code>substring</code></a><sup><small>FO</small></sup>
              function expects its first argument to be a
              string</span>. It is acceptable to supply an untyped
              value, which will be automatically converted to a
              string, but it is not acceptable to supply a value
              which has been annotated (as a result of schema
              processing) as an integer or a date.</p>
            </li>

            <li>
              <p>When an attribute value such as <code>colors="red
              green blue"</code> is processed without a schema, the
              value is considered to be a single string. When
              schema validation is applied, assuming the type is a
              list type like <code>xs:NMTOKENS</code>, the value
              will be treated as a sequence of three strings. This
              affects the results of many operations, for example
              comparison of the value with another string.
              <span>With this attribute value, the expression
              <code>contains(@colors, "green")</code> returns true
              in XPath 1.0 and also in XPath 2.0 if
              <code>input-type-annotations</code> is set to
              <code>strip</code>. In XPath 2.0, with a schema-aware
              processor and with
              <code>input-type-annotations</code> set to
              <code>preserve</code>, the same expression returns
              false with backwards-compatibility enabled, and
              raises an error with backwards compatibility
              disabled.</span></p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="xpath-compatibility" id=
          "xpath-compatibility"></a>J.1.6 XPath 2.0 Backwards
          Compatibility</h4>

          <p>Information about incompatibilities between XPath 2.0
          and XPath 1.0 is included in <a href="#xpath20">[XPath
          2.0]</a></p>

          <p>Incompatibilities in the specification of individual
          functions in the <a title="core function" href=
          "#dt-core-function">core function</a> library are listed
          in <a href="#xpath-functions">[Functions and
          Operators]</a></p>
        </div>
      </div>

      <div class="div2">
        <h3><a name="changes-since-1.0" id=
        "changes-since-1.0"></a>J.2 New Functionality</h3>

        <p>This section summarizes the new functionality offered in
        XSLT 2.0, compared with XSLT 1.0. These are arranged in
        three groups. Firstly, the changes that pervade the entire
        text. Secondly, the major new features introduced. And
        thirdly, a catalog of minor technical changes.</p>

        <p>Changes since the <span>November 2006 Proposed
        Recommendation</span> are listed separately: see <a href=
        "#changes-2007-01"><i>J.2.4 Changes since Proposed
        Recommendation</i></a>.</p>

        <p>In addition to these changes, reported <a href=
        "http://www.w3.org/1999/11/REC-xslt-19991116-errata/">errors</a>
        in XSLT 1.0 have been fixed.</p>

        <div class="div3">
          <h4><a name="pervasive-changes" id=
          "pervasive-changes"></a>J.2.1 Pervasive changes</h4>

          <ul>
            <li>
              <p>There has been significant re-arrangement of the
              text. More terminology definitions have been
              hyperlinked, and a glossary (see <a href=
              "#glossary"><i>C Glossary</i></a>) has been added.
              Additional appendices summarize the error conditions
              and implementation-defined features of the
              specification.</p>
            </li>

            <li>
              <p>The specifications of many features (for example
              keys, <a href=
              "#element-number"><code>xsl:number</code></a>, the
              <a href=
              "#function-format-number"><code>format-number</code></a>
              function, the <a href=
              "#element-import"><code>xsl:import</code></a>
              mechanism, and the description of attribute sets)
              have been rewritten to make them clearer and more
              precise.</p>
            </li>

            <li>
              <p>Many changes have been made to support the
              <span>XDM</span> data model, notably the support for
              sequences as a replacement for the node-sets of XPath
              1.0. This has affected the specification of elements
              such as <a href=
              "#element-for-each"><code>xsl:for-each</code></a>,
              <a href=
              "#element-value-of"><code>xsl:value-of</code></a>,
              and <a href=
              "#element-sort"><code>xsl:sort</code></a>, and has
              led to the introduction of new instructions such as
              <a href=
              "#element-sequence"><code>xsl:sequence</code></a>.</p>
            </li>

            <li>
              <p>The processing model is described differently:
              instead of instructions "writing to the result tree",
              they now return sequences of values. This change is
              largely one of terminology, but it also means that it
              is now possible for XSLT stylesheets to manipulate
              arbitrary sequences, including sequences containing
              parentless element or attribute nodes.</p>
            </li>

            <li>
              <p>The description of the evaluation context has been
              changed. The concepts of current node and current
              node list have been replaced by the XPath concepts of
              context item, context position, and context size.</p>
            </li>

            <li>
              <p>With the introduction of support for XML Schema
              within XPath 2.0, XSLT now supports stronger data
              typing, while retaining backwards compatibility. In
              particular, the types of variables and parameters can
              now be specified explicitly, and schema validation
              can be invoked for result trees and for elements and
              attributes in temporary trees.</p>
            </li>

            <li>
              <p>The description of error handling has been
              improved (see <a href="#errors"><i>2.9 Error
              Handling</i></a>). This formalizes the difference
              between static and dynamic errors, and tightens the
              rules that define which errors must be signaled under
              which conditions.</p>
            </li>

            <li>
              <p>The terms <a title="implementation-defined" href=
              "#dt-implementation-defined">implementation-defined</a>
              and <a title="implementation-dependent" href=
              "#dt-implementation-dependent">implementation-dependent</a>
              are now defined and used consistently, and a
              checklist of implementation-defined features is
              provided (see <a href=
              "#implementation-defined-features"><i>F Checklist of
              Implementation-Defined Features</i></a>).</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="major-features" id=
          "major-features"></a>J.2.2 Major Features</h4>

          <ul>
            <li>
              <p>XSLT 2.0 is designed to work with XPath 2.0 rather
              than XPath 1.0. This brings an enhanced data model
              with a type system based on sequences of nodes or
              atomic values, support for all the built-in types
              defined in XML Schema, and a wide range of new
              functions and operators.</p>
            </li>

            <li>
              <p>The result tree fragment data-type is eliminated.
              <a title="variable-binding element" href=
              "#dt-variable-binding-element">A variable-binding
              element</a> with content (and no <code>as</code>
              attribute) now constructs a <a title="temporary tree"
              href="#dt-temporary-tree">temporary tree</a>, and the
              value of the variable is the root node of this tree
              (see <a href="#variable-values"><i>9.3 Values of
              Variables and Parameters</i></a>). With an
              <code>as</code> attribute, a variable-binding element
              may be used to construct an arbitrary sequence. These
              features eliminate the need for the
              <code>xx:node-set</code> extension function provided
              by many XSLT 1.0 implementations.</p>
            </li>

            <li>
              <p>Facilities are introduced for grouping of nodes
              (the <a href=
              "#element-for-each-group"><code>xsl:for-each-group</code></a>
              instruction, and the <code>current-group()</code> and
              <code>current-grouping-key()</code> functions). See
              <a href="#grouping"><i>14 Grouping</i></a></p>
            </li>

            <li>
              <p>It is now possible to create user-defined
              functions within the stylesheet, that can be called
              from XPath expressions. See <a href=
              "#stylesheet-functions"><i>10.3 Stylesheet
              Functions</i></a>.</p>
            </li>

            <li>
              <p>A transformation is allowed to produce multiple
              result trees. See <a href=
              "#creating-result-trees"><i>19.1 Creating Final
              Result Trees</i></a>.</p>
            </li>

            <li>
              <p>A new instruction <a href=
              "#element-analyze-string"><code>xsl:analyze-string</code></a>
              is provided to process text by matching it against a
              regular expression.</p>
            </li>

            <li>
              <p>It is possible to declare the types of variables
              and parameters, and the result types of templates and
              functions. The types may either be built-in types, or
              user-defined types imported from a schema using a new
              <a href=
              "#element-import-schema"><code>xsl:import-schema</code></a>
              declaration.</p>
            </li>

            <li>
              <p>A stylesheet is able to attach type annotations to
              elements and attributes in a result tree, and also in
              temporary trees, and to make use of any type
              annotations that exist in a source tree. Result trees
              and temporary trees can be validated against a
              schema.</p>
            </li>

            <li>
              <p>A transformation may now be invoked by calling a
              named template. This creates the potential for a
              transformation to process large collections of input
              documents. <span>The input to such a transformation
              may be obtained using the <a href=
              "http://www.w3.org/TR/xpath-functions/#func-collection">
              <code>collection</code></a><sup><small>FO</small></sup>
              function defined in <a href=
              "#xpath-functions">[Functions and Operators]</a>, or
              it may be supplied as a <a title=
              "stylesheet parameter" href=
              "#dt-stylesheet-parameter">stylesheet
              parameter</a>.</span></p>
            </li>

            <li>
              <p>Comparisons between values used for grouping, for
              sorting, and for keys can be performed using the
              rules for any supported data type, including the
              ability to select named collations for performing
              string comparison. These complement the new
              facilities in XPath 2.0, which are also invoked
              automatically when matching template rules.</p>
            </li>

            <li>
              <p>The <a href=
              "#element-for-each"><code>xsl:for-each</code></a>
              instruction is able to process any sequence, not only
              a sequence of nodes.</p>
            </li>

            <li>
              <p>An XHTML output method has been added. The details
              are described in <a href=
              "#xslt-xquery-serialization">[XSLT and XQuery
              Serialization]</a>.</p>
            </li>

            <li>
              <p>A <code>collation</code> attribute has been added
              to the <a href=
              "#element-sort"><code>xsl:sort</code></a> element to
              allow sorting using a user-defined collation.</p>
            </li>

            <li>
              <p>A new <a href=
              "#element-next-match"><code>xsl:next-match</code></a>
              is provided to allow multiple template rules to be
              applied to the same source node.</p>
            </li>

            <li>
              <p>A new <a href=
              "#element-character-map"><code>xsl:character-map</code></a>
              declaration is available to control the serialization
              of individual characters. This is intended as a
              replacement for some use-cases where
              <code>disable-output-escaping</code> was previously
              necessary.</p>
            </li>

            <li>
              <p>Functions have been added for formatting dates and
              times. See <a href="#format-date"><i>16.5 Formatting
              Dates and Times</i></a></p>
            </li>

            <li>
              <p>The new facility of <a title="tunnel parameter"
              href="#dt-tunnel-parameter">tunnel parameters</a>
              allows parameters to be set that affect an entire
              phase of the transformation, without requiring them
              to be passed explicitly in every template call.</p>
            </li>

            <li>
              <p>Many instructions that previously constructed a
              value using child instructions can now alternatively
              construct the value using a <code>select</code>
              attribute; and conversely, instructions that
              previously required a <code>select</code> attribute
              can now use child instructions.</p>
            </li>

            <li>
              <p>The <a href=
              "#element-template"><code>xsl:template</code></a>
              declaration can now declare a template rule that
              applies to several different modes; and the <a href=
              "#element-apply-templates"><code>xsl:apply-templates</code></a>
              instruction can cause processing to continue in the
              current mode.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="minor-changes" id="minor-changes"></a>J.2.3
          Minor Changes</h4>

          <ul>
            <li>
              <p>Instead of allowing the output method complete
              freedom to add namespace nodes, a process of
              namespace fixup is applied to the result tree before
              it is output; this same namespace fixup process is
              also applied to documents constructed using
              variable-binding elements with content (see <a href=
              "#namespace-fixup"><i>5.7.3 Namespace
              Fixup</i></a>).</p>
            </li>

            <li>
              <p>Support for XML Base has been added.</p>
            </li>

            <li>
              <p>An <a href=
              "#element-apply-imports"><code>xsl:apply-imports</code></a>
              element is allowed to have parameters (see <a href=
              "#apply-imports"><i>6.7 Overriding Template
              Rules</i></a> and <a href="#with-param"><i>10.1.1
              Passing Parameters to Templates</i></a>).</p>
            </li>

            <li>
              <p><a title="extension function" href=
              "#dt-extension-function">Extension functions</a> are
              allowed to return external objects, which do not have
              any of the builtin XPath types.</p>
            </li>

            <li>
              <p>The specification for patterns (<a href=
              "#patterns"><i>5.5 Patterns</i></a>) has been revised
              to align it with the new XPath grammar. The formal
              semantics of patterns has been simplified: this
              became possible because of the extra compositionality
              now available in the expression grammar. The syntax
              and semantics of patterns remains essentially
              unchanged, except that XPath 2.0 expressions can be
              used within predicates.</p>
            </li>

            <li>
              <p>A backwards-compatible processing mode is
              introduced. See <a href="#backwards"><i>3.8
              Backwards-Compatible Processing</i></a></p>
            </li>

            <li>
              <p>The <a href=
              "#function-system-property"><code>system-property</code></a>
              function now always returns a string. Several new
              system properties have been defined. See <a href=
              "#system-property"><i>16.6.5
              system-property</i></a>.</p>
            </li>

            <li>
              <p>With <code>&lt;xsl:message
              terminate="yes"&gt;</code>, the processor now
              <em><span class="verb">must</span></em> terminate
              processing. Previously the word <em><span class=
              "verb">should</span></em> was used. See <a href=
              "#message"><i>17 Messages</i></a>.</p>
            </li>

            <li>
              <p>A number of new serialization parameters have been
              introduced.</p>
            </li>

            <li>
              <p>A new instruction <a href=
              "#element-namespace"><code>xsl:namespace</code></a>
              is available, for creating namespace nodes: see
              <a href="#creating-namespace-nodes"><i>11.7 Creating
              Namespace Nodes</i></a>.</p>
            </li>

            <li>
              <p>A new instruction <a href=
              "#element-perform-sort"><code>xsl:perform-sort</code></a>
              is available, for returning a sorted sequence.</p>
            </li>

            <li>
              <p>A new <code>[xsl:]xpath-default-namespace</code>
              attribute is available to define the default
              namespace for unqualified names in an XPath
              expression or XSLT pattern.</p>
            </li>

            <li>
              <p>The attributes <code>[xsl:]version</code>,
              <code>[xsl:]exclude-result-prefixes</code>, and
              <code>[xsl:]extension-element-prefixes</code>, as
              well as the new
              <code>[xsl:]xpath-default-namespace</code> and
              <code>[xsl:]default-collation</code>, can be used on
              any <a title="XSLT element" href=
              "#dt-xslt-element">XSLT element</a>, not only on
              <a href=
              "#element-stylesheet"><code>xsl:stylesheet</code></a>
              and on literal result elements as before. In
              particular, they can now be used on the <a href=
              "#element-template"><code>xsl:template</code></a>
              element.</p>
            </li>

            <li>
              <p>A new <a href=
              "#function-unparsed-text"><code>unparsed-text</code></a>
              function is introduced. It allows the contents of an
              external text file to be read as a string.</p>
            </li>

            <li>
              <p>Restrictions on the use of variables within
              patterns and key definitions have been removed; in
              their place a more general statement of the
              restrictions preventing circularity has been
              formulated. The <a href=
              "#function-current"><code>current</code></a> function
              may also now be used within patterns.</p>
            </li>

            <li>
              <p>The built-in templates for element and document
              nodes now pass any supplied parameter values on to
              the templates that they call.</p>
            </li>

            <li>
              <p>A detailed specification of the <a href=
              "#function-format-number"><code>format-number</code></a>
              function is now provided, removing the reliance on
              specifications in Java JDK 1.1.</p>
            </li>
          </ul>
        </div>

        <div class="div3">
          <h4><a name="changes-2007-01" id=
          "changes-2007-01"></a>J.2.4 Changes since Proposed
          Recommendation</h4>

          <p>The following changes have been made since publication
          of the <a href=
          "http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed
          Recommendation</a>. Each change contains a reference to
          its discussion and rationale, for example the relevant
          issue number in the <a href=
          "http://www.w3.org/Bugs/Public/">W3C public Bugzilla
          database</a>.</p>

          <ul>
            <li>
              <p>In <a href="#analyze-string"><i>15.1 The
              xsl:analyze-string instruction</i></a>, the paragraph
              describing the permitted contents of the instruction
              has been clarified. (The sentence "Both elements are
              optional, and neither may appear more than once." was
              considered awkward). This editorial change was made
              in response to a <a href=
              "http://lists.w3.org/Archives/Public/public-qt-comments/2006Jan/0083">
              public comment</a> made during the Candidate
              Recommendation phase.</p>
            </li>

            <li>
              <p>In <a href="#result-trees"><i>19 Final Result
              Trees</i></a> it was stated that the result of a
              transformation consisted of zero or more result
              trees; while <a href=
              "#executing-a-transformation"><i>2.4 Executing a
              Transformation</i></a> stated (correctly) that it
              consisted of one or more. The former statement has
              been revised. A cross-reference between the two
              sections has been added for clarification. (Bugzilla
              4031)</p>
            </li>

            <li>
              <p>Some trivial syntax errors in examples have been
              fixed. (Bugzilla 4149)</p>
            </li>
          </ul>

          <p>The <a href=
          "http://www.w3.org/TR/2006/PR-xslt20-20061121/">Proposed
          Recommendation</a> contains a complete list of published
          working drafts prepared during the development of this
          specification, and a detailed history of changes may be
          assembled by viewing the change log present in each
          draft. For most of the drafts, a version is available in
          which changes are visually highlighted.</p>
        </div>
      </div>
    </div>
  </div>
</body>
</html>
